{"version":3,"sources":["../src/connectors/gnosis-safe.ts","../src/connectors/magic.ts","../src/constants/chain.ts","../src/contexts/thirdweb-config.tsx","../src/hooks/useSigner.ts","../src/Provider.tsx","../src/utils/cache-keys.ts","../src/hooks/auth/useLogin.ts","../src/hooks/auth/useLogout.ts","../src/hooks/auth/useUser.ts","../src/hooks/contracts/useBuiltinContract.ts","../src/hooks/contracts/useEditionDrop.ts","../src/hooks/contracts/useEdition.ts","../src/hooks/contracts/useNFTDrop.ts","../src/hooks/contracts/useMarketplace.ts","../src/hooks/contracts/useNFTCollection.ts","../src/hooks/contracts/usePack.ts","../src/hooks/contracts/useToken.ts","../src/hooks/contracts/useTokenDrop.ts","../src/hooks/contracts/useVote.ts","../src/hooks/contracts/useSplit.ts","../src/hooks/contracts/useMultiwrap.ts","../src/hooks/contracts/useSignatureDrop.ts","../src/hooks/useConnect.ts","../src/hooks/useDisconnect.ts","../src/hooks/useAddress.ts","../src/hooks/useReadonlySDK.ts","../src/utils/isMobile.ts","../src/hooks/connectors/useMetamask.ts","../src/hooks/connectors/useWalletConnect.ts","../src/hooks/connectors/useWalletLink.ts","../src/hooks/connectors/useGnosis.ts","../src/hooks/connectors/useMagic.ts","../src/hooks/useChainId.ts","../src/hooks/useNetworkMismatch.ts","../src/hooks/useNetwork.ts","../src/index.ts","../src/constants/ipfs.ts","../src/utils/ipfs.ts","../src/utils/media.ts","../src/utils/react.ts","../src/components/Icons.tsx","../src/components/MediaRenderer.tsx","../src/components/NftMedia.tsx","../src/hooks/query-utils/useQueryWithNetwork.ts","../src/hooks/async/contracts.ts","../src/hooks/async/nft.ts","../src/hooks/async/drop.ts","../src/hooks/async/marketplace.ts","../src/hooks/async/token.ts","../src/hooks/async/claim-conditions.ts","../src/hooks/async/wallet.ts","../src/hooks/async/contract-settings.ts","../src/hooks/async/roles.ts"],"names":["ChainId","ethers","utils","invariant","Connector","normalizeChainId","CHAIN_ID_TO_GNOSIS_SERVER_URL","Mainnet","Avalanche","Polygon","Goerli","Rinkeby","__IS_SERVER__","window","GnosisSafeConnector","id","ready","name","constructor","config","_a","chains","filter","c","options","undefined","connect","safeSigner","createSafeSigner","account","getAccount","provider","getProvider","getChainId","chain","unsupported","isChainUnsupported","_b","_c","signer","previousConnector","getSigner","safeAddress","safeChainId","signerChainId","serverUrl","safeEthersAdapters","safeCoreSdk","safeEthersLib","Promise","all","ethAdapter","default","safe","create","service","SafeService","SafeEthersSigner","disconnect","getAddress","isAuthorized","onAccountsChanged","accounts","length","emit","chainId","onChainChanged","onDisconnect","setConfiguration","connector","providers","LOCAL_STORAGE_KEY","MagicConnector","getConfiguration","localStorage","getItem","configuration","JSON","parse","doNotAutoConnect","isAutoConnect","apiKey","rpcUrls","showUI","then","m","magic","Magic","auth","loginWithMagicLink","on","e","removeListener","switchChain","network","rpcUrl","find","Web3Provider","rpcProvider","some","x","setItem","stringify","removeItem","NATIVE_TOKENS","mainnet","nativeCurrency","blockExplorers","url","rinkeby","testnet","goerli","polygonMainnet","polygonTestnetMumbai","Mumbai","avalanche","avalancheFujiTestnet","AvalancheFujiTestnet","fantom","Fantom","fantomTestnet","FantomTestnet","optimism","Optimism","optimismTestnet","OptimismTestnet","arbitrum","Arbitrum","arbitrumTestnet","ArbitrumTestnet","defaultSupportedChains","Object","values","React","createContext","useContext","defaultChainRpc","ThirdwebConfigContext","rpcUrlMap","supportedChains","ThirdwebConfigProvider","__name","value","children","Provider","useThirdwebConfigContext","Signer","useEffect","useRef","useAccount","useNetwork","useSigner","useWagmiSigner","_d","_e","_getSignerPromise","address","data","previousAddress","usePrevious","previousChainId","current","finally","isSigner","ref","QueryClient","QueryClientProvider","ThirdwebSDK","getProviderForNetwork","useMemo","WagmiProvider","useProvider","CoinbaseWalletConnector","InjectedConnector","WalletConnectConnector","_extends","defaultdAppMeta","defaultWalletConnectors","ThirdwebProvider","sdkOptions","chainRpc","map","walletConnectors","dAppMeta","desiredChainId","authConfig","storageInterface","queryClient","autoConnect","_supporrtedChains","sc","_rpcUrlMap","reduce","prev","curr","_authConfig","authUrl","replace","wagmiProps","walletConnectClientMeta","icons","logoUrl","description","walletLinkClientMeta","appName","appLogoUrl","darkMode","isDarkMode","connectorStorageKey","connectors","shimDisconnect","shimChainChangedDisconnect","rpc","clientMeta","qrcode","jsonRpcUrl","readonlySettings","console","error","sdkOptionsWithDefaults","ThirdwebSDKProviderWagmiWrapper","props","ThirdwebSDKProvider","ThirdwebSDKContext","queryClientWithDefault","sdk","_sdk","_chainId","updateSignerOrProvider","ctxValue","_inProvider","client","useSDKContext","ctx","useSDK","useDesiredChainId","useActiveChainId","constants","TW_CACHE_KEY_PREFIX","createCachekey","input","createContractCacheKey","contractAddress","AddressZero","createCacheKeyWithNetwork","cacheKeys","active","concat","invalidateContractAndBalances","invalidateQueries","user","wallet","balance","walletAddress","tokenAddress","contract","type","compilerMetadata","typeAndCompilerMetadata","metadata","extractFunctions","call","functionName","args","events","getEvents","eventName","getAllEvents","nft","get","tokenId","balanceOf","owner","query","params","totalCirculatingSupply","totalCount","owned","drop","getAllUnclaimed","totalUnclaimedSupply","totalClaimedSupply","token","totalSupply","marketplace","getListing","listingId","getAllListings","getActiveListings","getBidBufferBps","auction","getWinningBid","getWinner","extensions","claimConditions","getActive","getAll","getClaimIneligibilityReasons","sales","getRecipient","royalties","getDefaultRoyaltyInfo","platformFees","roles","role","useQueryClient","useLogin","URLSearchParams","location","search","onError","decodeURI","login","cfg","payload","domain","encodedPayload","encodeURIComponent","btoa","encodedRedirectTo","redirectTo","loginRedirect","href","useLogout","logout","useQuery","useUser","isLoading","fetch","json","useBuiltinContract","contractType","getBuiltInContract","useEditionDrop","useEdition","useNFTDrop","useMarketplace","useNFTCollection","usePack","useToken","useTokenDrop","useVote","useSplit","useMultiwrap","useSignatureDrop","useConnect","useWagmiConnect","useDisconnect","optsWithDefaults","reconnectAfterGnosis","err","useAddress","useReadonlySDK","readonlyRpcUrl","detect","detectEnv","userAgent","isAndroid","os","detectOS","toLowerCase","includes","isIOS","navigator","maxTouchPoints","env","isMobile","useMetamask","loading","reject","isMetaMaskInjected","ethereum","isMetaMask","shouldUseWalletConnect","injectedConnector","walletConnectConnector","uri","host","pathname","warn","open","resolve","Error","useWalletConnect","useCoinbaseWallet","useWalletLink","useGnosis","previousConnectorChain","isAddress","useMagic","useChainId","useNetworkMismatch","activeChainId","useWagmiNetwork","defaultChains","defaultL2Chains","IpfsStorage","DEFAULT_IPFS_GATEWAY","DEFAULT_IPFS_RESOLVER_OPTIONS","gatewayUrl","mime","resolveIpfsUri","startsWith","resolveMimeType","mimeType","getType","res","method","ok","headers","has","video","supportsVideoType","document","createElement","canPlayType","shouldRenderVideoTag","audio","supportsAudioType","shouldRenderAudioTag","mergeRefs","refs","forEach","CarbonDocumentUnknown","svg","width","height","viewBox","circle","cx","cy","r","fill","path","d","CarbonDocumentAudio","CarbonPauseFilled","CarbonPlayFilledAlt","useState","useDimensions","PlayButton","onClick","isPlaying","isHovering","setIsHovering","onMouseEnter","onMouseLeave","onMouseDown","onMouseUp","button","style","position","bottom","right","transform","maxWidth","minWidth","aspectRatio","zIndex","backgroundColor","color","display","placeItems","borderRadius","border","cursor","boxShadow","VideoPlayer","forwardRef","src","alt","poster","requireInteraction","controls","restProps","videoRef","playing","setPlaying","muted","setMuted","play","pause","currentTime","div","loop","playsInline","preload","onCanPlay","objectFit","transition","opacity","img","pointerEvents","top","left","AudioPlayer","audioRef","visibility","IframePlayer","observe","elWidth","LinkPlayer","iframe","flexDirection","gap","alignItems","flexWrap","a","rel","textDecoration","target","MediaRenderer","mergedStyle","videoOrImageSrc","useResolvedMediaType","possiblePosterSrc","resolvedUrl","resolvedMimType","enabled","ThirdwebNftMedia","animation_url","image","useQueryWithNetwork","queryKey","queryFn","mergedOptions","useMutation","CONTRACTS_MAP","SmartContract","fetchContractType","resolveContractType","fetchContractCompilerMetadata","getPublisher","fetchCompilerMetadataFromAddress","fetchContractTypeAndCompilerMetadata","fetchQuery","staleTime","Infinity","getContractAbi","contractAbi","abi","getContractFromCombinedTypeAndCompilerMetadata","getContractFromAbi","useContractAbi","contractTypeAndCompilerMetadata","useContractTypeAndCompilerMetadata","useContractType","useContractCompilerMetadata","useContract","useContractMetadata","useContractFunctions","publishedMetadata","useContractData","useContractCall","callParams","onSettled","useAllContractEvents","subscribe","queryEnabled","cacheKey","listenToAllEvents","contractEvent","setQueryData","oldData","findIndex","transaction","transactionHash","logIndex","queryFilter","refetchOnWindowFocus","refetchOnMount","refetchOnReconnect","useContractEvents","Erc721","Erc1155","BigNumber","convertResponseToNFTType","supply","convertResponseToNFTTypeArray","useNFT","from","useNFTs","queryParams","keepPreviousData","useTotalCirculatingSupply","useTotalCount","useOwnedNFTs","ownerWalletAddress","useNFTBalance","useMintNFT","to","mint","useMintNFTSupply","additionalSupplyTo","additionalSupply","useTransferNFT","transfer","amount","useAirdropNFT","addresses","airdrop","useBurnNFT","burn","tokens","useUnclaimedNFTs","useClaimedNFTs","useUnclaimedNFTSupply","useClaimedNFTSupply","getTotalCount","useClaimNFT","claimTo","quantity","checkERC20Allowance","useLazyMint","onProgress","lazyMint","metadatas","ListingType","useListing","useListings","useActiveListings","useWinningBid","useAuctionWinner","winner","message","useBidBuffer","useCreateDirectListing","direct","createListing","useCreateAuctionListing","useMakeBid","makeBid","bid","useBuyNow","Direct","buyoutListing","buyAmount","buyForWallet","useTokenSupply","useTokenBalance","useMintToken","useClaimToken","useTransferToken","useTransferBatchToken","transferBatch","convertedData","toAddress","useBurnToken","useActiveClaimCondition","useClaimConditions","useClaimIneligibilityReasons","UserWallet","useBalance","walletSDK","retry","usePrimarySaleRecipient","useUpdatePrimarySaleRecipient","newRecipient","setRecipient","useRoyaltySettings","useUpdateRoyaltySettings","updatePayload","setDefaultRoyaltyInfo","usePlatformFees","useUpdatePlatformFees","set","useMetadata","useUpdateMetadata","update","useAllRoleMembers","useRoleMembers","useIsAddressRole","contractHasRoles","useSetAllRoleMembers","rolesWithAddresses","setAll","useGrantRole","grant","useRevokeRole","revoke"],"mappings":";yCAAA,OAASA,WAAAA,OAAe,iCACxB,OAAiBC,UAAAA,GAAQC,SAAAA,OAAa,SACtC,OAAOC,OAAe,iBACtB,OAAgBC,aAAAA,GAA0BC,oBAAAA,OAAwB,QAElE,IAAMC,GAAgC,CACpC,CAACN,GAAQO,SAAU,6CACnB,CAACP,GAAQQ,WAAY,+CACrB,CAACR,GAAQS,SAAU,6CACnB,CAACT,GAAQU,QAAS,4CAClB,CAACV,GAAQW,SAAU,8CAQfC,GAAgB,OAAOC,OAAW,IAE3BC,EAAN,cAAkCV,EAAS,CAChDW,GAAK,SACLC,MAAQJ,GACRK,KAAO,cAMPC,YAAYC,EAA8B,CA7B5C,IAAAC,EA+BID,EAAOE,QAASF,EAAAA,EAAOE,SAAPF,YAAAA,EAAeG,OAC5BC,GAAMA,EAAER,MAAMT,IAEjB,MAAM,CAAE,GAAGa,EAAQK,QAASC,OAAW,EAElCb,KACH,KAAKI,MAAQ,IAIjB,MAAMU,SAAuC,CAC3C,KAAKC,WAAa,MAAM,KAAKC,iBAAgB,EAC7C,IAAMC,EAAU,MAAM,KAAKC,WAAU,EAC/BC,EAAW,MAAM,KAAKC,YAAW,EACjCjB,EAAK,MAAM,KAAKkB,WAAU,EAChC,MAAO,CACLJ,QAAAA,EACAE,SAAAA,EACAG,MAAO,CAAEnB,GAAAA,EAAIoB,YAAa,KAAKC,mBAAmBrB,CAAE,IAIxD,MAAca,kBAAmB,CArDnC,IAAAR,EAAAiB,EAAAC,EAsDI,IAAMC,EAAS,OAAMnB,EAAA,KAAKoB,oBAAL,YAAApB,EAAwBqB,aACvCC,GAAcL,EAAA,KAAKlB,SAAL,YAAAkB,EAAaK,YAC3BC,GAAcL,EAAA,KAAKnB,SAAL,YAAAmB,EAChBK,YACJxC,GACEoC,EACA,4DAA4D,EAE9D,IAAMK,EAAgB,MAAML,EAAON,WAAU,EAC7C9B,GACEyC,IAAkBD,EAClB,sDAAsD,EAExDxC,GACEuC,EACA,2EAA2E,EAE7EvC,GACEwC,EACA,2EAA2E,EAE7E,IAAME,EAAYvC,GAA8BqC,GAChDxC,GAAU0C,EAAW,qBAAqB,EAE1C,GAAM,CAACC,EAAoBC,EAAaC,CAAa,EAAI,MAAMC,QAAQC,IAAI,CACzE,OAAO,mCACP,OAAO,4BACP,OAAO,8BACR,EAGKC,EAAa,IAAIH,EAAcI,QAAQA,QAAQ,CAAEnD,OAAAA,GAAQsC,OAAAA,EAAQ,EAEjEc,EAAO,MAAMN,EAAYK,QAAQA,QAAQE,OAAO,CACpDH,WAAAA,EACAT,YAAAA,EACD,EACKa,EAAU,IAAIT,EAAmBU,YAAYX,CAAS,EAC5D,OAAO,IAAIC,EAAmBW,iBAC5BJ,EACAE,EACAhB,EAAOR,QAAQ,EAInB,MAAM2B,YAA4B,CAChC,KAAKvC,OAASM,OACd,KAAKE,WAAaF,OAClB,KAAKe,kBAAoBf,OAI3B,MAAMK,YAA8B,CAElC,OAAO,MADQ,MAAM,KAAKW,UAAS,GACfkB,WAAU,EAGhC,MAAM1B,YAA8B,CAClC,OAAQ,MAAM,KAAKQ,UAAS,GAAIR,WAAU,EAG5C,MAAMD,aAAc,CAClB,OAAQ,MAAM,KAAKS,UAAS,GAAIV,SAGlC,MAAMU,WAA6B,CACjC,OAAK,KAAKd,aACR,KAAKA,WAAa,MAAM,KAAKC,iBAAgB,GAExC,KAAKD,WAGd,MAAMiC,cAAiC,CACrC,GAAI,CAEF,MAAO,CAAC,CADQ,MAAM,KAAK9B,WAAU,OAErC,CACA,MAAO,IAID+B,kBAAkBC,EAAoB,CAC1CA,EAASC,SAAW,EACtB,KAAKC,KAAK,YAAY,EAEtB,KAAKA,KAAK,SAAU,CAAEnC,QAAS3B,GAAMyD,WAAWG,EAAS,EAAE,EAAG,EAI/C1B,mBAAmB6B,EAAiB,CA/IzD,IAAA7C,EAgJI,OAAOA,EAAA,KAAKD,SAAL,MAAAC,EAAauB,YAChBsB,IAAY,KAAK9C,OAAOwB,YACxB,GAGIuB,eAAeD,EAA0B,CACjD,IAAMlD,EAAKV,GAAiB4D,CAAO,EAC7B9B,EAAc,KAAKC,mBAAmBrB,CAAE,EAC9C,KAAKiD,KAAK,SAAU,CAAE9B,MAAO,CAAEnB,GAAAA,EAAIoB,YAAAA,GAAe,EAG1CgC,cAAe,CACvB,KAAKH,KAAK,YAAY,EAGjBI,iBACLC,EACAlD,EACA,CACA,KAAKqB,kBAAoB6B,EACzB,KAAKlD,OAASA,IAhJLL,EAAAA,EAAAA,uBCpBb,OAASwD,aAAAA,GAAWpE,SAAAA,OAAa,SAMjC,OAAOC,OAAe,iBACtB,OAAgBC,aAAAA,GAAWC,oBAAAA,OAAwB,QASnD,IAAMO,GAAgB,OAAOC,OAAW,IAElC0D,GAAoB,6BAEbC,GAAN,cAA6BpE,EAAS,CAClCW,GAAK,QACLE,KAAO,QACPD,MAAQJ,GAMjB6D,kBAAmB,CACjB,GAAI7D,GACF,OAGF,IAAMO,EAASN,OAAO6D,aAAaC,QAAQJ,EAAiB,EAC5D,OAAIpD,IACF,KAAKyD,cAAgBC,KAAKC,MAAM3D,CAAM,GAEjC,KAAKyD,cAGd1D,YAAYC,EAAgE,CAI1E,GAHA,MAAM,CAAE,GAAGA,EAAQK,QAASL,GAAAA,YAAAA,EAAQK,QAAS,EAC7C,KAAKA,QAAUL,EAAOK,QAElB,CAACZ,GAAe,CAElB,GADA,KAAKI,MAAQ,GACT,KAAKQ,QAAQuD,kBAAoB,CAAC,KAAKN,iBAAgB,EACzD,OAEF,KAAK/C,QAAQ,EAAI,GAIrB,MAAMA,QAAQsD,EAAsB,CAClC,GAAM,CAAEC,OAAAA,EAAQF,iBAAAA,EAAkBG,QAAAA,KAAY1D,CAAO,EAAK,KAAKA,QACzDoD,EAAgB,KAAKH,iBAAgB,EAE3C,GAAI,CACFtE,OAAAA,GACEyE,EACA,kEAAkE,EAEhEI,IACFJ,EAAcO,OAAS,IAGlB,OAAO,qBAAaC,KAAK,MAAOC,GAAM,CAC3C,KAAKC,MAAQ,IAAID,EAAEE,MAAMN,EAAQzD,CAAO,EAExC,MAAM,KAAK8D,MAAME,KAAKC,mBAAmBb,CAAa,EACtD,IAAM7C,EAAW,KAAKC,YAAW,EAC7BD,EAAS2D,KACX3D,EAAS2D,GAAG,kBAAmB,KAAK7B,iBAAiB,EACrD9B,EAAS2D,GAAG,eAAgB,KAAKxB,cAAc,EAC/CnC,EAAS2D,GAAG,aAAc,KAAKvB,YAAY,GAE7C,IAAMtC,EAAU,MAAM,KAAKC,WAAU,EAC/Bf,EAAK,MAAM,KAAKkB,WAAU,EAChC,MAAO,CACLJ,QAAAA,EACAE,SAAAA,EACAG,MAAO,CAAEnB,GAAAA,EAAIoB,YAAa,KAAKC,mBAAmBrB,CAAE,IAEvD,QACM4E,EAAP,CACA,GAAI,CAACX,EACH,MAAMW,EAER,MAAO,CACL9D,QAASJ,OACTM,SAAUN,OACVS,MAAOT,SAIb,MAAMiC,YAAa,CACjB,IAAM3B,EAAW,KAAKC,YAAW,EAC7BD,GAAAA,MAAAA,EAAU6D,iBACZ7D,EAAS6D,eAAe,kBAAmB,KAAK/B,iBAAiB,EACjE9B,EAAS6D,eAAe,eAAgB,KAAK1B,cAAc,EAC3DnC,EAAS6D,eAAe,aAAc,KAAKzB,YAAY,GAEzD,KAAKC,iBAAiB3C,MAAS,EAGjC,MAAeoE,YAAY5B,EAAiB,CAC1C9D,GAAU,CAAC,KAAKiC,mBAAmB6B,CAAO,EAAG,wBAAwB,EACrE,IAAMlC,EAAW,KAAKC,YAAW,EACjC,OAAID,GAAAA,MAAAA,EAAU6D,iBACZ7D,EAAS6D,eAAe,kBAAmB,KAAK/B,iBAAiB,EACjE9B,EAAS6D,eAAe,eAAgB,KAAK1B,cAAc,EAC3DnC,EAAS6D,eAAe,aAAc,KAAKzB,YAAY,GAGzD,KAAK3C,QAAQsE,QAAU,CACrB7B,QAAAA,EACA8B,OAAQ,KAAKvE,QAAQ0D,QAAQjB,IAE/B,MAAM,KAAKvC,QAAO,EAClB,KAAKwC,eAAeD,CAAO,EACpB,KAAK5C,OAAO2E,KAAMzE,GAAMA,EAAER,KAAOkD,CAAO,EAGjD,MAAMnC,YAAa,CAEjB,OAAO,MADQ,MAAM,KAAKW,UAAS,GACfkB,WAAU,EAEhC,MAAM1B,YAAa,CAEjB,OAAO,MADQ,MAAM,KAAKQ,UAAS,GACfR,WAAU,EAEhCD,aAAc,CACZ7B,OAAAA,GAAU,KAAKmF,MAAO,8BAA8B,EAC7C,IAAIhB,GAAU2B,aACnB,KAAKX,MAAMY,WAAW,EAG1B,MAAMzD,WAAY,CAChB,OAAK,KAAK6C,OACR,MAAM,KAAK5D,QAAO,EAEb,KAAKM,YAAW,EAAGS,UAAS,EAErC,MAAMmB,cAAe,CACnB,GAAI,CAEF,MAAO,CAAC,CADQ,MAAM,KAAK9B,WAAU,OAErC,CACA,MAAO,IAID+B,kBAAkBC,EAAoB,CAC1CA,EAASC,SAAW,EACtB,KAAKC,KAAK,YAAY,EAEtB,KAAKA,KAAK,SAAU,CAAEnC,QAAS3B,GAAMyD,WAAWG,EAAS,EAAE,EAAG,EAI/C1B,mBAAmB6B,EAAiB,CACrD,MAAO,CAAC,KAAK5C,OAAO8E,KAAMC,GAAMA,EAAErF,KAAOkD,CAAO,EAGxCC,eAAeD,EAA0B,CACjD,IAAMlD,EAAKV,GAAiB4D,CAAO,EAC7B9B,EAAc,KAAKC,mBAAmBrB,CAAE,EAC9C,KAAKiD,KAAK,SAAU,CAAE9B,MAAO,CAAEnB,GAAAA,EAAIoB,YAAAA,GAAe,EAG1CgC,cAAe,CACvB,KAAKH,KAAK,YAAY,EAGjBI,iBAAiBQ,EAAiD,CACnEA,GACF,KAAKA,cAAgBA,EACrB/D,OAAO6D,aAAa2B,QAClB9B,GACAM,KAAKyB,UAAU1B,CAAa,CAAC,IAG/B,KAAKA,cAAgBnD,OACrBZ,OAAO6D,aAAa6B,WAAWhC,EAAiB,KApKzCC,EAAAA,GAAAA,kBCpBb,OAASgC,iBAAAA,MAAqB,oBAC9B,OAASxG,WAAAA,MAAe,iCAIxB,IAAMkC,GAA+B,CACnCuE,QAAS,CACP1F,GAAIf,EAAQO,QACZU,KAAM,mBACNyF,eAAgBF,EAAcxG,EAAQO,SACtC2E,QAAS,CAAC,iEACVyB,eAAgB,CACd,CACE1F,KAAM,YACN2F,IAAK,0BAIXC,QAAS,CACP9F,GAAIf,EAAQW,QACZM,KAAM,UACNyF,eAAgBF,EAAcxG,EAAQW,SACtCuE,QAAS,CAAC,iEACVyB,eAAgB,CACd,CACE1F,KAAM,YACN2F,IAAK,iCAGTE,QAAS,IAEXC,OAAQ,CACNhG,GAAIf,EAAQU,OACZO,KAAM,SACNyF,eAAgBF,EAAcxG,EAAQU,QACtCwE,QAAS,CAAC,gEACVyB,eAAgB,CACd,CACE1F,KAAM,YACN2F,IAAK,gCAGTE,QAAS,IAEXE,eAAgB,CACdjG,GAAIf,EAAQS,QACZQ,KAAM,kBACNyF,eAAgBF,EAAcxG,EAAQS,SACtCyE,QAAS,CACP,0BACA,oCACA,2CACA,qCACA,yCACA,gDAEFyB,eAAgB,CACd,CACE1F,KAAM,cACN2F,IAAK,6BAIXK,qBAAsB,CACpBlG,GAAIf,EAAQkH,OACZjG,KAAM,SACNyF,eAAgBF,EAAcxG,EAAQkH,QACtChC,QAAS,CACP,0CACA,oCACA,mDAEFyB,eAAgB,CACd,CACE1F,KAAM,cACN2F,IAAK,mCAGTE,QAAS,IAEXK,UAAW,CACTpG,GAAIf,EAAQQ,UACZS,KAAM,YACNyF,eAAgBF,EAAcxG,EAAQQ,WACtC0E,QAAS,CACP,wCACA,kCAEFyB,eAAgB,CACd,CACE1F,KAAM,YACN2F,IAAK,0BAGTE,QAAS,IAEXM,qBAAsB,CACpBrG,GAAIf,EAAQqH,qBACZpG,KAAM,yBACNyF,eAAgBF,EAAcxG,EAAQqH,sBACtCnC,QAAS,CAAC,8CACVyB,eAAgB,CACd,CACE1F,KAAM,YACN2F,IAAK,kCAGTE,QAAS,IAEXQ,OAAQ,CACNvG,GAAIf,EAAQuH,OACZtG,KAAM,eACNyF,eAAgBF,EAAcxG,EAAQuH,QACtCrC,QAAS,CAAC,yBACVyB,eAAgB,CACd,CACE1F,KAAM,UACN2F,IAAK,yBAGTE,QAAS,IAEXU,cAAe,CACbzG,GAAIf,EAAQyH,cACZxG,KAAM,iBACNyF,eAAgBF,EAAcxG,EAAQyH,eACtCvC,QAAS,CAAC,sCACVyB,eAAgB,CACd,CACE1F,KAAM,UACN2F,IAAK,iCAGTE,QAAS,IAEXY,SAAU,CACR3G,GAAIf,EAAQ2H,SACZ1G,KAAM,WACNyF,eAAgBF,EAAcxG,EAAQ2H,UACtCzC,QAAS,CAAC,+BACVyB,eAAgB,CACd,CACE1F,KAAM,YACN2F,IAAK,qCAGTE,QAAS,IAEXc,gBAAiB,CACf7G,GAAIf,EAAQ6H,gBACZ5G,KAAM,iBACNyF,eAAgBF,EAAcxG,EAAQ6H,iBACtC3C,QAAS,CAAC,6BACVyB,eAAgB,CACd,CACE1F,KAAM,YACN2F,IAAK,2CAGTE,QAAS,IAEXgB,SAAU,CACR/G,GAAIf,EAAQ+H,SACZ9G,KAAM,eACNyF,eAAgBF,EAAcxG,EAAQ+H,UACtC7C,QAAS,CAAC,gCACVyB,eAAgB,CACd,CACE1F,KAAM,WACN2F,IAAK,yBAGTE,QAAS,IAEXkB,gBAAiB,CACfjH,GAAIf,EAAQiI,gBACZhH,KAAM,mBACNyF,eAAgBF,EAAcxG,EAAQiI,iBACtC/C,QAAS,CAAC,mCACVyB,eAAgB,CACd,CACE1F,KAAM,WACN2F,IAAK,iCAGTE,QAAS,KAIAoB,GAAyBC,OAAOC,OAAOlG,EAAK,ECvLzD,OAASlC,WAAAA,MAAe,iCACxB,OAAOqI,IAA4BC,iBAAAA,GAAeC,cAAAA,OAAkB,QAQ7D,IAAMC,GAA6D,CACxE,CAACxI,EAAQO,SAAU,UACnB,CAACP,EAAQW,SAAU,UACnB,CAACX,EAAQU,QAAS,SAClB,CAACV,EAAQS,SAAU,UACnB,CAACT,EAAQkH,QAAS,SAClB,CAAClH,EAAQuH,QAAS,SAClB,CAACvH,EAAQQ,WAAY,aAGViI,GAAwBH,GAAqC,CACxEI,UAAWF,GACXG,gBAAiBT,GAClB,EAEYU,GAITC,EAAA,CAAC,CAAEC,MAAAA,EAAOC,SAAAA,CAAQ,IACpBV,GAAA,cAACI,GAAsBO,SAAQ,CAACF,MAAOA,GACpCC,CAAQ,EAFT,0BAMG,SAASE,GAA2B,CACzC,OAAOV,GAAWE,EAAqB,EADzBQ,EAAAA,EAAAA,4BCxChB,OAASC,UAAAA,OAAc,SACvB,OAASC,aAAAA,GAAWC,UAAAA,OAAc,QAClC,OAASC,cAAAA,GAAYC,cAAAA,GAAYC,aAAaC,OAAsB,QAM7D,SAASD,IAAY,CAR5B,IAAAnI,EAAAiB,EAAAC,EAAAmH,EAAAC,EASE,GAAM,CAACnH,EAAQE,CAAS,EAAI+G,GAAc,EACpC,CAAC3H,CAAO,EAAIwH,GAAU,EACtB,CAACvD,CAAO,EAAIwD,GAAU,EAEtBK,EAAoBP,GAA4C,IAAI,EAEpEQ,GAAU/H,EAAAA,EAAQgI,OAARhI,YAAAA,EAAc+H,QACxB3F,GAAU6B,EAAAA,EAAQ+D,KAAK3H,QAAb4D,YAAAA,EAAoB/E,GAE9B+I,EAAkBC,IAAYlI,EAAAA,EAAQgI,OAARhI,YAAAA,EAAc+H,OAAO,EACnDI,EAAkBD,IAAYjE,GAAAA,EAAAA,EAAQ+D,OAAR/D,YAAAA,EAAc5D,QAAd4D,YAAAA,EAAqB/E,EAAE,EAE3DoI,OAAAA,GAAU,IAAM,CACd,GAAIS,IAAYE,GAAmB7F,IAAY+F,EAC7C,GAAKL,EAAkBM,QAGrBN,EAAkBM,QAAUxH,EAAS,EAAGyH,QAAQ,IAAM,CACpDP,EAAkBM,QAAU,KAC7B,MAJD,SAOH,CAACL,EAAS3F,EAAS6F,EAAiBE,EAAgB,EAEhDd,GAAOiB,SAAS5H,EAAOsH,IAAI,EAAItH,EAAOsH,KAAOpI,OAzBtC8H,EAAAA,GAAAA,aA4BhB,SAASQ,GAAkBjB,EAA+B,CAGxD,IAAMsB,EAAMhB,GAAM,EAElBD,OAAAA,GAAU,IAAM,CACdiB,EAAIH,QAAUnB,GACb,CAACA,EAAM,EAEHsB,EAAIH,QATJF,EAAAA,GAAAA,eCrBT,OAASM,eAAAA,GAAaC,uBAAAA,OAA2B,wBACjD,OAMEC,eAAAA,GACAC,yBAAAA,OACK,iCAGP,OAAOnC,GAASC,iBAAAA,GAAea,aAAAA,GAAWsB,WAAAA,MAAe,QACzD,OAAOtK,OAAe,iBACtB,OACEuK,iBAAAA,GAEAC,eAAAA,OACK,QACP,OAASC,2BAAAA,OAA+B,kCACxC,OAASC,qBAAAA,OAAyB,4BAClC,OAASC,0BAAAA,OAA8B,iCApCvC,SAAAC,IAAA,sMAAAlC,EAAAkC,GAAA,YAuNA,IAAMC,GAAgC,CACpC/J,KAAM,yBAGFgK,GAEF,CAAC,WAAY,gBAAiB,cAwBrBC,GAAmBrC,EAAA,CAE9B,CACAsC,WAAAA,EACAC,SAAAA,EAAW5C,GACXG,gBAAAA,EAAkBT,GAAuBmD,IACtC9J,GAAMA,EAAER,EAAE,EAEbuK,iBAAAA,EAAmBL,GACnBM,SAAAA,EAAWP,GACXQ,eAAAA,EACAC,WAAAA,EACAC,iBAAAA,EACAC,YAAAA,EACAC,YAAAA,EAAc,GACd7C,SAAAA,CAAQ,IAC6D,CAGrE,IAAM8C,EAAoBpB,EAAQ,IACzB9B,EACJ0C,IAAK9J,GACA,OAAOA,GAAM,SACR2G,GAAuBlC,KAAM8F,GAAOA,EAAG/K,KAAOQ,CAAC,EAEjDA,CACR,EACAD,OAAQC,GAAMA,IAAME,MAAS,EAC/B,CAACkH,EAAgB,EAEdoD,EAAatB,EAAQ,IAClBoB,EAAkBG,OAAO,CAACC,EAAMC,KACrCD,EAAKC,EAAKnL,IACRmL,EAAKnL,MAAMqK,EACNZ,GACCY,EAASc,EAAKnL,KACZmL,EAAKhH,QAAQ,EAAE,EAEnBgH,EAAKhH,QAAQ,GACZ+G,GACN,CAAA,CAAE,EACJ,CAACb,EAAUS,EAAkB,EAG1BM,EAAcV,EAChB,CACE,GAAGA,EACHW,QAASX,EAAWW,QAAQC,QAAO,MAAQ,EAAE,GAE/C5K,OAEE6K,EAAiC7B,EAAQ,IAAM,CACnD,IAAM8B,EAA0B,CAC9BtL,KAAMsK,EAAStK,KACf2F,IAAK2E,EAAS3E,KAAO,GACrB4F,MAAO,CAACjB,EAASkB,SAAW,IAC5BC,YAAanB,EAASmB,aAAe,IAGjCC,EAAuB,CAC3BC,QAASrB,EAAStK,KAClB4L,WAAYtB,EAASkB,QACrBK,SAAUvB,EAASwB,YAGrB,MAAO,CACLnB,YAAAA,EACAoB,oBAAqB,yBACrBC,WAAY,CAAC,CAAEhJ,QAAAA,CAAO,IACbqH,EACJD,IAAKhH,GAAc,CAElB,GACG,OAAOA,GAAc,WACnBA,IAAc,YAAcA,IAAc,aAC5C,OAAOA,GAAc,WACnBA,EAAUpD,OAAS,YAClBoD,EAAUpD,OAAS,YAEvB,OAAO,IAAI4J,GAAkB,CAC3BrJ,QACE,OAAO6C,GAAc,SACjB,CAAE6I,eAAgB,GAAMC,2BAA4B,IACpD9I,EAAU7C,QAChBH,OAAQwK,EACT,EAEH,GACG,OAAOxH,GAAc,UACpBA,IAAc,iBACf,OAAOA,GAAc,UACpBA,EAAUpD,OAAS,gBAErB,OAAO,IAAI6J,GAAuB,CAChCtJ,QACE,OAAO6C,GAAc,SACjB,CACEJ,QAAAA,EACAmJ,IAAKrB,EACLsB,WAAYd,EACZe,OAAQ,IAEV,CACErJ,QAAAA,EACAmJ,IAAKrB,EACLsB,WAAYd,EACZe,OAAQ,GACR,GAAGjJ,EAAU7C,SAErBH,OAAQwK,EACT,EAEH,GACG,OAAOxH,GAAc,WACnBA,IAAc,YAAcA,IAAc,eAC5C,OAAOA,GAAc,WACnBA,EAAUpD,OAAS,YAClBoD,EAAUpD,OAAS,cACvB,CACA,IAAMsM,GAAaxB,EAAW9H,GAAWuH,GAAkB,GAC3D,OAAO,IAAIZ,GAAwB,CACjCvJ,OAAQwK,EACRrK,QACE,OAAO6C,GAAc,SACjB,CACE,GAAGsI,EACHY,WAAAA,IAEF,CACE,GAAGZ,EACHY,WAAAA,GACA,GAAGlJ,EAAU7C,SAEtB,EAEH,GAAI,OAAO6C,GAAc,UAAYA,EAAUpD,OAAS,QAAS,CAC/D,IAAMsM,GAAaxB,EAAW9H,GAAWuH,GAAkB,GAC3D,OAAO,IAAIhH,GAAe,CACxBnD,OAAQwK,EACRrK,QAAS,CACP,GAAG6C,EAAU7C,QACbsE,QAAS,CAAEC,OAAQwH,GAAYtJ,QAASuH,GAAkB,GAC1DtG,QAAS6G,GAEZ,EAEH,OACG,OAAO1H,GAAc,UAAYA,IAAc,UAC/C,OAAOA,GAAc,UAAYA,EAAUpD,OAAS,SAE9C,IAAIH,EAAoB,CAC7BO,OAAQwK,EACT,EAEI,KACR,EACAvK,OAAQC,GAAMA,IAAM,IAAI,IAG9B,CAAC+J,EAAkBO,EAAmBN,EAAS,EAE5CiC,EAAyD/C,EAAQ,IAAM,CAtZ/E,IAAArJ,EAAAiB,EAuZI,KACE8I,EAAAA,GAAAA,YAAAA,EAAYqC,mBAAZrC,YAAAA,EAA8BpF,WAC9BoF,EAAAA,GAAAA,YAAAA,EAAYqC,mBAAZrC,YAAAA,EAA8BlH,SAE9B,OAAOkH,EAAWqC,iBAEpB,GAAI,CAAChC,EACH,OAEF,IAAIzF,EAASgG,EAAWP,GACxB,GAAI,CACFzF,EAASyE,GAAsBzE,CAAM,OACrC,CACA0H,QAAQC,MACN,2CAA2ClC,oFAAiG,EAG9I,OAEF,MAAO,CACLvH,QAASuH,EACTzF,OAAAA,IAED,CAACgG,EAAYP,EAAe,EAEzBmC,EAAyBlD,EAAQ,KAE9B,CACL,GAFuBU,EAGvBqC,iBAAAA,IAED,CAACrC,EAAYqC,EAAiB,EAEjC,OACEnF,EAAA,cAACO,GAAsB,CACrBE,MAAO,CACLJ,UAAWqD,EACXpD,gBAAiBkD,EACjBJ,WAAYU,IAGd9D,EAAA,cAACqC,GAAaK,GAAA,CAAA,EAAKuB,CAAU,EAC3BjE,EAAA,cAACuF,GAA+B,CAC9BjC,YAAaA,EACbH,eAAgBA,EAChBL,WAAYwC,EACZjC,iBAAkBA,GAEjB3C,CAAQ,CACuB,CACpB,GApNU,oBAmO1B6E,GAIF/E,EAAA,CAAC,CAAEE,SAAAA,KAAa8E,CAAK,IAAO,CAC9B,IAAM9L,EAAW4I,GAAW,EACtBpI,EAASgH,GAAS,EACxB,OACElB,EAAA,cAACyF,GAAmB/C,GAAA,CAACxI,OAAQA,EAAQR,SAAUA,GAAc8L,CAAK,EAC/D9E,CAAQ,GALX,mCAgBEgF,GAAqBzF,GAA0B,CAAEkD,eAAgB,GAAI,EAgB9DsC,GAETjF,EAAA,CAAC,CACHsC,WAAAA,EACAK,eAAAA,EACAE,iBAAAA,EACA3J,SAAAA,EACAQ,OAAAA,EACAoJ,YAAAA,EACA5C,SAAAA,CAAQ,IACJ,CACJ,IAAMiF,EAAsCvD,EAAQ,IAC3CkB,GAA4B,IAAItB,GACtC,CAACsB,EAAY,EAEVsC,EAAMxD,EAAQ,IAAM,CACxB,GAAI,CAACe,GAAkB,OAAO3K,OAAW,IACvC,OAEF,IAAMqN,EAAO,IAAI3D,GAAYxI,EAAUoJ,EAAYO,CAAgB,EAClEwC,OAAAA,EAAaC,SAAW3C,EAClB0C,GACN,CAACnM,EAAUoJ,EAAYO,EAAkBF,EAAe,EAE3DrC,GAAU,IAAM,CACV5G,GAAU0L,GAAQA,EAAYE,WAAa3C,GAC7CyC,EAAIG,uBAAuB7L,CAAM,GAElC,CAACA,EAAQ0L,EAAKzC,EAAe,EAEhC,IAAM6C,EAAW5D,EACf,KAAO,CACLwD,IAAAA,EACAzC,eAAgBA,GAAkB,GAClC8C,YAAa,KAEf,CAACL,EAAI,EAGP,OACE5F,EAAA,cAACiC,GAAmB,CAACiE,OAAQP,GAC3B3F,EAAA,cAAC0F,GAAmB/E,SAAQ,CAACF,MAAOuF,GACjCtF,CAAQ,CACmB,GAzChC,uBAiDJ,SAASyF,IAA4B,CACnC,IAAMC,EAAMpG,EAAME,WAAWwF,EAAkB,EAC/C5N,OAAAA,GACEsO,EAAIH,YACJ,kHAAkH,EAE7GG,EANAD,EAAAA,GAAAA,iBAmBF,SAASE,GAAkC,CAChD,GAAM,CAAET,IAAAA,CAAG,EAAKO,GAAa,EAC7B,OAAOP,EAFOS,EAAAA,EAAAA,UAQT,SAASC,IAA4B,CAC1C,GAAM,CAAEnD,eAAAA,CAAc,EAAKgD,GAAa,EACxC,OAAOhD,EAFOmD,EAAAA,GAAAA,qBAQT,SAASC,GAAmD,CACjE,IAAMX,EAAMS,EAAM,EAClB,OAAQT,GAAAA,YAAAA,EAAaE,SAFPS,EAAAA,EAAAA,oBC1kBhB,OAAuBC,aAAAA,OAAiB,SAExC,IAAMC,GAAsB,WAK5B,SAASC,GAAeC,EAA2B,CACjD,OAAIA,EAAM,KAAOF,GACRE,EAEF,CAACF,MAAwBE,GAJzBD,EAAAA,GAAAA,kBAUF,SAASE,EACdC,EAA0BL,GAAUM,YACpCH,EAAkB,CAAA,EACR,CACV,OAAOD,GAAe,CAAC,WAAYG,KAAoBF,EAAM,EAJ/CC,EAAAA,EAAAA,0BAUT,SAASG,EACdJ,EACA/K,EACU,CACV,OAAOoL,EAAUvJ,QAAQwJ,OAAOrL,CAAO,EAAEsL,OAAOP,CAAK,EAJvCI,EAAAA,EAAAA,6BAUT,SAASI,EACd7D,EACAuD,EACAjL,EACkB,CAClB,OAAOhB,QAAQC,IAAI,CACjByI,EAAY8D,kBACVL,EACEH,EAAuBC,CAAe,EACtCjL,CAAO,CACR,EAEH0H,EAAY8D,kBACVL,EAA0BL,GAAe,CAAC,UAAU,EAAG9K,CAAO,CAAC,EAElE,EAfauL,EAAAA,EAAAA,iCAqBT,IAAMH,EAAY,CACvB7J,KAAM,CACJkK,KAAM,IAAMX,GAAe,CAAC,OAAO,GAErCjJ,QAAS,CACPwJ,OAASrL,GACP8K,GAAe,CAAC,UAAW9K,EAAQ,GAEvC0L,OAAQ,CACNC,QAAS,CACP3L,EACA4L,EACAC,IAEAV,EACEL,GAAe,CAAC,UAAW,CAAEc,cAAAA,EAAeC,aAAAA,GAAe,EAC3D7L,CAAO,GAGb8L,SAAU,CACRC,KAAOd,GACLD,EAAuBC,EAAiB,CAAC,gBAAgB,EAC3De,iBAAmBf,GACjBD,EAAuBC,EAAiB,CAAC,mBAAmB,EAC9DgB,wBACEhB,GAEAD,EAAuBC,EAAiB,CAAC,6BAA6B,EACxEiB,SAAWjB,GACTD,EAAuBC,EAAiB,CAAC,WAAW,EACtDkB,iBAAmBlB,GACjBD,EAAuBC,EAAiB,CAAC,mBAAmB,EAC9DmB,KAAM,CACJnB,EACAoB,EACAC,IACGtB,EAAuBC,EAAiB,CAAC,OAAQoB,EAAcC,EAAK,EAEzEC,OAAQ,CACNC,UAAW,CACTvB,EACAwB,IAEAzB,EAAuBC,EAAiB,CACtC,SACA,YACA,CAAEwB,UAAAA,GACH,EACHC,aAAezB,GACbD,EAAuBC,EAAiB,CAAC,SAAU,eAAe,GAItE0B,IAAK,CACHC,IAAK,CACH3B,EACA4B,IACG7B,EAAuBC,EAAiB,CAAC,MAAO,CAAE4B,QAAAA,GAAU,EACjEC,UAAW,CACT7B,EACA8B,EACAF,IAEA7B,EAAuBC,EAAiB,CACtC,YACA,CAAE8B,MAAAA,EAAOF,QAAAA,GACV,EACHG,MAAO,CACL/N,IAAK,CACHgM,EACAgC,IAEAjC,EACEC,EACAgC,EAAS,CAAC,QAAS,MAAOA,GAAU,CAAC,QAAS,MAAM,EAExDC,uBACEjC,GAEAD,EAAuBC,EAAiB,CACtC,QACA,yBACD,EACHkC,WAAalC,GACXD,EAAuBC,EAAiB,CAAC,QAAS,aAAa,EACjEmC,MAAO,CACLnO,IAAK,CACHgM,EACA8B,IAEA/B,EAAuBC,EAAiB,CACtC,QACA,QACA,MACA8B,EACD,IAGPM,KAAM,CACJC,gBAAiB,CACfrC,EACAgC,IAEAjC,EACEC,EACAgC,EAAS,CAAC,kBAAmBA,GAAU,CAAC,kBAAkB,EAE9DM,qBACEtC,GACGD,EAAuBC,EAAiB,CAAC,uBAAuB,EACrEuC,mBAAqBvC,GACnBD,EAAuBC,EAAiB,CAAC,qBAAqB,IAIpEwC,MAAO,CACLC,YAAczC,GACZD,EAAuBC,EAAiB,CAAC,cAAc,EACzD6B,UAAW,CACT7B,EACAW,IAEAZ,EAAuBC,EAAiB,CACtC,YACA,CAAEW,cAAAA,GACH,GAEL+B,YAAa,CACXC,WAAY,CACV3C,EACA4C,IAEA7C,EAAuBC,EAAiB,CAAC,aAAc,CAAE4C,UAAAA,GAAY,EACvEC,eAAgB,CACd7C,EACAgC,IAEAjC,EACEC,EACAgC,EAAS,CAAC,iBAAkBA,GAAU,CAAC,iBAAiB,EAE5Dc,kBAAmB,CACjB9C,EACAgC,IAEAjC,EACEC,EACAgC,EAAS,CAAC,oBAAqBA,GAAU,CAAC,oBAAoB,EAElEe,gBAAkB/C,GAChBD,EAAuBC,EAAiB,CAAC,kBAAkB,EAE7DgD,QAAS,CACPC,cAAe,CACbjD,EACA4C,IAEA7C,EAAuBC,EAAiB,CACtC,UACA,gBACA,CAAE4C,UAAAA,GACH,EACHM,UAAW,CACTlD,EACA4C,IAEA7C,EAAuBC,EAAiB,CACtC,UACA,YACA,CAAE4C,UAAAA,GACH,KAKTO,WAAY,CACVC,gBAAiB,CACfC,UAAW,CACTrD,EACA4B,IAEA7B,EACEC,EACA4B,EACI,CAAC,kBAAmB,YAAa,CAAEA,QAAAA,IACnC,CAAC,kBAAmB,YAAY,EAExC0B,OAAQ,CACNtD,EACA4B,IAEA7B,EACEC,EACA4B,EACI,CAAC,kBAAmB,SAAU,CAAEA,QAAAA,IAChC,CAAC,kBAAmB,SAAS,EAErC2B,6BAA8B,CAC5BvD,EACAgC,EACAJ,IAEA7B,EACEC,EACA4B,EACI,CACE,kBACA,0BACA,CAAEA,QAAAA,GACFI,GAEF,CAAC,kBAAmB,0BAA2BA,EAAO,GAKhEwB,MAAO,CACLC,aAAezD,GACbD,EAAuBC,EAAiB,CAAC,QAAQ,GAGrD0D,UAAW,CACTC,sBACE3D,GACGD,EAAuBC,EAAiB,CAAC,YAAY,GAG5D4D,aAAc,CACZjC,IAAM3B,GACJD,EAAuBC,EAAiB,CAAC,eAAe,GAG5DiB,SAAU,CACRU,IAAM3B,GACJD,EAAuBC,EAAiB,CAAC,WAAW,GAExD6D,MAAO,CACLP,OAAStD,GACPD,EAAuBC,EAAiB,CAAC,QAAQ,EACnD2B,IAAK,CAAC3B,EAAiD8D,IACrD/D,EAAuBC,EAAiB,CAAC,QAAS,CAAE8D,KAAAA,GAAO,KC/SnE,OAASC,kBAAAA,OAAsB,wBAE/B,OAAO5K,OAAW,QAClB,OAAOlI,OAAe,iBAsBf,SAAS+S,GAAS/R,EAAsB,CAC7C,IAAM8M,EAAMS,EAAM,EACZ/C,EAAcsH,GAAc,EAC5B,CAAExH,WAAAA,CAAU,EAAKxC,EAAwB,EAE/CZ,GAAMc,UAAU,IAAM,CAEpB,IAAMuE,EADc,IAAIyF,gBAAgBtS,OAAOuS,SAASC,MAAM,EACpCxC,IAAI,OAAO,EAEjCnD,IAASvM,GAAAA,YAAAA,EAAQmS,UAEnBnS,EAAOmS,QAAQC,UAAU7F,CAAK,CAAC,GAEhC,CAACvM,GAAAA,YAAAA,EAAQmS,QAAQ,EAEpB,eAAeE,EAAMC,EAAoB,CACvCtT,GACEsL,EACA,sDAAsD,EAExD,IAAMiI,EAAU,MAAMzF,GAAAA,YAAAA,EAAKzI,KAAKgO,MAAM/H,EAAWkI,OAAQF,IAEnDG,EAAiBC,mBAAmBC,KAAKjP,KAAKyB,UAAUoN,CAAO,CAAC,CAAC,EACjEK,EAAoBF,oBACxB1S,GAAAA,YAAAA,EAAQ6S,aAAcvI,EAAWwI,eAAiBpT,OAAOuS,SAASc,IAAI,EAGxEvI,EAAY8D,kBAAkBJ,EAAU7J,KAAKkK,KAAI,CAAE,EAGnD7O,OAAOuS,SAASc,KAAO,GAAGzI,EAAWW,yBAAyBwH,cAA2BG,IAf5EP,OAAAA,EAAAA,EAAAA,SAkBRA,EAjCON,EAAAA,GAAAA,YC1BhB,OAASD,kBAAAA,OAAsB,wBAC/B,OAAO9S,OAAe,iBAUf,SAASgU,IAAY,CAC1B,IAAMxI,EAAcsH,GAAc,EAC5B,CAAExH,WAAAA,CAAU,EAAKxC,EAAwB,EAE/C,SAASmL,GAAS,CAChBjU,GACEsL,EACA,sDAAsD,EAExDE,EAAY8D,kBAAkBJ,EAAU7J,KAAKkK,KAAI,CAAE,EACnD7O,OAAOuS,SAASc,KAAO,GAAGzI,EAAWW,iBAN9BgI,OAAAA,EAAAA,EAAAA,UASFA,EAbOD,EAAAA,GAAAA,aCXhB,OAASE,YAAAA,OAAgB,wBACzB,OAAOlU,OAAe,iBAaf,SAASmU,IAAU,CACxB,GAAM,CAAE7I,WAAAA,CAAU,EAAKxC,EAAwB,EAEzC,CAAEY,KAAM6F,EAAM6E,UAAAA,CAAS,EAAKF,GAChChF,EAAU7J,KAAKkK,KAAI,EACnB,UACEvP,GACEsL,EACA,sDAAsD,EAGhD,MADI,MAAM+I,MAAM,GAAG/I,EAAWW,cAAc,GAClCqI,KAAI,EACvB,EAGH,MAAO,CAAE/E,KAAAA,EAAM6E,UAAAA,GAfDD,EAAAA,GAAAA,WCJT,SAASI,EACdC,EACAzF,EACoD,CACpD,IAAMjB,EAAMS,EAAM,EAClB,GAAI,GAACT,GAAO,CAACiB,GAAmB,CAACyF,GAGjC,OAAO1G,EAAI2G,mBAAmB1F,EAAiByF,CAAY,EAR7CD,EAAAA,EAAAA,sBCcT,SAASG,GACd3F,EACyB,CACzB,OAAOwF,EAAmB,eAAgBxF,CAAe,EAH3C2F,EAAAA,GAAAA,kBCCT,SAASC,GAAW5F,EAA+C,CACxE,OAAOwF,EAAmB,UAAWxF,CAAe,EADtC4F,EAAAA,GAAAA,cCDT,SAASC,GAAW7F,EAA+C,CACxE,OAAOwF,EAAmB,WAAYxF,CAAe,EADvC6F,EAAAA,GAAAA,cCCT,SAASC,GACd9F,EACyB,CACzB,OAAOwF,EAAmB,cAAexF,CAAe,EAH1C8F,EAAAA,GAAAA,kBCAT,SAASC,GACd/F,EAC2B,CAC3B,OAAOwF,EAAmB,iBAAkBxF,CAAe,EAH7C+F,EAAAA,GAAAA,oBCAT,SAASC,GAAQhG,EAA4C,CAClE,OAAOwF,EAAmB,OAAQxF,CAAe,EADnCgG,EAAAA,GAAAA,WCAT,SAASC,GAASjG,EAA6C,CACpE,OAAOwF,EAAmB,QAASxF,CAAe,EADpCiG,EAAAA,GAAAA,YCnBT,SAASC,GAAalG,EAAiD,CAC5E,OAAOwF,EAAmB,aAAcxF,CAAe,EADzCkG,EAAAA,GAAAA,gBCmBT,SAASC,GAAQnG,EAA4C,CAClE,OAAOwF,EAAmB,OAAQxF,CAAe,EADnCmG,EAAAA,GAAAA,WCAT,SAASC,GAASpG,EAA6C,CACpE,OAAOwF,EAAmB,QAASxF,CAAe,EADpCoG,EAAAA,GAAAA,YCDT,SAASC,GAAarG,EAAiD,CAC5E,OAAOwF,EAAmB,YAAaxF,CAAe,EADxCqG,EAAAA,GAAAA,gBCAT,SAASC,GACdtG,EAC2B,CAC3B,OAAOwF,EAAmB,iBAAkBxF,CAAe,EAH7CsG,EAAAA,GAAAA,oBC1BhB,OAASC,cAAcC,OAAuB,QAMvC,SAASD,GAAa,CAC3B,OAAOC,GAAe,EADRD,EAAAA,EAAAA,cCJhB,OAASpM,cAAAA,OAAkB,QA8BpB,SAASsM,GAAcnU,EAA8C,CAC1E,IAAMoU,EAAmB,CAAOC,qBAAsB,GAAQ,GAAGrU,GAC3D,CAAA,CAAGE,CAAO,EAAI+T,EAAU,EACxB,CAAC5L,EAAMnG,CAAU,EAAI2F,GAAU,EAErC,MAAO,UAAY,CArCrB,IAAAjI,EAsCI,IAAMoB,IACHqH,EAAAA,EAAKA,OAALA,YAAAA,EAAWxF,qBAAqBvD,GAC/B+I,EAAKA,KAAKxF,UAAU7B,mBACtBf,OAEF,GAAImU,EAAiBC,sBAAwBrT,EAC3C,GAAI,CACF,OAAO,MAAMd,EAAQc,CAAiB,QAC/BsT,EAAP,CACArI,eAAQC,MAAM,6CAA8CoI,CAAG,EAExDpS,EAAU,EAIrB,OAAOA,EAAU,GArBLiS,EAAAA,GAAAA,iBChChB,OAAStM,cAAAA,OAAkB,QA2BpB,SAAS0M,GAAiC,CA3BjD,IAAA3U,EA4BE,GAAM,CAACS,CAAO,EAAIwH,GAAU,EAC5B,OAAOxH,EAAAA,EAAQgI,OAARhI,YAAAA,EAAc+H,QAFPmM,EAAAA,EAAAA,cC3BhB,OAGExL,eAAAA,OACK,iCACP,OAASE,WAAAA,OAAe,QAKjB,SAASuL,GACdC,EACA9K,EACAO,EACa,CACb,OAAOjB,GAAQ,IACN,IAAIF,GACT0L,EACA,CACE,GAAG9K,EACHqC,iBAAkB,CAChB,GAAGrC,GAAAA,YAAAA,EAAYqC,iBACfzH,OAAQkQ,IAGZvK,CAAgB,EAEjB,CAACuK,EAAgB9K,EAAW,EAjBjB6K,EAAAA,GAAAA,kBCVhB,OAMEE,UAAAA,OACK,iBAEP,SAASC,GACPC,EAOO,CACP,OAAOF,GAAOE,CAAS,EAThBD,EAAAA,GAAAA,aAeF,SAASE,IAAqB,CACnC,IAAMC,EAAKC,GAAQ,EACnB,OAAOD,EAAKA,EAAGE,YAAW,EAAGC,SAAS,SAAS,EAAI,GAFrCJ,EAAAA,GAAAA,aAQT,SAASK,IAAiB,CAC/B,IAAMJ,EAAKC,GAAQ,EACnB,OAAOD,EACHA,EAAGE,YAAW,EAAGC,SAAS,KAAK,GAC5BH,EAAGE,YAAW,EAAGC,SAAS,KAAK,GAAKE,UAAUC,eAAiB,EAClE,GALUF,EAAAA,GAAAA,SAWhB,SAASH,IAAW,CAClB,IAAMM,EAAMV,GAAS,EACrB,OAAOU,GAAAA,MAAAA,EAAKP,GAAKO,EAAIP,GAAK7U,OAFnB8U,EAAAA,GAAAA,YAQF,SAASO,IAAoB,CAElC,OADWP,GAAQ,EACPF,GAAS,GAAMK,GAAK,EAAK,GAFvBI,EAAAA,GAAAA,YCjDhB,OAAO3W,OAAe,iBA8Bf,SAAS4W,IAAc,CAhC9B,IAAA3V,EAiCE,GAAM,CAAC6L,EAAYvL,CAAO,EAAI+T,EAAU,EACxC,GAAIxI,EAAW+J,QACb,MAAO,IAAM/T,QAAQgU,OAAO,8CAA8C,EAG5E,IAAMC,EACJ,OAAOrW,OAAW,OAAeA,EAAAA,OAAOsW,WAAPtW,YAAAA,EAAiBuW,YAE9CC,EAAyBP,GAAQ,GAAM,CAACI,EAGxCI,EAAoBrK,EAAWpD,KAAKoD,WAAWjH,KAClDzE,GAAMA,EAAER,KAAO,UAAU,EAGtBwW,EAAyBtK,EAAWpD,KAAKoD,WAAWjH,KACvDzE,GAAMA,EAAER,KAAO,eAAe,EAG3BsD,GACHgT,EAAyBE,EAAyBD,IACnDA,EAEFnX,OAAAA,GACEkE,EACA,qGAAqG,EAGhG,SAAY,CAEjB,GAAI,CAAC6S,EAAoB,CAEvB,IAAIM,EAAM,kCACR3W,OAAOuS,SAASqE,KAAO5W,OAAOuS,SAASsE,SAAW7W,OAAOuS,SAASC,SAIpE,GAAIgE,GAA0BhT,EAAUtD,KAAO,gBAC7C,GAAI,CACFyW,GAAO,MAAMnT,EAAUrC,YAAW,GAAIqC,UAAUmT,IAEhDA,EAAMnB,GAAS,EACXmB,EAEA,kCACE3W,OAAOuS,SAASqE,KAChB5W,OAAOuS,SAASsE,SAChB7W,OAAOuS,SAASC,eAEfyC,EAAP,CACArI,QAAQkK,KAAK,uCAAwC7B,CAAG,EAI5DjV,cAAO+W,KAAKJ,EAAK,QAAQ,EAElBvU,QAAQ4U,QAAQ,CACrBnK,MAAO,IAAIoK,MAAM,uBAAuB,EACzC,EAIH,OAAO,MAAMpW,EAAQ2C,CAAS,GA/DlB0S,EAAAA,GAAAA,eC/BhB,OAAO5W,OAAe,iBA+Bf,SAAS4X,IAAmB,CACjC,GAAM,CAAC9K,EAAYvL,CAAO,EAAI+T,EAAU,EACxC,GAAIxI,EAAW+J,QACb,MAAO,IACL/T,QAAQgU,OAAO,mDAAmD,EAEtE,IAAM5S,EAAY4I,EAAWpD,KAAKoD,WAAWjH,KAC1CzE,GAAMA,EAAER,KAAO,eAAe,EAEjCZ,OAAAA,GACEkE,EACA,iGAAiG,EAG5F,IAAM3C,EAAQ2C,CAAS,EAdhB0T,EAAAA,GAAAA,oBC/BhB,OAAO5X,OAAe,iBA+Bf,SAAS6X,IAAoB,CAClC,GAAM,CAAC/K,EAAYvL,CAAO,EAAI+T,EAAU,EACxC,GAAIxI,EAAW+J,QACb,MAAO,IAAM/T,QAAQgU,OAAO,8CAA8C,EAE5E,IAAM5S,EAAY4I,EAAWpD,KAAKoD,WAAWjH,KAC1CzE,GAAMA,EAAER,KAAO,gBAAgB,EAElCZ,OAAAA,GACEkE,EACA,4FAA4F,EAGvF,IAAM3C,EAAQ2C,CAAS,EAbhB2T,EAAAA,GAAAA,qBAqBT,SAASC,IAAgB,CAC9B,OAAOD,GAAiB,EADVC,EAAAA,GAAAA,iBChDhB,OAAS/X,SAAAA,OAAa,SACtB,OAAOC,OAAe,iBA2Bf,SAAS+X,IAAY,CAC1B,GAAM,CAACjL,EAAYvL,CAAO,EAAI+T,EAAU,EACxC,GAAIxI,EAAW+J,QACb,MAAO,IAAM/T,QAAQgU,OAAO,4CAA4C,EAE1E,IAAM5S,EAAY4I,EAAWpD,KAAKoD,WAAWjH,KAAMzE,GAAMA,EAAER,KAAO,QAAQ,EAC1EZ,OAAAA,GACEkE,EACA,0FAA0F,EAGrF,MAAOlD,GAAqC,CACjD,IAAMqB,EAAoByK,EAAWpD,KAAKxF,UACpC8T,EAAyB,MAAM3V,GAAAA,YAAAA,EAAmBP,cACxD9B,OAAAA,GACE,CAAC,CAACqC,EACF,mFAAmF,EAErFrC,GACEgY,IAA2BhX,EAAOwB,YAClC,2DAA2D,EAE7DxC,GACED,GAAMkY,UAAUjX,EAAOuB,WAAW,EAClC,8CAA8C,EAE/C2B,EAAkCD,iBACjC5B,EACArB,CAAM,EAEDO,EAAQ2C,CAAS,GA9BZ6T,EAAAA,GAAAA,aC9BhB,OAAO/X,OAAe,iBAgEf,SAASkY,IAAW,CACzB,GAAM,CAACpL,EAAYvL,CAAO,EAAI+T,EAAU,EACxC,GAAIxI,EAAW+J,QACb,MAAO,IAAM/T,QAAQgU,OAAO,2CAA2C,EAGzE,IAAM5S,EAAY4I,EAAWpD,KAAKoD,WAAWjH,KAAMzE,GAAMA,EAAER,KAAO,OAAO,EAEzEZ,OAAAA,GACEkE,EACA,yFAAyF,EAGnFO,IACLP,EAA6BD,iBAAiBQ,CAAa,EACrDlD,EAAQ2C,CAAS,GAfZgU,EAAAA,GAAAA,YCnEhB,OAAS/O,cAAAA,OAAkB,QAsBpB,SAASgP,IAAiC,CAtBjD,IAAAlX,EAuBE,OAAOkI,EAAAA,GAAU,EAAG,GAAKO,KAAK3H,QAAvBoH,YAAAA,EAA8BvI,GADvBuX,EAAAA,GAAAA,cCMT,SAASC,IAAqB,CACnC,IAAM/M,EAAiBmD,GAAiB,EAClC6J,EAAgBF,GAAU,EAMhC,OAJI9M,IAAmB,IAInB,CAACgN,EAEI,GAGFhN,IAAmBgN,EAbZD,EAAAA,GAAAA,sBC5BhB,OAASjP,cAAcmP,OAAuB,QA0BvC,SAASnP,IAAa,CAC3B,OAAOmP,GAAe,EADRnP,EAAAA,GAAAA,cCPhB,OAASoP,iBAAAA,GAAeC,mBAAAA,GAAiBtP,cAAAA,GAAYsB,eAAAA,OAAmB,QACxE,OAAS3K,WAAAA,GAAS4Y,eAAAA,OAAmB,iCCpB9B,IAAMC,GAAuB,mCAMvBC,GAAqD,CAChEC,WAAYF,ICNd,OAAOG,OAAU,eAEV,SAASC,GACdzB,EACAhW,EAAUsX,GACV,CACA,GAAI,EAACtB,EAGL,OAAIA,EAAI0B,WAAW,SAAS,EACnB1B,EAAInL,QAAQ,UAAW7K,EAAQuX,UAAU,EAE3CvB,EAVOyB,EAAAA,GAAAA,kBAahB,eAAsBE,GAAgBvS,EAAc,CAClD,GAAI,CAACA,EACH,OAEF,IAAMwS,EAAWJ,GAAKK,QAAQzS,CAAG,EACjC,GAAIwS,EACF,OAAOA,EAGT,IAAME,EAAM,MAAM9E,MAAM5N,EAAK,CAC3B2S,OAAQ,OACT,EACD,GAAID,EAAIE,IAAMF,EAAIG,QAAQC,IAAI,cAAc,EAC1C,OAAOJ,EAAIG,QAAQ5I,IAAI,cAAc,GAAKpP,OAbxB0X,EAAAA,GAAAA,mBChBtB,IAAIQ,GAEJ,SAASC,GAAkBR,EAAmB,CAC5C,OACE,OAAOvY,OAAW,KAClB,CAACuY,GACD,CAACA,EAASF,WAAW,QAAQ,EAEtB,IAGJS,KACHA,GAAQE,SAASC,cAAc,OAAO,GAGjCH,GAAMI,YAAYX,CAAQ,GAb1BQ,EAAAA,GAAAA,qBAgBF,SAASI,GAAqBZ,EAAmB,CACtD,MAAO,CAAC,CAACQ,GAAkBR,CAAQ,EADrBY,EAAAA,GAAAA,wBAIhB,IAAIC,GAEJ,SAASC,GAAkBd,EAAmB,CAC5C,OACE,OAAOvY,OAAW,KAClB,CAACuY,GACD,CAACA,EAASF,WAAW,QAAQ,EAEtB,IAGJe,KACHA,GAAQJ,SAASC,cAAc,OAAO,GAGjCG,GAAMF,YAAYX,CAAQ,GAb1Bc,EAAAA,GAAAA,qBAgBF,SAASC,GAAqBf,EAAmB,CACtD,MAAO,CAAC,CAACc,GAAkBd,CAAQ,EADrBe,EAAAA,GAAAA,wBCxCT,SAASC,GACdC,EACsB,CACtB,OAAQvR,GAAU,CAChBuR,EAAKC,QAASlQ,GAAQ,CAChB,OAAOA,GAAQ,WACjBA,EAAItB,CAAK,EAEAsB,GAAO,OACfA,EAAyCH,QAAUnB,GAEvD,GAXWsR,EAAAA,GAAAA,aCAhB,OAAO/R,MAAyB,QAAhC,SAAA0C,GAAA,oMAAAlC,EAAAkC,EAAA,YAEO,IAAMwP,GAA4D1R,EACvEgF,GAGExF,EAAA,cAACmS,MAAGzP,EAAA,CAAC0P,MAAM,MAAMC,OAAO,MAAMC,QAAQ,aAAgB9M,CAAK,EACzDxF,EAAA,cAACuS,SAAM,CAACC,GAAG,IAAIC,GAAG,OAAOC,EAAE,MAAMC,KAAK,iBACtC3S,EAAA,cAAC4S,OAAI,CACHD,KAAK,eACLE,EAAE,uGAEJ7S,EAAA,cAAC4S,OAAI,CACHD,KAAK,eACLE,EAAE,4KACI,EAb2D,yBAkB5DC,GAA0DtS,EACrEgF,GAGExF,EAAA,cAACmS,MAAGzP,EAAA,CAAC0P,MAAM,MAAMC,OAAO,MAAMC,QAAQ,aAAgB9M,CAAK,EACzDxF,EAAA,cAAC4S,OAAI,CACHD,KAAK,eACLE,EAAE,uMAEJ7S,EAAA,cAAC4S,OAAI,CACHD,KAAK,eACLE,EAAE,oKACI,EAZyD,uBAiB1DE,GAAwDvS,EACnEgF,GAGExF,EAAA,cAACmS,MAAGzP,EAAA,CAAC0P,MAAM,MAAMC,OAAO,MAAMC,QAAQ,aAAgB9M,CAAK,EACzDxF,EAAA,cAAC4S,OAAI,CACHD,KAAK,eACLE,EAAE,oJACI,EARuD,qBAaxDG,GAA0DxS,EACrEgF,GAGExF,EAAA,cAACmS,MAAGzP,EAAA,CAAC0P,MAAM,MAAMC,OAAO,MAAMC,QAAQ,aAAgB9M,CAAK,EACzDxF,EAAA,cAAC4S,OAAI,CACHD,KAAK,eACLE,EAAE,6FACI,EARyD,uBCzCvE,OAAS7G,YAAAA,OAAgB,wBACzB,OAAOhM,GAASc,aAAAA,GAAWsB,WAAAA,GAASrB,UAAAA,GAAQkS,YAAAA,MAAgB,QAC5D,OAAOC,OAAmB,wBAX1B,SAAAxQ,GAAA,oMAAAlC,EAAAkC,EAAA,YAqDA,IAAMyQ,GAAyC3S,EAAA,CAAC,CAAE4S,QAAAA,EAASC,UAAAA,CAAS,IAAO,CACzE,GAAM,CAACC,EAAYC,CAAa,EAAIN,EAAS,EAAK,EAC5CO,EAAehT,EAAA,IAAM+S,EAAc,EAAI,EAAxB,gBACfE,EAAejT,EAAA,IAAM+S,EAAc,EAAK,EAAzB,gBACfG,EAAclT,EAAA,IAAM+S,EAAc,EAAK,EAAzB,eACdI,EAAYnT,EAAA,IAAM+S,EAAc,EAAI,EAAxB,aAClB,OACEvT,EAAA,cAAC4T,SAAM,CACLC,MAAO,CACLC,SAAU,WACVC,OAAQ,EACRC,MAAO,EACPC,UAAW,wBACXC,SAAU,OACV9B,MAAO,KACP+B,SAAU,OACVC,YAAa,IACbC,OAAQ,EACRC,gBAAiB,OACjBC,MAAO,qBACPC,QAAS,OACTC,WAAY,SACZC,aAAc,MACdC,OAAQ,+BACRC,OAAQ,UACR,GAAItB,EACA,CACEiB,MAAO,kBACPM,UAAW,sCAEb,CAAA,GAENzB,QAASA,EACTI,aAAcA,EACdC,aAAcA,EACdC,YAAaA,EACbC,UAAWA,GAETN,EAGArT,EAAA,cAAC+S,GAAiB,CAACc,MAAO,CAAEzB,MAAO,MAAOC,OAAQ,SAFlDrS,EAAA,cAACgT,GAAmB,CAACa,MAAO,CAAEzB,MAAO,MAAOC,OAAQ,QAGrD,GA1CwC,cA+CzCyC,GAAc9U,EAAM+U,WAIxB,CACE,CACEC,IAAAA,EACAC,IAAAA,EACAC,OAAAA,EACAC,mBAAAA,EACAzU,SAAAA,EACAmT,MAAAA,EACAzB,MAAAA,EACAC,OAAAA,EACA+C,SAAAA,KACGC,CAAS,EAEdtT,IACG,CACH,IAAMuT,EAAWvU,GAAyB,IAAI,EACxC,CAACwU,EAASC,CAAU,EAAIvC,EAAS,CAACkC,CAAkB,EACpD,CAACM,EAAOC,CAAQ,EAAIzC,EAAS,EAAI,EAEvCnS,OAAAA,GAAU,IAAM,CACVwU,EAAS1T,UACP2T,EACFD,EAAS1T,QAAQ+T,KAAI,GAErBL,EAAS1T,QAAQgU,MAAK,EACtBN,EAAS1T,QAAQiU,YAAc,KAGlC,CAACN,EAAQ,EAGVvV,EAAA,cAAC8V,MAAGpT,EAAA,CAACmR,MAAO,CAAEC,SAAU,WAAY,GAAGD,IAAawB,CAAS,EAC3DrV,EAAA,cAACsR,QAAK,CACJvP,IAAKgQ,GAAU,CAACuD,EAAUvT,EAAI,EAC9BiT,IAAKA,GAAO5b,OACZ8b,OAAQA,GAAU9b,OAClB2c,KAAAA,GACAC,YAAAA,GACAP,MAAOA,EACPQ,QAASf,EAAS,WAAa,OAC/BgB,UAAW,IAAM,CAhJ3B,IAAAnd,EAiJgBwc,KACFD,EAAAA,EAAS1T,UAAT0T,MAAAA,EAAkBK,SAGtBvD,MAAOA,EACPC,OAAQA,EACR+C,SAAUA,EACVvB,MAAO,CACLxB,OAAQ,OACRD,MAAO,OACP+D,UAAW,UACX9B,OAAQ,EACR+B,WAAY,cACZC,QAAUnB,EAAaK,EAAU,EAAI,EAAlB,KAGtBL,GACClV,EAAA,cAACsW,MAAG,CACFtB,IAAKE,EACLrB,MAAO,CACLsC,UAAW,UACXI,cAAe,OACfzC,SAAU,WACV1B,MAAO,OACPC,OAAQ,OACRgC,OAAQ,EACR+B,WAAY,cACZC,QAASd,EAAU,EAAI,EACvBiB,IAAK,EACLC,KAAM,EACNzC,MAAO,EACPD,OAAQ,KAId/T,EAAA,cAACmT,GAAU,CACTC,QAAS,IAAM,CACboC,EAAY5R,GAAS,CAACA,CAAI,EAC1B8R,EAAS,EAAK,GAEhBrC,UAAWkC,GACX,EAGP,EAGGmB,GAAc1W,EAAM+U,WAIxB,CACE,CACEC,IAAAA,EACAC,IAAAA,EACAC,OAAAA,EACAC,mBAAAA,EACAzU,SAAAA,EACAmT,MAAAA,EACAxB,OAAAA,EACAD,MAAAA,EACAgD,SAAAA,KACGC,CAAS,EAEdtT,IACG,CACH,IAAM4U,EAAW5V,GAAyB,IAAI,EACxC,CAACwU,EAASC,CAAU,EAAIvC,EAAS,EAAK,EACtC,CAACwC,EAAOC,CAAQ,EAAIzC,EAAS,EAAI,EAEvCnS,OAAAA,GAAU,IAAM,CACV6V,EAAS/U,UACP2T,EACFoB,EAAS/U,QAAQ+T,KAAI,GAErBgB,EAAS/U,QAAQgU,MAAK,EACtBe,EAAS/U,QAAQiU,YAAc,KAGlC,CAACN,EAAQ,EAGVvV,EAAA,cAAC8V,MAAGpT,EAAA,CAACmR,MAAO,CAAEC,SAAU,WAAY,GAAGD,IAAawB,CAAS,EAC1DH,EACClV,EAAA,cAACsW,MAAG,CACFjE,OAAQA,EACRD,MAAOA,EACP4C,IAAKE,EACLrB,MAAO,CACLxB,OAAQ,OACRD,MAAO,OACPmE,cAAe,OACfJ,UAAW,aAIfnW,EAAA,cAAC8V,MAAG,CACFjC,MAAO,CACLzB,MAAO,OACPC,OAAQ,OACRmC,QAAS,OACTC,WAAY,SACZ8B,cAAe,OACfjC,gBAAiB,OACjBC,MAAO,uBAGTvU,EAAA,cAAC8S,GAAmB,CAACe,MAAO,CAAExB,OAAQ,OAAQD,MAAO,SAAY,EAIrEpS,EAAA,cAACmT,GAAU,CACTC,QAAS,IAAM,CACboC,EAAY5R,GAAS,CAACA,CAAI,EAC1B8R,EAAS,EAAK,GAEhBrC,UAAWkC,IAEbvV,EAAA,cAAC4R,QAAK,CACJ7P,IAAKgQ,GAAU,CAAC4E,EAAU5U,EAAI,EAC9BiT,IAAKA,GAAO5b,OACZ2c,KAAAA,GACAC,YAAAA,GACAP,MAAOA,EACP5B,MAAO,CACLC,SAAU,WACVuC,QAAS,EACTE,cAAe,OACflC,OAAQ,GACRuC,WAAY,WAEd,EAGP,EAGGC,GAAe7W,EAAM+U,WAIzB,CACE,CACEC,IAAAA,EACAC,IAAAA,EACAC,OAAAA,EACAC,mBAAAA,EACAzU,SAAAA,EACAmT,MAAAA,EACAxB,OAAAA,EACAD,MAAAA,EACAgD,SAAAA,KACGC,CAAS,EAEdtT,IACG,CACH,GAAM,CAAE+U,QAAAA,EAAS1E,MAAO2E,CAAO,EAAK7D,GAAa,EAC3C,CAACqC,EAASC,CAAU,EAAIvC,EAAS,CAACkC,CAAkB,EAE1D,OAAI4B,EAAU,IAEV/W,EAAA,cAAC8V,MAAG,CAAC/T,IAAK+U,GACR9W,EAAA,cAACgX,GAAUtU,EAAA,CAACmR,MAAOA,EAAOmB,IAAKA,EAAKC,IAAKA,GAASI,CAAS,CAAA,CAAI,EAMnErV,EAAA,cAAC8V,MAAGpT,EAAA,CACFmR,MAAO,CAAEC,SAAU,WAAY,GAAGD,IAC9BwB,EAAS,CACbtT,IAAK+U,IAEL9W,EAAA,cAACiX,SAAM,CACLjC,IAAKO,EAAUP,GAAO5b,OAAYA,OAClC2I,IAAKA,EACL8R,MAAO,CACLsC,UAAW,UACX9B,OAAQ,EACRhC,OAAQ,OACRD,MAAO,OACPgE,WAAY,cACZC,QAAUnB,EAAaK,EAAU,EAAI,EAAlB,KAGtBL,GACClV,EAAA,cAACsW,MAAG,CACFtB,IAAKE,EACLrB,MAAO,CACLsC,UAAW,UACXI,cAAe,OACfzC,SAAU,WACV1B,MAAO,OACPC,OAAQ,OACRgC,OAAQ,EACR+B,WAAY,cACZC,QAASd,EAAU,EAAI,EACvBiB,IAAK,EACLC,KAAM,EACNzC,MAAO,EACPD,OAAQ,KAId/T,EAAA,cAACmT,GAAU,CACTC,QAAS,IAAM,CACboC,EAAY5R,GAAS,CAACA,CAAI,GAE5ByP,UAAWkC,GACX,EAGP,EAEGyB,GAAahX,EAAM+U,WAIvB,CACE,CACEC,IAAAA,EACAC,IAAAA,EACAC,OAAAA,EACAC,mBAAAA,EACAzU,SAAAA,EACAmT,MAAAA,EACAxB,OAAAA,EACAD,MAAAA,EACAgD,SAAAA,KACGC,CAAS,EAEdtT,IAGE/B,EAAA,cAAC8V,MAAGpT,EAAA,CAACmR,MAAO,CAAEC,SAAU,WAAY,GAAGD,IAAawB,CAAS,EAC3DrV,EAAA,cAAC8V,MAAG,CACFjC,MAAO,CACLzB,MAAO,OACPC,OAAQ,OACRmC,QAAS,OACTC,WAAY,SACZH,gBAAiB,OACjBC,MAAO,uBAGTvU,EAAA,cAAC8V,MAAG,CACFjC,MAAO,CACLW,QAAS,OACT0C,cAAe,SACfC,IAAK,MACLC,WAAY,SACZC,SAAU,WAGZrX,EAAA,cAACkS,GAAqB,CACpB2B,MAAO,CACLK,SAAU,QACVC,SAAU,OACV/B,MAAO,MACPgC,YAAa,OAGjBpU,EAAA,cAACsX,IAAC,CACAC,IAAI,sBACJ1D,MAAO,CACL2D,eAAgB,YAChBjD,MAAO,sBAET1I,KAAMmJ,GAAO5b,OACbqe,OAAO,SACP1V,IAAKA,GAEJkT,GAAO,MAAM,CACZ,CACA,CACF,CAGX,EAuBUyC,GAAgB1X,EAAM+U,WAIjC,CACE,CACErU,SAAAA,EACAsU,IAAAA,EACAE,OAAAA,EACAD,IAAAA,EACAE,mBAAAA,EAAqB,GACrBtB,MAAAA,KACGwB,CAAS,EAEdtT,IACG,CACH,IAAM4V,EAAmC,CAAExB,UAAW,UAAW,GAAGtC,GAC9D+D,EAAkBC,GAAqB7C,GAAO5b,MAAS,EACvD0e,EAAoBD,GAAqB3C,GAAU9b,MAAS,EAClE,GAAKwe,EAAgB7G,SAQd,IAAI6G,EAAgB7G,WAAa,YACtC,OACE/Q,EAAA,cAAC6W,GAAYnU,EAAA,CACXmR,MAAO8D,EACP3C,IAAK4C,EAAgBrZ,IACrB2W,OAAQ4C,EAAkBvZ,IAC1B4W,mBAAoBA,GAChBE,CAAS,CAAA,EAGZ,GAAI1D,GAAqBiG,EAAgB7G,QAAQ,EACtD,OACE/Q,EAAA,cAAC8U,GAAWpS,EAAA,CACVmR,MAAO8D,EACP3C,IAAK4C,EAAgBrZ,IACrB2W,OAAQ4C,EAAkBvZ,IAC1B4W,mBAAoBA,GAChBE,CAAS,CAAA,EAGZ,GAAIvD,GAAqB8F,EAAgB7G,QAAQ,EACtD,OACE/Q,EAAA,cAAC0W,GAAWhU,EAAA,CACVmR,MAAO8D,EACP3C,IAAK4C,EAAgBrZ,IACrB2W,OAAQ4C,EAAkBvZ,IAC1B4W,mBAAoBA,GAChBE,CAAS,CAAA,EAGZ,GAAIuC,EAAgB7G,SAASF,WAAW,QAAQ,EACrD,OACE7Q,EAAA,cAACsW,MAAG5T,EAAA,CACFmR,MAAO8D,EACP3C,IAAK4C,EAAgBrZ,IACrB0W,IAAKA,EACLlT,IAAKA,GACDsT,CAAS,CAAA,MA5CjB,QACErV,EAAA,cAACsW,MAAG5T,EAAA,CACFmR,MAAO8D,GACHtC,EAAS,CACbtT,IAAKA,KA4CX,OACE/B,EAAA,cAACgX,GAAUtU,EAAA,CACTmR,MAAO8D,EACP3C,IAAK4C,EAAgBrZ,IACrB0W,IAAKA,EACLlT,IAAKA,GACDsT,CAAS,CAAA,EAGlB,EAiCI,SAASwC,GAAqB1I,EAAc,CACjD,IAAM4I,EAAc3V,GAAQ,IAAMwO,GAAezB,CAAG,EAAG,CAACA,EAAI,EACtD6I,EAAkBhM,GACtB,CAAC,YAAa+L,GACd,IAAMjH,GAAgBiH,CAAW,EACjC,CACEE,QAAS,CAAC,CAACF,EACZ,EAGH,MAAO,CACLxZ,IAAKwZ,EACLhH,SAAUiH,EAAgBxW,MAZdqW,EAAAA,GAAAA,wBC1iBhB,OAAO7X,OAAW,QAFlB,SAAA0C,IAAA,sMAAAlC,EAAAkC,GAAA,YAwCO,IAAMwV,GAAmBlY,GAAM+U,WAGpC,CAAC,CAAEjN,SAAAA,KAAatC,CAAK,EAAIzD,IAEvB/B,GAAA,cAAC0X,GAAahV,GAAA,CACZsS,IAAKlN,EAASqQ,eAAiBrQ,EAASsQ,MACxClD,OAAQpN,EAASsQ,MACjBnD,IAAKnN,EAASlP,KACdmJ,IAAKA,GACDyD,CAAK,CAAA,CAGd,ECnDD,OAKEwG,YAAAA,OACK,wBAGA,SAASqM,EAMdC,EACAC,EACApf,EAI+B,CAC/B,IAAMgX,EAAgB5J,EAAgB,EAEhCiS,EAGF,CACF,GAAGrf,EACH8e,QAAS,CAAC,EAAE9H,IAAiBhX,GAAAA,YAAAA,EAAS8e,WAGxC,OAAOjM,GACLjF,EAA0BuR,EAAUnI,CAAa,EACjDoI,EACAC,CAAa,EA1BDH,EAAAA,EAAAA,uBCHhB,OAEEI,eAAAA,GACAzM,YAAAA,GACApB,kBAAAA,MACK,wBAOP,OAAS8N,iBAAAA,GAAeC,iBAAAA,OAAqB,iCAM7C,OAAS7X,aAAAA,GAAWsB,WAAAA,OAAe,QACnC,OAAOtK,MAAe,iBAEtB,eAAe8gB,GACb/R,EACAjB,EACA,CACA,GAAI,GAACiB,GAAmB,CAACjB,GAGzB,GAAI,CACF,OAAO,MAAMA,EAAIiT,oBAAoBhS,CAAe,OACpD,CAEA,MAAO,UAXI+R,EAAAA,GAAAA,qBAef,eAAeE,GACbjS,EACAjB,EACA,CACA,GAAI,GAACiB,GAAmB,CAACjB,GAIzB,OAAO,MACL,MAAMA,EAAImT,aAAY,GACtBC,iCAAiCnS,CAAe,EAVrCiS,EAAAA,GAAAA,iCAYf,eAAeG,GACb3V,EACAuD,EACAjB,EACA,CACA,GAAI,CAACiB,GAAmB,CAACjB,EACvB,OAEF,IAAM0G,EAAe,MAAMhJ,EAAY4V,WACrCnS,EACEC,EAAUU,SAASC,KAAKd,CAAe,EACtCjB,EAAYE,QAAQ,EAEvB,IAAM8S,GAAkB/R,EAAiBjB,CAAG,EAE5C,CAAEuT,UAAWC,IAAU,EAEzB,GAAI9M,IAAiB,SACnB,MAAO,CACLA,aAAAA,EACA1E,iBAAkB,MAGtB,IAAMA,EAAmB,MAAMtE,EAAY4V,WACzCnS,EACEC,EAAUU,SAASE,iBAAiBf,CAAe,EAClDjB,EAAYE,QAAQ,EAEvB,IAAMgT,GAA8BjS,EAAiBjB,CAAG,EAExD,CAAEuT,UAAWC,IAAU,EAEzB,MAAO,CACL9M,aAAAA,EACA1E,iBAAAA,GAlCWqR,EAAAA,GAAAA,wCAsCf,SAASI,GACP1S,EAGA,CAlGF,IAAA5N,EAmGE,GAAI,CAAC4N,GAAS,CAACA,EAAM2F,aACnB,OAAO,KAET,IAAIgN,EAA+C,KACnD,OAAI3S,EAAM2F,eAAiB,WACzBgN,EAAcZ,GAAc/R,EAAM2F,cAAcgN,aAE9C3S,EAAM2F,eAAiB,UAAY3F,EAAMiB,mBAC3C0R,GAAc3S,EAAAA,EAAMiB,mBAANjB,YAAAA,EAAwB4S,KAGjCD,EAhBAD,EAAAA,GAAAA,kBAmBT,SAASG,GACP3S,EACAF,EAGAf,EACA,CACA,GAAI,CAACe,GAAS,CAACf,GAAO,CAACiB,GAAmB,CAACF,EAAM2F,aAC/C,OAAO,KAGT,IAAMgN,EAAcD,GAAe1S,CAAK,EAExC7O,OAAAA,EACEwhB,EACA,yCAAyCzS,GAAiB,EAErDjB,EAAI6T,mBAAmB5S,EAAiByS,CAAW,EAjBnDE,EAAAA,GAAAA,kDA2BF,SAASE,GACd7S,EACA,CA9IF,IAAA9N,EA+IE,IAAM6M,EAAMS,EAAM,EAEZsT,EACJC,GAAmC/S,CAAe,EAEpD,GACE,CAACA,GACD,CAACjB,GACD,GAAC+T,EAAAA,EAAgCnY,OAAhCmY,MAAAA,EAAsCrN,cAEvC,MAAO,CACL,GAAGqN,EACHJ,IAAK,MAIT,IAAMA,EAAMF,GAAeM,EAAgCnY,IAAI,EAC/D,MAAO,CAAE,GAAGmY,EAAiCJ,IAAAA,GApB/BG,EAAAA,GAAAA,kBAmCT,SAASG,GACdhT,EACA,CACA,IAAMjB,EAAMS,EAAM,EAClB,OAAOgS,EACLrR,EAAUU,SAASC,KAAKd,CAAe,EACvC,IAAM+R,GAAkB/R,EAAiBjB,CAAG,EAC5C,CACEqS,QAAS,CAAC,CAACrS,GAAO,CAAC,CAACiB,EAEpBsS,UAAWC,IACZ,EAXWS,EAAAA,GAAAA,mBA2BT,SAASC,GACdjT,EACA,CACA,IAAMjB,EAAMS,EAAM,EAClB,OAAOgS,EACLrR,EAAUU,SAASE,iBAAiBf,CAAe,EACnD,IAAMiS,GAA8BjS,EAAiBjB,CAAG,EACxD,CACEqS,QAAS,CAAC,CAACrS,GAAO,CAAC,CAACiB,EAEpBsS,UAAWC,IACZ,EAXWU,EAAAA,GAAAA,+BAkBhB,SAASF,GACP/S,EACA,CACA,IAAMjB,EAAMS,EAAM,EACZ/C,EAAcsH,EAAc,EAClC,OAAOyN,EACLrR,EAAUU,SAASG,wBAAwBhB,CAAe,EAC1D,IACEoS,GAAqC3V,EAAauD,EAAiBjB,CAAG,EACxE,CACEqS,QAAS,CAAC,CAACrS,GAAO,CAAC,CAACiB,EAEpBsS,UAAWC,IACZ,EAbIQ,EAAAA,GAAAA,sCA6BF,SAASG,GAAYlT,EAAiD,CAzP7E,IAAA9N,EA0PE,IAAM6M,EAAMS,EAAM,EAEZsT,EACJC,GAAmC/S,CAAe,EAEpD,GACE,CAACA,GACD,CAACjB,GACD,GAAC+T,EAAAA,EAAgCnY,OAAhCmY,MAAAA,EAAsCrN,cAEvC,MAAO,CACL,GAAGqN,EACHjS,SAAU,MAId,IAAMA,EAAW8R,GACf3S,EACA8S,EAAgCnY,KAChCoE,CAAG,EAEL,MAAO,CAAE,GAAG+T,EAAiCjS,SAAAA,GAtB/BqS,EAAAA,GAAAA,eAqCT,SAASC,GACdnT,EACA,CACA,IAAMjB,EAAMS,EAAM,EACZ/C,EAAcsH,EAAc,EAC5BuF,EAAgB5J,EAAgB,EACtC,OAAO8R,EACLrR,EAAUU,SAASI,SAASjB,CAAe,EAC3C,SAAY,CAtShB,IAAA9N,EAuSM,IAAM8O,EAA0B,MAAMvE,EAAY4V,WAChDnS,EACEC,EAAUU,SAASG,wBAAwBhB,CAAe,EAC1DsJ,CAAa,EAEf,IACE8I,GACE3V,EACAuD,EACAjB,CAAG,EAGP,CAAEuT,UAAWC,IAAU,EAEnB1R,EAAW8R,GACf3S,EACAgB,EACAjC,CAAG,EAEL9N,OAAAA,GAAU4P,EAAAA,GAAAA,YAAAA,EAAUI,WAAVJ,YAAAA,EAAoBc,IAAK,oCAAoC,EAC/D,MAAMd,EAASI,SAASU,IAAG,GAErC,CACEyP,QAAS,CAAC,CAACpR,GAAmB,CAAC,CAACjB,EACjC,EAjCWoU,EAAAA,GAAAA,uBAwCT,SAASC,GACdpT,EACA,CACA,IAAMjB,EAAMS,EAAM,EACZ/C,EAAcsH,EAAc,EAC5BuF,EAAgB5J,EAAgB,EACtC,OAAO8R,EACLrR,EAAUU,SAASK,iBAAiBlB,CAAe,EACnD,SAAY,CACV,IAAMgB,EAA0B,MAAMvE,EAAY4V,WAChDnS,EACEC,EAAUU,SAASG,wBAAwBhB,CAAe,EAC1DsJ,CAAa,EAEf,IACE8I,GACE3V,EACAuD,EACAjB,CAAG,EAGP,CAAEuT,UAAWC,IAAU,EAEnB1R,EAAW8R,GACf3S,EACAgB,EACAjC,CAAG,EAEL,OAAI8B,aAAoBiR,GACfjR,EAASwS,kBAAkBnS,iBAAgB,EAE7C,MAET,CACEkQ,QAAS,CAAC,CAACpR,GAAmB,CAAC,CAACjB,EAEhCuT,UAAWC,IACZ,EArCWa,EAAAA,GAAAA,wBAyDT,SAASE,GACdzS,EACAO,KACGC,EACH,CACA,IAAMrB,EAAkBa,GAAAA,YAAAA,EAAUpM,aAClC,OAAO+c,EACLrR,EAAUU,SAASM,KAAKnB,EAAiBoB,EAAcC,CAAI,EAC3D,KACEpQ,EAAU4P,EAAU,0BAA0B,EAC9C5P,EAAUmQ,EAAc,gCAAgC,EACjDP,EAASM,KAAKC,EAAY,GAAKC,CAAI,GAE5C,CACE+P,QAAS,CAAC,CAACvQ,GAAY,CAAC,CAACO,EAC1B,EAfWkS,EAAAA,GAAAA,mBAqCT,SAASC,GACd1S,EACAO,EACA,CACA,IAAMkI,EAAgB5J,EAAgB,EAChCM,EAAkBa,GAAAA,YAAAA,EAAUpM,aAC5BgI,EAAcsH,EAAc,EAElC,OAAO6N,GACL,MAAO4B,IACLviB,EAAU4P,EAAU,0BAA0B,EAC9C5P,EAAUmQ,EAAc,gCAAgC,EACnDoS,GAAAA,MAAAA,EAAY3e,OAGVgM,EAASM,KAAKC,EAAY,GAAKoS,CAAU,EAFvC3S,EAASM,KAAKC,CAAY,GAIrC,CACEqS,UAAW,IACThX,EAAY8D,kBACVL,EACEH,EAAuBC,CAAe,EACtCsJ,CAAa,CACd,EAEN,EAzBWiK,EAAAA,GAAAA,mBAqCT,SAASG,GACd7S,EACAvO,EAAmE,CACjEqhB,UAAW,IAEb,CACA,IAAM3T,EAAkBa,GAAAA,YAAAA,EAAUpM,aAC5Bmf,EAAe,CAAC,CAAC/S,EACjBpE,EAAcsH,EAAc,EAC5BuF,EAAgB5J,EAAgB,EAEhCmU,EAAWtY,GACf,IACE2E,EACEC,EAAUU,SAASS,OAAOG,aAAazB,CAAe,EACtDsJ,CAAa,EAEjB,CAACtJ,EAAgB,EAEnB/F,OAAAA,GAAU,IAEJ,CAAC3H,EAAQqhB,WAAa,CAACC,GAAgB,CAAC/S,EAC1C,OAGsBA,EAASS,OAAOwS,kBACrCC,GAAkB,CAEjBtX,EAAYuX,aACVH,EACCI,GACMA,EAIHA,EAAQC,UACLzd,GACCA,EAAE0d,YAAYC,kBACZL,EAAcI,YAAYC,iBAC5B3d,EAAE0d,YAAYE,WAAaN,EAAcI,YAAYE,QAAQ,IAC3D,GAEC,CAACN,KAAkBE,GAErBA,EAZE,CAACF,EAaX,EAEJ,EAIF,CAACH,EAActhB,EAAQqhB,UAAWE,EAAS,EAEvC1O,GACL0O,EACA,KACE5iB,EAAU4P,EAAU,0BAA0B,EACvCA,EAASS,OAAOG,aAAanP,EAAQgiB,WAAW,GAEzD,CACElD,QAASwC,EAETW,qBAAsB,CAACjiB,EAAQqhB,UAC/Ba,eAAgB,GAChBC,mBAAoB,GACrB,EAjEWf,EAAAA,GAAAA,wBA6ET,SAASgB,GACd7T,EACAW,EACAlP,EAAmE,CACjEqhB,UAAW,IAEb,CACA,IAAM3T,EAAkBa,GAAAA,YAAAA,EAAUpM,aAC5Bmf,EAAe,CAAC,CAAC/S,GAAY,CAAC,CAACW,EAC/B/E,EAAcsH,EAAc,EAC5BuF,EAAgB5J,EAAgB,EAEhCmU,EAAWtY,GACf,IACE2E,EACEC,EAAUU,SAASS,OAAOG,aAAazB,CAAe,EACtDsJ,CAAa,EAEjB,CAACtJ,EAAgB,EAEnB/F,OAAAA,GAAU,IAEJ,CAAC3H,EAAQqhB,WAAa,CAACC,GAAgB,CAAC/S,GAAY,CAACW,EACvD,OAGsBX,EAASS,OAAOwS,kBACrCC,GAAkB,CAEjBtX,EAAYuX,aACVH,EACCI,GACMA,EAIHA,EAAQC,UACLzd,GACCA,EAAE0d,YAAYC,kBACZL,EAAcI,YAAYC,iBAC5B3d,EAAE0d,YAAYE,WAAaN,EAAcI,YAAYE,QAAQ,IAC3D,GAEC,CAACN,KAAkBE,GAErBA,EAZE,CAACF,EAaX,EAEJ,EAIF,CAACH,EAActhB,EAAQqhB,UAAWE,EAAUrS,EAAU,EAElD2D,GACL0O,EACA,KACE5iB,EAAU4P,EAAU,0BAA0B,EACvCA,EAASS,OAAOC,UAAUC,EAAWlP,EAAQgiB,WAAW,GAEjE,CACElD,QAASwC,EAETW,qBAAsB,CAACjiB,EAAQqhB,UAC/Ba,eAAgB,GAChBC,mBAAoB,GACrB,EAlEWC,EAAAA,GAAAA,qBClgBhB,OAAS9C,eAAAA,GAAa7N,kBAAAA,OAAsB,wBAC5C,OACE4Q,UAAAA,GACAC,WAAAA,OAEK,iCACP,OAASC,aAAAA,OAA+B,SACxC,OAAO5jB,MAAe,iBAKtB,SAAS6jB,GACPjU,EACAI,EACsB,CACtB,OAAIJ,aAAoB8T,GACf,CACL7T,KAAM,SACNiU,OAAQ,EACRjT,MAAO,GACP,GAAGb,GAGA,CACLH,KAAM,UACNiU,OAAQ,EACRjT,MAAO,GACP,GAAGb,GAhBE6T,EAAAA,GAAAA,4BAuBT,SAASE,GACPnU,EACAI,EACwB,CACxB,OAAOA,EAAS9E,IAAKhG,GAAM2e,GAAyBjU,EAAU1K,CAAC,CAAC,EAJzD6e,EAAAA,GAAAA,iCA6BF,SAASC,GACdpU,EACAe,EACA,CACA,IAAM5B,EAAkBa,GAAAA,YAAAA,EAAUpM,aAElC,OAAO+c,EACLrR,EAAUU,SAASa,IAAIC,IAAI3B,EAAiB4B,CAAO,EACnD,UACE3Q,EAAU4P,EAAU,+BAA+B,EACnD5P,EAAU4P,EAASc,IAAK,wCAAwC,EAEzDmT,GACLjU,EACA,MAAMA,EAASc,IAAIkT,GAAUK,KAAKtT,GAAW,CAAC,CAAC,CAAC,GAGpD,CACEwP,QAAS,CAAC,CAACvQ,GAAYe,IAAYrP,OACpC,EAnBW0iB,EAAAA,GAAAA,UA0CT,SAASE,GACdtU,EACAuU,EACA,CACA,IAAMpV,EAAkBa,GAAAA,YAAAA,EAAUpM,aAClC,OAAO+c,EACLrR,EAAUU,SAASa,IAAIK,MAAM/N,IAAIgM,EAAiBoV,CAAW,EAC7D,SAAY,CArIhB,IAAAljB,EAsIMjB,OAAAA,EAAU4P,EAAU,+BAA+B,EACnD5P,GACE4P,EAAAA,EAASkB,QAATlB,YAAAA,EAAgB7M,IAChB,8CAA8C,EAGzCghB,GACLnU,EACA,MAAMA,EAASkB,MAAM/N,IAAIohB,CAAW,CAAC,GAGzC,CACEhE,QAAS,CAAC,CAACvQ,GAAY,CAACb,EACxBqV,iBAAkB,GACnB,EAtBWF,EAAAA,GAAAA,WA4CT,SAASG,MACX,CAACzU,EAAUe,CAAO,EACrB,CACA,IAAM5B,EAAkBa,GAAAA,YAAAA,EAAUpM,aAClC,OAAO+c,EACLrR,EAAUU,SAASa,IAAIK,MAAME,uBAAuBjC,CAAe,EACnE,IAAM,CAhLV,IAAA9N,EAAAiB,EAkLM,OADAlC,EAAU4P,EAAU,+BAA+B,EAC/CA,aAAoB8T,IACtB1jB,GACE4P,EAAAA,GAAAA,YAAAA,EAAUkB,QAAVlB,YAAAA,EAAiBoB,uBACjB,iEAAiE,EAE5DpB,EAASkB,MAAME,uBAAsB,IAE9ChR,GACE4P,EAAAA,EAASkB,QAATlB,YAAAA,EAAgBoB,uBAChB,wDAAwD,EAE1DhR,EAAU2Q,EAAS,qBAAqB,EACjCf,EAASkB,MAAME,uBAAuBL,CAAO,IAEtD,CACEwP,QAAS,CAAC,CAACvQ,EACZ,EAxBWyU,EAAAA,GAAAA,6BAiDT,SAASC,GAAc1U,EAAsC,CAClE,IAAMb,EAAkBa,GAAAA,YAAAA,EAAUpM,aAClC,OAAO+c,EACLrR,EAAUU,SAASa,IAAIK,MAAMG,WAAWlC,CAAe,EACvD,IAAM,CA/NV,IAAA9N,EAAAiB,EAiOM,OADAlC,EAAU4P,EAAU,+BAA+B,EAC/CA,aAAoB8T,IACtB1jB,GACE4P,EAAAA,GAAAA,YAAAA,EAAUkB,QAAVlB,YAAAA,EAAiBoB,uBACjB,iEAAiE,EAE5DpB,EAASkB,MAAME,uBAAsB,IAE9ChR,GACE4P,EAAAA,EAASkB,QAATlB,YAAAA,EAAgBqB,WAChB,qDAAqD,EAEhDrB,EAASkB,MAAMG,WAAU,IAElC,CACEkP,QAAS,CAAC,CAACvQ,EACZ,EArBW0U,EAAAA,GAAAA,iBA4CT,SAASC,GACd3U,EACA4U,EACA,CACA,IAAMzV,EAAkBa,GAAAA,YAAAA,EAAUpM,aAClC,OAAO+c,EACLrR,EAAUU,SAASa,IAAIK,MAAMI,MAAMnO,IAAIgM,EAAiByV,CAAkB,EAC1E,SAAY,CA9QhB,IAAAvjB,EAAAiB,EAAAC,EAgRM,OADAnC,EAAU4P,EAAU,+BAA+B,EAC/CA,aAAoB8T,IACtB1jB,GACE4P,GAAAA,EAAAA,EAASkB,QAATlB,YAAAA,EAAgBsB,QAAhBtB,YAAAA,EAAuB7M,IACvB,oDAAoD,EAE/CghB,GACLnU,EACA,MAAMA,EAASkB,MAAMI,MAAMnO,IAAIyhB,CAAkB,CAAC,IAGtDxkB,GACE4P,EAAAA,EAASkB,QAATlB,YAAAA,EAAgBsB,MAChB,gDAAgD,EAE3C6S,GACLnU,EACA,MAAMA,EAASkB,MAAMI,MAAMsT,CAAkB,CAAC,IAGlD,CACErE,QAAS,CAAC,CAACvQ,GAAY,CAAC,CAAC4U,EAC1B,EA9BWD,EAAAA,GAAAA,gBAqDT,SAASE,MACX,CAAC7U,EAAU4U,EAAoB7T,CAAO,EACzC,CACA,IAAM5B,EAAkBa,GAAAA,YAAAA,EAAUpM,aAClC,OAAO+c,EACLrR,EAAUU,SAASa,IAAIG,UACrB7B,EACAyV,EACA7T,CAAO,EAET,KACE3Q,EAAU4P,EAAU,+BAA+B,EACnD5P,EACE4P,EAASgB,UACT,8CAA8C,EAEhD5Q,EAAUwkB,EAAoB,kCAAkC,EAC5D5U,aAAoB+T,IACtB3jB,EAAU2Q,EAAS,qBAAqB,EACjCf,EAASgB,UAAU4T,EAAoB7T,CAAO,GAEhDf,EAASgB,UAAU4T,CAAkB,GAE9C,CACErE,QAAS,CAAC,CAACvQ,GAAY,CAAC,CAAC4U,EAC1B,EAzBWC,EAAAA,GAAAA,iBAyFT,SAASC,GACd9U,EACA,CACA,IAAMyI,EAAgB5J,EAAgB,EAChCM,EAAkBa,GAAAA,YAAAA,EAAUpM,aAC5BgI,EAAcsH,GAAc,EAElC,OAAO6N,GACL,MAAOjX,GAAmC,CA7Z9C,IAAAzI,EAgaM,GAFAjB,EAAU0J,EAAKib,GAAI,0BAA0B,EAC7C3kB,GAAU4P,EAAAA,GAAAA,YAAAA,EAAUgV,OAAVhV,YAAAA,EAAgB+U,GAAI,mCAAmC,EAC7D/U,aAAoB+T,GAAS,CAC/B3jB,EAAU,WAAY0J,EAAM,qBAAqB,EACjD,GAAM,CAAEib,GAAAA,EAAI3U,SAAAA,EAAU8T,OAAAA,CAAM,EAAKpa,EACjC,OAAQ,MAAMkG,EAASgV,KAAKD,GAAGA,EAAI,CACjC3U,SAAAA,EACA8T,OAAQF,GAAUK,KAAKH,GAAU,CAAC,EACnC,EAEH,OAAQ,MAAMlU,EAASgV,KAAKD,GAC1Bjb,EAAKib,GACLjb,EAAKsG,QAAQ,GAGjB,CACEwS,UAAW,IACTnT,EACE7D,EACAuD,EACAsJ,CAAa,EAElB,EA/BWqM,EAAAA,GAAAA,cA2FT,SAASG,GAAiBjV,EAAmB,CAClD,IAAMyI,EAAgB5J,EAAgB,EAChCM,EAAkBa,GAAAA,YAAAA,EAAUpM,aAC5BgI,EAAcsH,GAAc,EAElC,OAAO6N,GACL,MAAOjX,GAA8B,CAtfzC,IAAAzI,EAufMjB,EAAU0J,EAAKib,GAAI,0BAA0B,EAC7C3kB,GACE4P,EAAAA,GAAAA,YAAAA,EAAUgV,OAAVhV,YAAAA,EAAgBkV,mBAChB,mDAAmD,EAGrD9kB,EAAU,YAAa0J,EAAM,sBAAsB,EACnD1J,EAAU,qBAAsB0J,EAAM,+BAA+B,EACrE,GAAM,CAAEib,GAAAA,EAAIhU,QAAAA,EAASoU,iBAAAA,CAAgB,EAAKrb,EAC1C,OAAO,MAAMkG,EAASgV,KAAKE,mBACzBH,EACAhU,EACAoU,CAAgB,GAGpB,CACEvC,UAAW,IACTnT,EACE7D,EACAuD,EACAsJ,CAAa,EAElB,EA7BWwM,EAAAA,GAAAA,oBAyFT,SAASG,GACdpV,EACA,CACA,IAAMyI,EAAgB5J,EAAgB,EAChCM,EAAkBa,GAAAA,YAAAA,EAAUpM,aAC5BgI,EAAcsH,GAAc,EAElC,OAAO6N,GACJjX,IACC1J,EAAU4P,GAAAA,YAAAA,EAAUqV,SAAU,oCAAoC,EAC9DrV,aAAoB+T,IACtB3jB,EAAU,WAAY0J,EAAM,qBAAqB,EAC1CkG,EAASqV,SAASvb,EAAKib,GAAIjb,EAAKiH,QAASjH,EAAKwb,MAAM,GAGtDtV,EAASqV,SAASvb,EAAKib,GAAIjb,EAAKiH,OAAO,GAEhD,CACE6R,UAAW,IACTnT,EACE7D,EACAuD,EACAsJ,CAAa,EAElB,EAxBW2M,EAAAA,GAAAA,kBAyFT,SAASG,GAAcvV,EAAmB,CAC/C,IAAMyI,EAAgB5J,EAAgB,EAChCM,EAAkBa,GAAAA,YAAAA,EAAUpM,aAC5BgI,EAAcsH,GAAc,EAElC,OAAO6N,GACL,CAAC,CAAEhQ,QAAAA,EAASyU,UAAAA,CAAS,KACnBplB,EAAU4P,GAAAA,YAAAA,EAAUyV,QAAS,mCAAmC,EAEzDzV,EAASyV,QAAQ1U,EAASyU,CAAS,GAE5C,CACE5C,UAAW,IACTnT,EACE7D,EACAuD,EACAsJ,CAAa,EAElB,EAlBW8M,EAAAA,GAAAA,iBAkFT,SAASG,GACd1V,EACA,CACA,IAAMyI,EAAgB5J,EAAgB,EAChCM,EAAkBa,GAAAA,YAAAA,EAAUpM,aAC5BgI,EAAcsH,GAAc,EAElC,OAAO6N,GACL,MAAOjX,GAAmC,CAGxC,GAFA1J,EAAU0J,EAAKiH,QAAS,qBAAqB,EAC7C3Q,EAAU4P,GAAAA,YAAAA,EAAU2V,KAAM,gCAAgC,EACtD3V,aAAoB+T,GAAS,CAC/B3jB,EAAU,WAAY0J,EAAM,qBAAqB,EACjD,GAAM,CAAEiH,QAAAA,EAASuU,OAAAA,CAAM,EAAKxb,EAC5B,OAAO,MAAMkG,EAAS2V,KAAKC,OAAO7U,EAASuU,CAAM,EAEnD,GAAM,CAAEvU,QAAAA,CAAO,EAAKjH,EACpB,OAAO,MAAMkG,EAAS2V,KAAKhU,MAAMZ,CAAO,GAE1C,CACE6R,UAAW,IACTnT,EACE7D,EACAuD,EACAsJ,CAAa,EAElB,EA1BWiN,EAAAA,GAAAA,cCtuBhB,OAAS3E,eAAAA,GAAa7N,kBAAAA,OAAsB,wBAC5C,OACE6Q,WAAAA,OAMK,iCACP,OAAO3jB,MAAe,iBAmBf,SAASylB,GACd7V,EACAuU,EACA,CACA,IAAMpV,EAAkBa,GAAAA,YAAAA,EAAUpM,aAClC,OAAO+c,EACLrR,EAAUU,SAASa,IAAIU,KAAKC,gBAAgBrC,EAAiBoV,CAAW,EACxE,KACEnkB,EAAU4P,EAAU,+BAA+B,EACnD5P,EACE4P,EAASwB,gBACT,oDAAoD,EAE/CxB,EAASwB,gBAAgB+S,CAAW,GAE7C,CAAEhE,QAAS,CAAC,CAACvQ,EAAU,EAfX6V,EAAAA,GAAAA,oBAkCT,SAASC,GACd9V,EACAuU,EACA,CACA,OAAOD,GAAQtU,EAAUuU,CAAW,EAJtBuB,EAAAA,GAAAA,kBAWT,SAASC,GACd/V,EACA,CACA,IAAMb,EAAkBa,GAAAA,YAAAA,EAAUpM,aAClC,OAAO+c,EACLrR,EAAUU,SAASa,IAAIU,KAAKE,qBAAqBtC,CAAe,EAChE,KACE/O,EAAU4P,EAAU,+BAA+B,EAEnD5P,EACE4P,EAASyB,qBACT,yDAAyD,EAEpDzB,EAASyB,qBAAoB,GAEtC,CAAE8O,QAAS,CAAC,CAACvQ,EAAU,EAfX+V,EAAAA,GAAAA,yBAwBT,SAASC,GAAoBhW,EAAuC,CACzE,IAAMb,EAAkBa,GAAAA,YAAAA,EAAUpM,aAClC,OAAO+c,EACLrR,EAAUU,SAASa,IAAIU,KAAKG,mBAAmBvC,CAAe,EAC9D,KACE/O,EAAU4P,EAAU,+BAA+B,EAC/CA,aAAoB+T,GACf/T,EAASiW,cAAa,GAE/B7lB,EACE4P,EAAS0B,mBACT,uDAAuD,EAElD1B,EAAS0B,mBAAkB,IAEpC,CAAE6O,QAAS,CAAC,CAACvQ,EAAU,EAfXgW,EAAAA,GAAAA,uBAqDT,SAASE,GACdlW,EACA,CACA,IAAMyI,EAAgB5J,EAAgB,EAChCM,EAAkBa,GAAAA,YAAAA,EAAUpM,aAC5BgI,EAAcsH,GAAc,EAElC,OAAO6N,GACL,MAAOjX,GAAoC,CAGzC,GAFA1J,EAAU0J,EAAKib,GAAI,0BAA0B,EAC7C3kB,EAAU4P,GAAAA,YAAAA,EAAUmW,QAAS,mCAAmC,EAC5DnW,aAAoB+T,GAAS,CAC/B3jB,EAAU,YAAa0J,EAAM,sBAAsB,EACnD,GAAM,CAAEib,GAAAA,EAAIhU,QAAAA,EAASqV,SAAAA,CAAQ,EAAKtc,EAClC,OAAQ,MAAMkG,EAASmW,QACrBpB,EACAhU,EACAqV,EACAtc,EAAKuc,mBAAmB,EAG5B,OAAQ,MAAMrW,EAASmW,QACrBrc,EAAKib,GACLjb,EAAKsc,SACLtc,EAAKuc,mBAAmB,GAG5B,CACEzD,UAAW,IACTnT,EACE7D,EACAuD,EACAsJ,CAAa,EAElB,EAlCWyN,EAAAA,GAAAA,eA8CT,SAASI,GACdtW,EACAuW,EACA,CACA,IAAM9N,EAAgB5J,EAAgB,EAChCM,EAAkBa,GAAAA,YAAAA,EAAUpM,aAC5BgI,EAAcsH,GAAc,EAElC,OAAO6N,GACL,MAAOjX,GAA4C,CA3NvD,IAAAzI,EA4NMjB,GACE4P,EAAAA,GAAAA,YAAAA,EAAUuB,OAAVvB,YAAAA,EAAgBwW,SAChB,yCAAyC,EAE3C,IAAI/kB,EACJ,OAAI8kB,IACF9kB,EAAU,CACR8kB,WAAAA,IAGG,MAAMvW,EAASuB,KAAKiV,SAAS1c,EAAK2c,UAAWhlB,CAAO,GAE7D,CACEmhB,UAAW,IACTnT,EACE7D,EACAuD,EACAsJ,CAAa,EAElB,EA7BW6N,EAAAA,GAAAA,eC1MhB,OAASvF,eAAAA,GAAa7N,kBAAAA,OAAsB,wBAQ5C,OAASwT,eAAAA,OAAmB,iCAC5B,OAAS1C,aAAAA,OAA+B,SACxC,OAAO5jB,MAAe,iBAmBf,SAASumB,GACd3W,EACA+B,EACA,CACA,IAAM5C,EAAkBa,GAAAA,YAAAA,EAAUpM,aAClC,OAAO+c,EACLrR,EAAUU,SAAS6B,YAAYC,WAAW3C,EAAiB4C,CAAS,EACpE,KACE3R,EAAU4P,EAAU,+BAA+B,EAC5CA,EAAS8B,WAAWkS,GAAUK,KAAKtS,GAAa,CAAC,CAAC,GAE3D,CACEwO,QAAS,CAAC,CAACvQ,GAAY,CAACb,EACxBqV,iBAAkB,GACnB,EAdWmC,EAAAA,GAAAA,cA+BT,SAASC,GACd5W,EACAzO,EACA,CACA,IAAM4N,EAAkBa,GAAAA,YAAAA,EAAUpM,aAClC,OAAO+c,EACLrR,EAAUU,SAAS6B,YAAYG,eAAe7C,EAAiB5N,CAAM,EACrE,KACEnB,EAAU4P,EAAU,+BAA+B,EAC5CA,EAASgC,eAAezQ,CAAM,GAEvC,CACEgf,QAAS,CAAC,CAACvQ,GAAY,CAACb,EACxBqV,iBAAkB,GACnB,EAdWoC,EAAAA,GAAAA,eA+BT,SAASC,GACd7W,EACAzO,EACA,CACA,IAAM4N,EAAkBa,GAAAA,YAAAA,EAAUpM,aAClC,OAAO+c,EACLrR,EAAUU,SAAS6B,YAAYI,kBAAkB9C,EAAiB5N,CAAM,EACxE,KACEnB,EAAU4P,EAAU,+BAA+B,EAE5CA,EAASiC,kBAAkB1Q,CAAM,GAE1C,CACEgf,QAAS,CAAC,CAACvQ,GAAY,CAACb,EACxBqV,iBAAkB,GACnB,EAfWqC,EAAAA,GAAAA,qBAgCT,SAASC,GACd9W,EACA+B,EACA,CACA,IAAM5C,EAAkBa,GAAAA,YAAAA,EAAUpM,aAClC,OAAO+c,EACLrR,EAAUU,SAAS6B,YAAYM,QAAQC,cACrCjD,EACA4C,CAAS,EAEX,KACE3R,EAAU4P,EAAU,+BAA+B,EAC5CA,EAASmC,QAAQC,cAAc4R,GAAUK,KAAKtS,GAAa,CAAC,CAAC,GAEtE,CACEwO,QAAS,CAAC,CAACvQ,GAAY+B,IAAcrQ,OACtC,EAhBWolB,EAAAA,GAAAA,iBAiCT,SAASC,GACd/W,EACA+B,EACA,CACA,IAAM5C,EAAkBa,GAAAA,YAAAA,EAAUpM,aAClC,OAAO+c,EACLrR,EAAUU,SAAS6B,YAAYM,QAAQE,UACrClD,EACA4C,CAAS,EAEX,SAAY,CA9KhB,IAAA1Q,EA+KMjB,EAAU4P,EAAU,+BAA+B,EACnD,IAAIgX,EACJ,GAAI,CACFA,EAAS,MAAMhX,EAASmC,QAAQE,UAC9B2R,GAAUK,KAAKtS,GAAa,CAAC,CAAC,QAEzBgE,EAAP,CACA,GAAI,GAAEA,EAAAA,GAAAA,YAAAA,EAAekR,UAAflR,MAAAA,EAAwBW,SAAS,2BACrC,MAAMX,EAGV,OAAOiR,GAET,CACEzG,QAAS,CAAC,CAACvQ,GAAY+B,IAAcrQ,OACtC,EA1BWqlB,EAAAA,GAAAA,oBA2CT,SAASG,GAAalX,EAAsC,CACjE,IAAMb,EAAkBa,GAAAA,YAAAA,EAAUpM,aAClC,OAAO+c,EACLrR,EAAUU,SAAS6B,YAAYK,gBAAgB/C,CAAe,EAC9D,KACE/O,EAAU4P,EAAU,+BAA+B,EAC5CA,EAASkC,gBAAe,GAEjC,CACEqO,QAAS,CAAC,CAACvQ,EACZ,EAVWkX,EAAAA,GAAAA,gBAiDT,SAASC,GAAuBnX,EAAsC,CAC3E,IAAMyI,EAAgB5J,EAAgB,EAChCM,EAAkBa,GAAAA,YAAAA,EAAUpM,aAC5BgI,EAAcsH,GAAc,EAC5BpD,EAAgBkG,EAAU,EAChC,OAAO+K,GACL,MAAOjX,GAA2B,CAtQtC,IAAAzI,EAuQMjB,OAAAA,EAAU0P,EAAe,4CAA4C,EACrE1P,GACE4P,EAAAA,GAAAA,YAAAA,EAAUoX,SAAVpX,YAAAA,EAAkBqX,cAClB,gDAAgD,EAE3C,MAAMrX,EAASoX,OAAOC,cAAcvd,CAAI,GAEjD,CACE8Y,UAAW,IACTnT,EACE7D,EACAuD,EACAsJ,CAAa,EAElB,EArBW0O,EAAAA,GAAAA,0BAwDT,SAASG,GAAwBtX,EAAsC,CAC5E,IAAMyI,EAAgB5J,EAAgB,EAChCM,EAAkBa,GAAAA,YAAAA,EAAUpM,aAC5BgI,EAAcsH,GAAc,EAC5BpD,EAAgBkG,EAAU,EAChC,OAAO+K,GACL,MAAOjX,GAA4B,CA9TvC,IAAAzI,EA+TMjB,OAAAA,EAAU0P,EAAe,4CAA4C,EACrE1P,GACE4P,EAAAA,GAAAA,YAAAA,EAAUoX,SAAVpX,YAAAA,EAAkBqX,cAClB,iDAAiD,EAE5C,MAAMrX,EAASmC,QAAQkV,cAAcvd,CAAI,GAElD,CACE8Y,UAAW,IACTnT,EACE7D,EACAuD,EACAsJ,CAAa,EAElB,EArBW6O,EAAAA,GAAAA,2BAwDT,SAASC,GAAWvX,EAAsC,CAC/D,IAAMyI,EAAgB5J,EAAgB,EAChCM,EAAkBa,GAAAA,YAAAA,EAAUpM,aAC5BgI,EAAcsH,GAAc,EAC5BpD,EAAgBkG,EAAU,EAChC,OAAO+K,GACL,MAAOjX,GAAwB,CAtXnC,IAAAzI,EAuXMjB,OAAAA,EAAU0P,EAAe,sCAAsC,EAC/D1P,GACE4P,EAAAA,GAAAA,YAAAA,EAAUmC,UAAVnC,YAAAA,EAAmBwX,QACnB,2CAA2C,EAEtC,MAAMxX,EAASmC,QAAQqV,QAAQ1d,EAAKiI,UAAWjI,EAAK2d,GAAG,GAEhE,CACE7E,UAAW,IACTnT,EACE7D,EACAuD,EACAsJ,CAAa,EAElB,EArBW8O,EAAAA,GAAAA,cAwDT,SAASG,GAAU1X,EAAsC,CAC9D,IAAMyI,EAAgB5J,EAAgB,EAChCM,EAAkBa,GAAAA,YAAAA,EAAUpM,aAC5BgI,EAAcsH,GAAc,EAC5BpD,EAAgBkG,EAAU,EAChC,OAAO+K,GACL,MAAOjX,GAAuB,CA9alC,IAAAzI,EAgbM,OADAjB,EAAU0P,EAAe,sCAAsC,EAC3DhG,EAAKmG,OAASyW,GAAYiB,QAC5BvnB,EACE4P,GAAAA,YAAAA,EAAUoX,OAAOQ,cACjB,gDAAgD,EAG3C,MAAM5X,EAASoX,OAAOQ,cAC3B9d,EAAK9I,GACL8I,EAAK+d,UACL/d,EAAKge,YAAY,IAGrB1nB,GACE4P,EAAAA,GAAAA,YAAAA,EAAUmC,UAAVnC,YAAAA,EAAmB4X,cACnB,iDAAiD,EAE5C,MAAM5X,EAASmC,QAAQyV,cAAc9d,EAAK9I,EAAE,IAErD,CACE4hB,UAAW,IACTnT,EACE7D,EACAuD,EACAsJ,CAAa,EAElB,EAjCWiP,EAAAA,GAAAA,aC3ZhB,OAAS3G,eAAAA,GAAa7N,kBAAAA,OAAsB,wBAE5C,OAAO9S,MAAe,iBAkBf,SAAS2nB,GAAe/X,EAAgC,CAC7D,IAAMb,EAAkBa,GAAAA,YAAAA,EAAUpM,aAClC,OAAO+c,EACLrR,EAAUU,SAAS2B,MAAMC,YAAYzC,CAAe,EACpD,KACE/O,EAAU4P,EAAU,+BAA+B,EAC5CA,EAAS4B,YAAW,GAE7B,CACE2O,QAAS,CAAC,CAACvQ,GAAY,CAAC,CAACb,EAC1B,EAVW4Y,EAAAA,GAAAA,kBA0BT,SAASC,GACdhY,EACAF,EACA,CACA,IAAMX,EAAkBa,GAAAA,YAAAA,EAAUpM,aAClC,OAAO+c,EACLrR,EAAUU,SAAS2B,MAAMX,UAAU7B,EAAiBW,CAAa,EACjE,UACE1P,EAAU4P,EAAU,+BAA+B,EACnD5P,EAAU0P,EAAe,qBAAqB,EACvC,MAAME,EAASgB,UAAUlB,CAAa,GAE/C,CACEyQ,QAAS,CAAC,CAACzQ,GAAiB,CAAC,CAACE,EAC/B,EAdWgY,EAAAA,GAAAA,mBAqDT,SAASC,GAAajY,EAAgC,CAC3D,IAAMyI,EAAgB5J,EAAgB,EAChCM,EAAkBa,GAAAA,YAAAA,EAAUpM,aAC5BgI,EAAcsH,GAAc,EAElC,OAAO6N,GACJjX,GAAsB,CAtH3B,IAAAzI,EAuHM,GAAM,CAAE0jB,GAAAA,EAAIO,OAAAA,CAAM,EAAKxb,EACvB1J,OAAAA,GAAU4P,EAAAA,GAAAA,YAAAA,EAAUgV,OAAVhV,YAAAA,EAAgB+U,GAAI,mCAAmC,EAC1D/U,EAASgV,KAAKD,GAAGA,EAAIO,CAAM,GAEpC,CACE1C,UAAW,IACTnT,EACE7D,EACAuD,EACAsJ,CAAa,EAElB,EAlBWwP,EAAAA,GAAAA,gBAqDT,SAASC,GACdlY,EACA,CACA,IAAMyI,EAAgB5J,EAAgB,EAChCM,EAAkBa,GAAAA,YAAAA,EAAUpM,aAC5BgI,EAAcsH,GAAc,EAElC,OAAO6N,GACL,MAAOjX,IACL1J,EAAU0J,EAAKib,GAAI,0BAA0B,EAC7C3kB,EAAU4P,GAAAA,YAAAA,EAAUmW,QAAS,mCAAmC,EACzD,MAAMnW,EAASmW,QACpBrc,EAAKib,GACLjb,EAAKwb,OACLxb,EAAKuc,mBAAmB,GAG5B,CACEzD,UAAW,IACTnT,EACE7D,EACAuD,EACAsJ,CAAa,EAElB,EAxBWyP,EAAAA,GAAAA,iBA2DT,SAASC,GAAiBnY,EAAgC,CAC/D,IAAMyI,EAAgB5J,EAAgB,EAChCM,EAAkBa,GAAAA,YAAAA,EAAUpM,aAC5BgI,EAAcsH,GAAc,EAElC,OAAO6N,GACJjX,GAAsB,CACrB,GAAM,CAAEib,GAAAA,EAAIO,OAAAA,CAAM,EAAKxb,EACvB1J,OAAAA,EAAU4P,GAAAA,YAAAA,EAAUqV,SAAU,oCAAoC,EAC3DrV,EAASqV,SAASN,EAAIO,CAAM,GAErC,CACE1C,UAAW,IACTnT,EACE7D,EACAuD,EACAsJ,CAAa,EAElB,EAlBW0P,EAAAA,GAAAA,oBAqDT,SAASC,GAAsBpY,EAAgC,CACpE,IAAMyI,EAAgB5J,EAAgB,EAChCM,EAAkBa,GAAAA,YAAAA,EAAUpM,aAC5BgI,EAAcsH,GAAc,EAElC,OAAO6N,GACJjX,GAAwB,CACvB1J,EACE4P,GAAAA,YAAAA,EAAUqY,cACV,yCAAyC,EAE3C,IAAMC,EAAgBxe,EAAKwB,IAAKqG,IAAW,CACzC4W,UAAW5W,EAAMoT,GACjBO,OAAQ3T,EAAM2T,QACd,EAEF,OAAOtV,EAASqY,cAAcC,CAAa,GAE7C,CACE1F,UAAW,IACTnT,EACE7D,EACAuD,EACAsJ,CAAa,EAElB,EAzBW2P,EAAAA,GAAAA,yBA4DT,SAASI,GAAaxY,EAAgC,CAC3D,IAAMyI,EAAgB5J,EAAgB,EAChCM,EAAkBa,GAAAA,YAAAA,EAAUpM,aAC5BgI,EAAcsH,GAAc,EAElC,OAAO6N,GACJjX,GAA0B,CACzB,GAAM,CAAEwb,OAAAA,CAAM,EAAKxb,EACnB1J,OAAAA,EAAU4P,GAAAA,YAAAA,EAAU2V,KAAM,gCAAgC,EACnD3V,EAAS2V,KAAKC,OAAON,CAAM,GAEpC,CACE1C,UAAW,IACTnT,EACE7D,EACAuD,EACAsJ,CAAa,EAElB,EAlBW+P,EAAAA,GAAAA,gBC9UhB,OAEEzE,WAAAA,MAIK,iCAEP,OAAO3jB,MAAe,iBAgCf,SAASqoB,MAEX,CAACzY,EAAUe,CAAO,EAA0C,CAC/D,IAAM5B,EAAkBa,GAAAA,YAAAA,EAAUpM,aAElC,OAAO+c,EACLrR,EAAUgD,WAAWC,gBAAgBC,UAAUrD,EAAiB4B,CAAO,EACvE,KACE3Q,EAAU4P,EAAU,+BAA+B,EACnD5P,EACE4P,EAASuC,gBAAgBC,UACzB,8DAA8D,EAE5DxC,aAAoB+T,GACtB3jB,EAAU2Q,EAAS,kDAAkD,EAC9Df,EAASuC,gBAAgBC,UAAUzB,CAAO,GAE5Cf,EAASuC,gBAAgBC,UAAS,GAE3C,CAIE+N,QAASvQ,aAAoB+T,EAAUhT,IAAYrP,OAAY,CAAC,CAACsO,EAClE,EAxBWyY,EAAAA,GAAAA,2BAkDT,SAASC,MAEX,CAAC1Y,EAAUe,CAAO,EAA0C,CAC/D,IAAM5B,EAAkBa,GAAAA,YAAAA,EAAUpM,aAElC,OAAO+c,EACLrR,EAAUgD,WAAWC,gBAAgBE,OAAOtD,EAAiB4B,CAAO,EACpE,KACE3Q,EAAU4P,EAAU,+BAA+B,EACnD5P,EACE4P,EAASuC,gBAAgBE,OACzB,2DAA2D,EAEzDzC,aAAoB+T,GACtB3jB,EAAU2Q,EAAS,kDAAkD,EAC9Df,EAASuC,gBAAgBE,OAAO1B,CAAO,GAEzCf,EAASuC,gBAAgBE,OAAM,GAExC,CAIE8N,QAASvQ,aAAoB+T,EAAUhT,IAAYrP,OAAY,CAAC,CAACsO,EAClE,EAxBW0Y,EAAAA,GAAAA,sBAyET,SAASC,MAEX,CAAC3Y,EAAUmB,EAAQJ,CAAO,EAA6C,CAC1E,IAAM5B,EAAkBa,GAAAA,YAAAA,EAAUpM,aAElC,OAAO+c,EACLrR,EAAUgD,WAAWC,gBAAgBG,6BACnCvD,EACAgC,EACAJ,CAAO,EAET,KACE3Q,EAAU4P,EAAU,+BAA+B,EACnD5P,EACE4P,EAASuC,gBAAgBG,6BACzB,iFAAiF,EAE/E1C,aAAoB+T,GACtB3jB,EACE2Q,EACA,6DAA6D,EAExDf,EAASuC,gBAAgBG,6BAC9B3B,EACAI,EAAOiV,SACPjV,EAAOrB,aAAa,GAGjBE,EAASuC,gBAAgBG,6BAC9BvB,EAAOiV,SACPjV,EAAOrB,aAAa,GAGxB,CAMEyQ,SACGvQ,aAAoB+T,EAAUhT,IAAYrP,OAAY,CAAC,CAACsO,IACzD,CAAC,CAACmB,GACF,CAAC,CAACA,EAAOrB,cACZ,EA3CW6Y,EAAAA,GAAAA,gCC/JhB,OAASrU,YAAAA,OAAgB,wBACzB,OAASsU,cAAAA,OAAkB,iCAC3B,OAASle,WAAAA,OAAe,QASjB,SAASme,GAAW9Y,EAAgC,CACzD,GAAM,CAAEpH,UAAAA,CAAS,EAAKO,EAAwB,EACxChF,EAAUqU,GAAU,EACpB/V,EAASgH,GAAS,EAClBsG,EAAgBkG,EAAU,EAE1B8S,EAAYpe,GAAQ,IAAM,CAC9B,GAAIlI,EACF,OAAO,IAAIomB,GAAWpmB,EAAQ,CAC5BiL,iBAAkB,CAChBzH,OAAQ2C,EAAUzE,GAClBA,QAAAA,GAEH,GAGF,CAAC1B,EAAQ0B,EAAQ,EAEd8e,EAAWtY,GAAQ,IAChB4E,EAAUM,OAAOC,QAAQ3L,EAAS4L,EAAeC,CAAY,EACnE,CAAC7L,EAAS6L,EAAcD,EAAc,EAEzC,OAAOwE,GACL0O,EACA,IACS8F,GAAAA,YAAAA,EAAWjZ,QAAQE,GAE5B,CAEEwQ,QAAS,CAAC,CAACuI,GAAa,CAAC,CAAChZ,EAC1BiZ,MAAO,GACPvE,iBAAkB,GACnB,EAhCWqE,EAAAA,GAAAA,cCXhB,OAAS9H,eAAAA,GAAa7N,kBAAAA,OAAsB,wBAM5C,OAAO9S,MAAe,iBAgBf,SAAS4oB,GACdhZ,EACA,CACA,IAAMb,EAAkBa,GAAAA,YAAAA,EAAUpM,aAClC,OAAO+c,EACLrR,EAAUgD,WAAWK,MAAMC,aAAazD,CAAe,EACvD,KACE/O,EAAU4P,EAAU,sBAAsB,EAC1C5P,EACE,UAAW4P,GAAYA,EAAS2C,MAChC,uCAAuC,EAElC3C,EAAS2C,MAAMC,aAAY,GAEpC,CAAE2N,QAAS,CAAC,CAACvQ,GAAY,CAAC,CAACb,EAAiB,EAdhC6Z,EAAAA,GAAAA,2BAiDT,SAASC,GACdjZ,EACA,CACA,IAAMpE,EAAcsH,GAAc,EAC5B/D,EAAkBa,GAAAA,YAAAA,EAAUpM,aAC5B6U,EAAgB5J,EAAgB,EACtC,OAAOkS,GACJmI,IACC9oB,EAAU4P,EAAU,sBAAsB,EAC1C5P,EACE,UAAW4P,GAAYA,EAAS2C,MAChC,uCAAuC,EAElC3C,EAAS2C,MAAMwW,aAAaD,CAAY,GAEjD,CACEtG,UAAW,IACTnT,EACE7D,EACAuD,EACAsJ,CAAa,EAElB,EAtBWwQ,EAAAA,GAAAA,iCA0CT,SAASG,GACdpZ,EACA,CACA,IAAMb,EAAkBa,GAAAA,YAAAA,EAAUpM,aAClC,OAAO+c,EACLrR,EAAUgD,WAAWO,UAAUC,sBAAsB3D,CAAe,EACpE,KACE/O,EAAU4P,EAAU,sBAAsB,EAC1C5P,EACE,cAAe4P,GAAYA,EAAS6C,UACpC,qCAAqC,EAEhC7C,EAAS6C,UAAUC,sBAAqB,GAEjD,CAAEyN,QAAS,CAAC,CAACvQ,GAAY,CAAC,CAACb,EAAiB,EAdhCia,EAAAA,GAAAA,sBAiDT,SAASC,GACdrZ,EACA,CACA,IAAMpE,EAAcsH,GAAc,EAC5B/D,EAAkBa,GAAAA,YAAAA,EAAUpM,aAC5B6U,EAAgB5J,EAAgB,EACtC,OAAOkS,GACJuI,IAIClpB,EAAU4P,EAAU,sBAAsB,EAC1C5P,EACE,cAAe4P,GAAYA,EAAS6C,UACpC,qCAAqC,EAEhC7C,EAAS6C,UAAU0W,sBAAsBD,CAAa,GAE/D,CACE1G,UAAW,IACTnT,EACE7D,EACAuD,EACAsJ,CAAa,EAElB,EAzBW4Q,EAAAA,GAAAA,4BA6CT,SAASG,GACdxZ,EACA,CACA,IAAMb,EAAkBa,GAAAA,YAAAA,EAAUpM,aAClC,OAAO+c,EACLrR,EAAUgD,WAAWS,aAAajC,IAAI3B,CAAe,EACrD,KACE/O,EAAU4P,EAAU,sBAAsB,EAC1C5P,EACE,iBAAkB4P,GAAYA,EAAS+C,aACvC,wCAAwC,EAEnC/C,EAAS+C,aAAajC,IAAG,GAElC,CAAEyP,QAAS,CAAC,CAACvQ,GAAY,CAAC,CAACb,EAAiB,EAdhCqa,EAAAA,GAAAA,mBAgDT,SAASC,GACdzZ,EACA,CACA,IAAMpE,EAAcsH,GAAc,EAC5B/D,EAAkBa,GAAAA,YAAAA,EAAUpM,aAC5B6U,EAAgB5J,EAAgB,EACtC,OAAOkS,GACJuI,IAIClpB,EAAU4P,EAAU,sBAAsB,EAC1C5P,EACE,iBAAkB4P,GAAYA,EAAS+C,aACvC,wCAAwC,EAEnC/C,EAAS+C,aAAa2W,IAAIJ,CAAa,GAEhD,CACE1G,UAAW,IACTnT,EACE7D,EACAuD,EACAsJ,CAAa,EAElB,EAzBWgR,EAAAA,GAAAA,yBA6CT,SAASE,GACd3Z,EACA,CACA,IAAMb,EAAkBa,GAAAA,YAAAA,EAAUpM,aAClC,OAAO+c,EACLrR,EAAUgD,WAAWlC,SAASU,IAAI3B,CAAe,EACjD,KACE/O,EAAU4P,EAAU,sBAAsB,EAC1C5P,EACE,aAAc4P,GAAYA,EAASI,SACnC,oCAAoC,EAE/BJ,EAASI,SAASU,IAAG,GAE9B,CAAEyP,QAAS,CAAC,CAACvQ,GAAY,CAAC,CAACb,EAAiB,EAdhCwa,EAAAA,GAAAA,eA+CT,SAASC,GACd5Z,EACA,CACA,IAAMpE,EAAcsH,GAAc,EAC5B/D,EAAkBa,GAAAA,YAAAA,EAAUpM,aAC5B6U,EAAgB5J,EAAgB,EACtC,OAAOkS,GACJuI,IACClpB,EAAU4P,EAAU,sBAAsB,EAC1C5P,EACE,aAAc4P,GAAYA,EAASI,SACnC,oCAAoC,EAE/BJ,EAASI,SAASyZ,OAAOP,CAAa,GAE/C,CACE1G,UAAW,IACTnT,EACE7D,EACAuD,EACAsJ,CAAa,EAElB,EAtBWmR,EAAAA,GAAAA,qBC3VhB,OAAS7I,eAAAA,GAAa7N,kBAAAA,OAAsB,wBAS5C,OAASpE,aAAAA,OAAiB,SAC1B,OAAO1O,MAAe,iBA4Cf,SAAS0pB,GACd9Z,EACA,CACA,IAAMb,EAAkBa,GAAAA,YAAAA,EAAUpM,aAClC,OAAO+c,EACLrR,EAAUgD,WAAWU,MAAMP,OAAOtD,CAAe,EACjD,KACE/O,EAAU4P,EAAU,sBAAsB,EAC1C5P,EAAU4P,EAASgD,MAAO,iCAAiC,EAEpDhD,EAASgD,MAAMP,OAAM,GAE9B,CACE8N,QAAS,CAAC,CAACvQ,GAAY,CAAC,CAACb,EAC1B,EAdW2a,EAAAA,GAAAA,qBA+BT,SAASC,GACd/Z,EACAiD,EACA,CACA,IAAM9D,EAAkBa,GAAAA,YAAAA,EAAUpM,aAClC,OAAO+c,EACLrR,EAAUgD,WAAWU,MAAMlC,IAAI3B,EAAiB8D,CAAI,EACpD,KACE7S,EAAU4P,EAAU,sBAAsB,EAC1C5P,EAAU4P,EAASgD,MAAO,iCAAiC,EACpDhD,EAASgD,MAAMlC,IAAImC,CAAI,GAEhC,CACEsN,QAAS,CAAC,CAACvQ,GAAY,CAAC,CAACb,GAAmB,CAAC,CAAC8D,EAC/C,EAdW8W,EAAAA,GAAAA,kBAgCT,SAASC,GACdha,EACAiD,EACAnD,EACS,CAET,IAAMma,EAAmB,CAAC,EAAEja,GAAYA,EAASgD,OAC3C,CAAElJ,KAAAA,CAAI,EAAKigB,GACfE,EAAmBja,EAAWtO,OAC9BuR,CAAI,EASN,OALIgX,IAAqB,IAKrBngB,GAAAA,MAAAA,EAAM4M,SAAS5H,GAAUM,aACpB,GAIF,CAAC,EAAEU,IAAiBhG,GAAAA,YAAAA,EAAM4M,SAAS5G,KAvB5Bka,EAAAA,GAAAA,oBA6DT,SAASE,GACdla,EACA,CACA,IAAMyI,EAAgB5J,EAAgB,EAChCM,EAAkBa,GAAAA,YAAAA,EAAUpM,aAC5BgI,EAAcsH,GAAc,EAElC,OAAO6N,GACL,MAAOoJ,GAED,CACJ/pB,EAAU4P,EAAU,sBAAsB,EAC1C5P,EAAU4P,EAASgD,MAAO,iCAAiC,EAC3D,MAAMhD,EAASgD,MAAMoX,OAAOD,CAAkB,GAEhD,CACEvH,UAAW,IACTnT,EACE7D,EACAuD,EACAsJ,CAAa,EAElB,EAtBWyR,EAAAA,GAAAA,wBA2DT,SAASG,GACdra,EACA,CACA,IAAMyI,EAAgB5J,EAAgB,EAChCM,EAAkBa,GAAAA,YAAAA,EAAUpM,aAC5BgI,EAAcsH,GAAc,EAElC,OAAO6N,GACL,MAAO5P,GAGD,CACJ/Q,EAAU4P,EAAU,sBAAsB,EAC1C5P,EAAU4P,EAASgD,MAAO,iCAAiC,EAC3D,MAAMhD,EAASgD,MAAMsX,MAAMnZ,EAAO8B,KAAa9B,EAAOtH,OAAO,GAE/D,CACE+Y,UAAW,IACTnT,EACE7D,EACAuD,EACAsJ,CAAa,EAElB,EAvBW4R,EAAAA,GAAAA,gBA0DT,SAASE,GACdva,EACA,CACA,IAAMyI,EAAgB5J,EAAgB,EAChCM,EAAkBa,GAAAA,YAAAA,EAAUpM,aAC5BgI,EAAcsH,GAAc,EAClC,OAAO6N,GACL,MAAO5P,GAGD,CACJ/Q,EAAU4P,EAAU,sBAAsB,EAC1C5P,EAAU4P,EAASgD,MAAO,iCAAiC,EAC3D,MAAMhD,EAASgD,MAAMwX,OAAOrZ,EAAO8B,KAAa9B,EAAOtH,OAAO,GAEhE,CACE+Y,UAAW,IACTnT,EACE7D,EACAuD,EACAsJ,CAAa,EAElB,EAtBW8R,EAAAA,GAAAA","sourcesContent":["import { ChainId } from \"@thirdweb-dev/sdk/dist/browser\";\nimport { Signer, ethers, utils } from \"ethers\";\nimport invariant from \"tiny-invariant\";\nimport { Chain, Connector, ConnectorData, normalizeChainId } from \"wagmi\";\n\nconst CHAIN_ID_TO_GNOSIS_SERVER_URL = {\n  [ChainId.Mainnet]: \"https://safe-transaction.mainnet.gnosis.io\",\n  [ChainId.Avalanche]: \"https://safe-transaction.avalanche.gnosis.io\",\n  [ChainId.Polygon]: \"https://safe-transaction.polygon.gnosis.io\",\n  [ChainId.Goerli]: \"https://safe-transaction.goerli.gnosis.io\",\n  [ChainId.Rinkeby]: \"https://safe-transaction.rinkeby.gnosis.io\",\n};\n\nexport interface GnosisConnectorArguments {\n  safeAddress: string;\n  safeChainId: number;\n}\n\nconst __IS_SERVER__ = typeof window === \"undefined\";\n\nexport class GnosisSafeConnector extends Connector {\n  id = \"gnosis\";\n  ready = __IS_SERVER__;\n  name = \"Gnosis Safe\";\n  // config\n  public previousConnector?: Connector<any>;\n  private config?: GnosisConnectorArguments;\n  private safeSigner?: Signer;\n\n  constructor(config: { chains?: Chain[] }) {\n    // filter out any chains that gnosis doesnt support before passing to connector\n    config.chains = config.chains?.filter(\n      (c) => c.id in CHAIN_ID_TO_GNOSIS_SERVER_URL,\n    );\n    super({ ...config, options: undefined });\n\n    if (!__IS_SERVER__) {\n      this.ready = true;\n    }\n  }\n\n  async connect(): Promise<ConnectorData<any>> {\n    this.safeSigner = await this.createSafeSigner();\n    const account = await this.getAccount();\n    const provider = await this.getProvider();\n    const id = await this.getChainId();\n    return {\n      account,\n      provider,\n      chain: { id, unsupported: this.isChainUnsupported(id) },\n    };\n  }\n\n  private async createSafeSigner() {\n    const signer = await this.previousConnector?.getSigner();\n    const safeAddress = this.config?.safeAddress;\n    const safeChainId = this.config\n      ?.safeChainId as keyof typeof CHAIN_ID_TO_GNOSIS_SERVER_URL;\n    invariant(\n      signer,\n      \"cannot create Gnosis Safe signer without a personal signer\",\n    );\n    const signerChainId = await signer.getChainId();\n    invariant(\n      signerChainId === safeChainId,\n      \"chainId of personal signer has to match safe chainId\",\n    );\n    invariant(\n      safeAddress,\n      \"safeConfig.safeAddress is required, did you forget to call setSafeConfig?\",\n    );\n    invariant(\n      safeChainId,\n      \"safeConfig.safeChainId is required, did you forget to call setSafeConfig?\",\n    );\n    const serverUrl = CHAIN_ID_TO_GNOSIS_SERVER_URL[safeChainId];\n    invariant(serverUrl, \"Chain not supported\");\n\n    const [safeEthersAdapters, safeCoreSdk, safeEthersLib] = await Promise.all([\n      import(\"@gnosis.pm/safe-ethers-adapters\"),\n      import(\"@gnosis.pm/safe-core-sdk\"),\n      import(\"@gnosis.pm/safe-ethers-lib\"),\n    ]);\n\n    // @ts-expect-error - this is a hack to get the default export\n    const ethAdapter = new safeEthersLib.default.default({ ethers, signer });\n    // @ts-expect-error - this is a hack to get the default export\n    const safe = await safeCoreSdk.default.default.create({\n      ethAdapter,\n      safeAddress,\n    });\n    const service = new safeEthersAdapters.SafeService(serverUrl);\n    return new safeEthersAdapters.SafeEthersSigner(\n      safe,\n      service,\n      signer.provider,\n    );\n  }\n\n  async disconnect(): Promise<void> {\n    this.config = undefined;\n    this.safeSigner = undefined;\n    this.previousConnector = undefined;\n    return undefined;\n  }\n\n  async getAccount(): Promise<string> {\n    const signer = await this.getSigner();\n    return await signer.getAddress();\n  }\n\n  async getChainId(): Promise<number> {\n    return (await this.getSigner()).getChainId();\n  }\n\n  async getProvider() {\n    return (await this.getSigner()).provider;\n  }\n\n  async getSigner(): Promise<Signer> {\n    if (!this.safeSigner) {\n      this.safeSigner = await this.createSafeSigner();\n    }\n    return this.safeSigner;\n  }\n\n  async isAuthorized(): Promise<boolean> {\n    try {\n      const account = await this.getAccount();\n      return !!account;\n    } catch {\n      return false;\n    }\n  }\n\n  protected onAccountsChanged(accounts: string[]) {\n    if (accounts.length === 0) {\n      this.emit(\"disconnect\");\n    } else {\n      this.emit(\"change\", { account: utils.getAddress(accounts[0]) });\n    }\n  }\n\n  protected override isChainUnsupported(chainId: number) {\n    return this.config?.safeChainId\n      ? chainId === this.config.safeChainId\n      : false;\n  }\n\n  protected onChainChanged(chainId: string | number) {\n    const id = normalizeChainId(chainId);\n    const unsupported = this.isChainUnsupported(id);\n    this.emit(\"change\", { chain: { id, unsupported } });\n  }\n\n  protected onDisconnect() {\n    this.emit(\"disconnect\");\n  }\n\n  public setConfiguration(\n    connector: Connector<any>,\n    config: GnosisConnectorArguments,\n  ) {\n    this.previousConnector = connector;\n    this.config = config;\n  }\n}\n","import { providers, utils } from \"ethers\";\nimport type {\n  LoginWithMagicLinkConfiguration,\n  Magic as MagicInstance,\n  MagicSDKAdditionalConfiguration,\n} from \"magic-sdk\";\nimport invariant from \"tiny-invariant\";\nimport { Chain, Connector, normalizeChainId } from \"wagmi\";\n\nexport interface MagicConnectorArguments\n  extends MagicSDKAdditionalConfiguration {\n  apiKey: string;\n  doNotAutoConnect?: boolean;\n  rpcUrls: Record<number, string>;\n}\n\nconst __IS_SERVER__ = typeof window === \"undefined\";\n\nconst LOCAL_STORAGE_KEY = \"--magic-link:configuration\";\n\nexport class MagicConnector extends Connector {\n  readonly id = \"magic\";\n  readonly name = \"Magic\";\n  readonly ready = __IS_SERVER__;\n\n  override options: MagicConnectorArguments;\n  private configuration?: LoginWithMagicLinkConfiguration;\n  public magic?: MagicInstance;\n\n  getConfiguration() {\n    if (__IS_SERVER__) {\n      return undefined;\n    }\n\n    const config = window.localStorage.getItem(LOCAL_STORAGE_KEY);\n    if (config) {\n      this.configuration = JSON.parse(config);\n    }\n    return this.configuration;\n  }\n\n  constructor(config: { chains?: Chain[]; options: MagicConnectorArguments }) {\n    super({ ...config, options: config?.options });\n    this.options = config.options;\n\n    if (!__IS_SERVER__) {\n      this.ready = true;\n      if (this.options.doNotAutoConnect || !this.getConfiguration()) {\n        return;\n      }\n      this.connect(true);\n    }\n  }\n\n  async connect(isAutoConnect?: true) {\n    const { apiKey, doNotAutoConnect, rpcUrls, ...options } = this.options;\n    const configuration = this.getConfiguration();\n\n    try {\n      invariant(\n        configuration,\n        \"did you forget to set the configuration via: setConfiguration()?\",\n      );\n      if (isAutoConnect) {\n        configuration.showUI = false;\n      }\n\n      return import(\"magic-sdk\").then(async (m) => {\n        this.magic = new m.Magic(apiKey, options);\n\n        await this.magic.auth.loginWithMagicLink(configuration);\n        const provider = this.getProvider();\n        if (provider.on) {\n          provider.on(\"accountsChanged\", this.onAccountsChanged);\n          provider.on(\"chainChanged\", this.onChainChanged);\n          provider.on(\"disconnect\", this.onDisconnect);\n        }\n        const account = await this.getAccount();\n        const id = await this.getChainId();\n        return {\n          account,\n          provider,\n          chain: { id, unsupported: this.isChainUnsupported(id) },\n        };\n      });\n    } catch (e) {\n      if (!isAutoConnect) {\n        throw e;\n      }\n      return {\n        account: undefined,\n        provider: undefined,\n        chain: undefined,\n      };\n    }\n  }\n  async disconnect() {\n    const provider = this.getProvider();\n    if (provider?.removeListener) {\n      provider.removeListener(\"accountsChanged\", this.onAccountsChanged);\n      provider.removeListener(\"chainChanged\", this.onChainChanged);\n      provider.removeListener(\"disconnect\", this.onDisconnect);\n    }\n    this.setConfiguration(undefined);\n  }\n\n  override async switchChain(chainId: number) {\n    invariant(!this.isChainUnsupported(chainId), \"chain is not supported\");\n    const provider = this.getProvider();\n    if (provider?.removeListener) {\n      provider.removeListener(\"accountsChanged\", this.onAccountsChanged);\n      provider.removeListener(\"chainChanged\", this.onChainChanged);\n      provider.removeListener(\"disconnect\", this.onDisconnect);\n    }\n\n    this.options.network = {\n      chainId,\n      rpcUrl: this.options.rpcUrls[chainId],\n    };\n    await this.connect();\n    this.onChainChanged(chainId);\n    return this.chains.find((c) => c.id === chainId);\n  }\n\n  async getAccount() {\n    const signer = await this.getSigner();\n    return await signer.getAddress();\n  }\n  async getChainId() {\n    const signer = await this.getSigner();\n    return await signer.getChainId();\n  }\n  getProvider() {\n    invariant(this.magic, \"connector is not initialized\");\n    return new providers.Web3Provider(\n      this.magic.rpcProvider as unknown as providers.ExternalProvider,\n    );\n  }\n  async getSigner() {\n    if (!this.magic) {\n      await this.connect();\n    }\n    return this.getProvider().getSigner();\n  }\n  async isAuthorized() {\n    try {\n      const account = await this.getAccount();\n      return !!account;\n    } catch {\n      return false;\n    }\n  }\n\n  protected onAccountsChanged(accounts: string[]) {\n    if (accounts.length === 0) {\n      this.emit(\"disconnect\");\n    } else {\n      this.emit(\"change\", { account: utils.getAddress(accounts[0]) });\n    }\n  }\n\n  protected override isChainUnsupported(chainId: number) {\n    return !this.chains.some((x) => x.id === chainId);\n  }\n\n  protected onChainChanged(chainId: string | number) {\n    const id = normalizeChainId(chainId);\n    const unsupported = this.isChainUnsupported(id);\n    this.emit(\"change\", { chain: { id, unsupported } });\n  }\n\n  protected onDisconnect() {\n    this.emit(\"disconnect\");\n  }\n\n  public setConfiguration(configuration?: LoginWithMagicLinkConfiguration) {\n    if (configuration) {\n      this.configuration = configuration;\n      window.localStorage.setItem(\n        LOCAL_STORAGE_KEY,\n        JSON.stringify(configuration),\n      );\n    } else {\n      this.configuration = undefined;\n      window.localStorage.removeItem(LOCAL_STORAGE_KEY);\n    }\n  }\n}\n","import { NATIVE_TOKENS } from \"@thirdweb-dev/sdk\";\nimport { ChainId } from \"@thirdweb-dev/sdk/dist/browser\";\nimport type { Chain as WagmiChain } from \"wagmi\";\n\nexport type Chain = WagmiChain;\nconst chain: Record<string, Chain> = {\n  mainnet: {\n    id: ChainId.Mainnet,\n    name: \"Ethereum Mainnet\",\n    nativeCurrency: NATIVE_TOKENS[ChainId.Mainnet],\n    rpcUrls: [\"https://mainnet.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161\"],\n    blockExplorers: [\n      {\n        name: \"Etherscan\",\n        url: \"https://etherscan.io\",\n      },\n    ],\n  },\n  rinkeby: {\n    id: ChainId.Rinkeby,\n    name: \"Rinkeby\",\n    nativeCurrency: NATIVE_TOKENS[ChainId.Rinkeby],\n    rpcUrls: [\"https://rinkeby.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161\"],\n    blockExplorers: [\n      {\n        name: \"Etherscan\",\n        url: \"https://rinkeby.etherscan.io\",\n      },\n    ],\n    testnet: true,\n  },\n  goerli: {\n    id: ChainId.Goerli,\n    name: \"Goerli\",\n    nativeCurrency: NATIVE_TOKENS[ChainId.Goerli],\n    rpcUrls: [\"https://goerli.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161\"],\n    blockExplorers: [\n      {\n        name: \"Etherscan\",\n        url: \"https://goerli.etherscan.io\",\n      },\n    ],\n    testnet: true,\n  },\n  polygonMainnet: {\n    id: ChainId.Polygon,\n    name: \"Polygon Mainnet\",\n    nativeCurrency: NATIVE_TOKENS[ChainId.Polygon],\n    rpcUrls: [\n      \"https://polygon-rpc.com\",\n      \"https://rpc-mainnet.matic.network\",\n      \"https://matic-mainnet.chainstacklabs.com\",\n      \"https://rpc-mainnet.maticvigil.com\",\n      \"https://rpc-mainnet.matic.quiknode.pro\",\n      \"https://matic-mainnet-full-rpc.bwarelabs.com\",\n    ],\n    blockExplorers: [\n      {\n        name: \"Polygonscan\",\n        url: \"https://polygonscan.com\",\n      },\n    ],\n  },\n  polygonTestnetMumbai: {\n    id: ChainId.Mumbai,\n    name: \"Mumbai\",\n    nativeCurrency: NATIVE_TOKENS[ChainId.Mumbai],\n    rpcUrls: [\n      \"https://matic-mumbai.chainstacklabs.com\",\n      \"https://rpc-mumbai.maticvigil.com\",\n      \"https://matic-testnet-archive-rpc.bwarelabs.com\",\n    ],\n    blockExplorers: [\n      {\n        name: \"PolygonScan\",\n        url: \"https://mumbai.polygonscan.com\",\n      },\n    ],\n    testnet: true,\n  },\n  avalanche: {\n    id: ChainId.Avalanche,\n    name: \"Avalanche\",\n    nativeCurrency: NATIVE_TOKENS[ChainId.Avalanche],\n    rpcUrls: [\n      \"https://api.avax.network/ext/bc/C/rpc\",\n      \"https://rpc.ankr.com/avalanche\",\n    ],\n    blockExplorers: [\n      {\n        name: \"SnowTrace\",\n        url: \"https://snowtrace.io/\",\n      },\n    ],\n    testnet: false,\n  },\n  avalancheFujiTestnet: {\n    id: ChainId.AvalancheFujiTestnet,\n    name: \"Avalanche Fuji Testnet\",\n    nativeCurrency: NATIVE_TOKENS[ChainId.AvalancheFujiTestnet],\n    rpcUrls: [\"https://api.avax-test.network/ext/bc/C/rpc\"],\n    blockExplorers: [\n      {\n        name: \"SnowTrace\",\n        url: \"https://testnet.snowtrace.io/\",\n      },\n    ],\n    testnet: true,\n  },\n  fantom: {\n    id: ChainId.Fantom,\n    name: \"Fantom Opera\",\n    nativeCurrency: NATIVE_TOKENS[ChainId.Fantom],\n    rpcUrls: [\"https://rpc.ftm.tools\"],\n    blockExplorers: [\n      {\n        name: \"FTMscan\",\n        url: \"https://ftmscan.com/\",\n      },\n    ],\n    testnet: false,\n  },\n  fantomTestnet: {\n    id: ChainId.FantomTestnet,\n    name: \"Fantom Testnet\",\n    nativeCurrency: NATIVE_TOKENS[ChainId.FantomTestnet],\n    rpcUrls: [\"https://rpc.testnet.fantom.network\"],\n    blockExplorers: [\n      {\n        name: \"FTMscan\",\n        url: \"https://testnet.ftmscan.com/\",\n      },\n    ],\n    testnet: false,\n  },\n  optimism: {\n    id: ChainId.Optimism,\n    name: \"Optimism\",\n    nativeCurrency: NATIVE_TOKENS[ChainId.Optimism],\n    rpcUrls: [\"https://mainnet.optimism.io\"],\n    blockExplorers: [\n      {\n        name: \"Etherscan\",\n        url: \"https://optimistic.etherscan.io/\",\n      },\n    ],\n    testnet: false,\n  },\n  optimismTestnet: {\n    id: ChainId.OptimismTestnet,\n    name: \"Optimism Kovan\",\n    nativeCurrency: NATIVE_TOKENS[ChainId.OptimismTestnet],\n    rpcUrls: [\"https://kovan.optimism.io\"],\n    blockExplorers: [\n      {\n        name: \"Etherscan\",\n        url: \"https://kovan-optimistic.etherscan.io/\",\n      },\n    ],\n    testnet: true,\n  },\n  arbitrum: {\n    id: ChainId.Arbitrum,\n    name: \"Arbitrum One\",\n    nativeCurrency: NATIVE_TOKENS[ChainId.Arbitrum],\n    rpcUrls: [\"https://arb1.arbitrum.io/rpc\"],\n    blockExplorers: [\n      {\n        name: \"Arbiscan\",\n        url: \"https://arbiscan.io/\",\n      },\n    ],\n    testnet: false,\n  },\n  arbitrumTestnet: {\n    id: ChainId.ArbitrumTestnet,\n    name: \"Arbitrum Rinkeby\",\n    nativeCurrency: NATIVE_TOKENS[ChainId.ArbitrumTestnet],\n    rpcUrls: [\"https://rinkeby.arbitrum.io/rpc\"],\n    blockExplorers: [\n      {\n        name: \"Arbiscan\",\n        url: \"https://testnet.arbiscan.io/\",\n      },\n    ],\n    testnet: true,\n  },\n};\n\nexport const defaultSupportedChains = Object.values(chain) as Chain[];\n\nexport type SupportedChainId = typeof defaultSupportedChains[number][\"id\"];\n\nexport type SupportedChain = SupportedChainId | Chain;\n","import { ThirdwebAuthConfig } from \"../Provider\";\nimport {\n  Chain,\n  SupportedChainId,\n  defaultSupportedChains,\n} from \"../constants/chain\";\nimport { ChainId } from \"@thirdweb-dev/sdk/dist/browser\";\nimport React, { PropsWithChildren, createContext, useContext } from \"react\";\n\ninterface ThirdwebConfigContext {\n  rpcUrlMap: Record<SupportedChainId | number, string>;\n  supportedChains: Chain[];\n  authConfig?: ThirdwebAuthConfig;\n}\n\nexport const defaultChainRpc: Record<SupportedChainId | number, string> = {\n  [ChainId.Mainnet]: \"mainnet\",\n  [ChainId.Rinkeby]: \"rinkeby\",\n  [ChainId.Goerli]: \"goerli\",\n  [ChainId.Polygon]: \"polygon\",\n  [ChainId.Mumbai]: \"mumbai\",\n  [ChainId.Fantom]: \"fantom\",\n  [ChainId.Avalanche]: \"avalanche\",\n};\n\nexport const ThirdwebConfigContext = createContext<ThirdwebConfigContext>({\n  rpcUrlMap: defaultChainRpc,\n  supportedChains: defaultSupportedChains,\n});\n\nexport const ThirdwebConfigProvider: React.FC<\n  PropsWithChildren<{\n    value: ThirdwebConfigContext;\n  }>\n> = ({ value, children }) => (\n  <ThirdwebConfigContext.Provider value={value}>\n    {children}\n  </ThirdwebConfigContext.Provider>\n);\n\nexport function useThirdwebConfigContext() {\n  return useContext(ThirdwebConfigContext);\n}\n","import { Signer } from \"ethers\";\nimport { useEffect, useRef } from \"react\";\nimport { useAccount, useNetwork, useSigner as useWagmiSigner } from \"wagmi\";\n\n/**\n *\n * @internal\n */\nexport function useSigner() {\n  const [signer, getSigner] = useWagmiSigner();\n  const [account] = useAccount();\n  const [network] = useNetwork();\n\n  const _getSignerPromise = useRef<ReturnType<typeof getSigner> | null>(null);\n\n  const address = account.data?.address;\n  const chainId = network.data.chain?.id;\n\n  const previousAddress = usePrevious(account.data?.address);\n  const previousChainId = usePrevious(network.data?.chain?.id);\n\n  useEffect(() => {\n    if (address !== previousAddress || chainId !== previousChainId) {\n      if (!_getSignerPromise.current) {\n        return;\n      } else {\n        _getSignerPromise.current = getSigner().finally(() => {\n          _getSignerPromise.current = null;\n        });\n      }\n    }\n  }, [address, chainId, previousAddress, previousChainId]);\n\n  return Signer.isSigner(signer.data) ? signer.data : undefined;\n}\n\nfunction usePrevious<TVal>(value: TVal): TVal | undefined {\n  // The ref object is a generic container whose current property is mutable ...\n  // ... and can hold any value, similar to an instance property on a class\n  const ref = useRef<TVal>();\n  // Store current value in ref\n  useEffect(() => {\n    ref.current = value;\n  }, [value]); // Only re-run if value changes\n  // Return previous value (happens before update in useEffect above)\n  return ref.current;\n}\n","import {\n  GnosisConnectorArguments,\n  GnosisSafeConnector,\n} from \"./connectors/gnosis-safe\";\nimport { MagicConnector, MagicConnectorArguments } from \"./connectors/magic\";\nimport {\n  Chain,\n  SupportedChain,\n  defaultSupportedChains,\n} from \"./constants/chain\";\nimport {\n  ThirdwebConfigProvider,\n  defaultChainRpc,\n} from \"./contexts/thirdweb-config\";\nimport { useSigner } from \"./hooks/useSigner\";\nimport { QueryClient, QueryClientProvider } from \"@tanstack/react-query\";\nimport {\n  ChainOrRpc,\n  IStorage,\n  SDKOptions,\n  SUPPORTED_CHAIN_ID,\n  SignerOrProvider,\n  ThirdwebSDK,\n  getProviderForNetwork,\n} from \"@thirdweb-dev/sdk/dist/browser\";\nimport { SDKOptionsOutput } from \"@thirdweb-dev/sdk/dist/src/schema\";\nimport { Signer } from \"ethers\";\nimport React, { createContext, useEffect, useMemo } from \"react\";\nimport invariant from \"tiny-invariant\";\nimport {\n  WagmiProvider,\n  ProviderProps as WagmiproviderProps,\n  useProvider,\n} from \"wagmi\";\nimport { CoinbaseWalletConnector } from \"wagmi/connectors/coinbaseWallet\";\nimport { InjectedConnector } from \"wagmi/connectors/injected\";\nimport { WalletConnectConnector } from \"wagmi/connectors/walletConnect\";\n\n/**\n * @internal\n */\nexport type InjectedConnectorType =\n  | \"injected\"\n  | \"metamask\"\n  | { name: \"injected\" | \"metamask\"; options?: InjectedConnector[\"options\"] };\n\n/**\n * @internal\n */\nexport type WalletConnectConnectorType =\n  | \"walletConnect\"\n  | { name: \"walletConnect\"; options: WalletConnectConnector[\"options\"] };\n\n/**\n * @internal\n */\nexport type WalletLinkConnectorType =\n  | \"walletLink\"\n  | \"coinbase\"\n  | {\n      name: \"walletLink\" | \"coinbase\";\n      options: CoinbaseWalletConnector[\"options\"];\n    };\n\n/**\n * @internal\n */\nexport type MagicConnectorType =\n  | \"magic\"\n  | {\n      name: \"magic\";\n      options: Omit<MagicConnectorArguments, \"network\">;\n    };\n\n/**\n * @internal\n */\nexport type GnosisConnectorType =\n  | \"gnosis\"\n  | {\n      name: \"gnosis\";\n      options: GnosisConnectorArguments;\n    };\n\n/**\n * @internal\n */\nexport type WalletConnector =\n  | InjectedConnectorType\n  | WalletConnectConnectorType\n  | WalletLinkConnectorType\n  | MagicConnectorType\n  | GnosisConnectorType;\n\n/**\n * @internal\n */\nexport type ChainRpc<TSupportedChain extends SupportedChain> = Record<\n  TSupportedChain extends Chain ? TSupportedChain[\"id\"] : TSupportedChain,\n  string\n>;\n\nexport interface ThirdwebAuthConfig {\n  /**\n   * The backend URL of the authentication endoints. For example, if your endpoints are\n   * at /api/auth/login, /api/auth/logout, etc. then this should be set to \"/api/auth\".\n   */\n  authUrl: string;\n\n  /**\n   * The frontend domain used to generate the login payload.\n   * This domain should match the domain used on your auth backend.\n   */\n  domain: string;\n\n  /**\n   * The URL to redirect to after a succesful login.\n   */\n  loginRedirect?: string;\n}\n\n/**\n * the metadata to pass to wallet connection dialog (may show up during the wallet-connection process)\n * @remarks this is only used for wallet connect and wallet link, metamask does not support it\n * @public\n */\nexport interface DAppMetaData {\n  /**\n   * the name of your app\n   */\n  name: string;\n  /**\n   * optional - a description of your app\n   */\n  description?: string;\n  /**\n   * optional - a url that points to a logo (or favicon) of your app\n   */\n  logoUrl?: string;\n  /**\n   * optional - the url where your app is hosted\n   */\n  url?: string;\n  /**\n   * optional - whether to show the connect dialog in darkmode or not\n   */\n  isDarkMode?: boolean;\n}\n\n/**\n * The possible props for the ThirdwebProvider.\n */\nexport interface ThirdwebProviderProps<\n  TSupportedChain extends SupportedChain = SupportedChain,\n> {\n  /**\n   * The {@link SDKOptions | Thirdweb SDK Options} to pass to the thirdweb SDK\n   * comes with sensible defaults\n   */\n  sdkOptions?: SDKOptions;\n  /**\n   * An array of chainIds or {@link Chain} objects that the dApp supports\n   * If not provided, all chains supported by the SDK will be supported by default\n   */\n  supportedChains?: TSupportedChain[];\n  /**\n   * An array of connector types (strings) or wallet connector objects that the dApp supports\n   * If not provided, will default to metamask (injected), wallet connect and walletlink (coinbase wallet) with sensible defaults\n   */\n  walletConnectors?: WalletConnector[];\n  /**\n   * A partial map of chainIds to rpc urls to use for certain chains\n   * If not provided, will default to the rpcUrls of the chain objects for the supported chains\n   */\n  chainRpc?: Partial<ChainRpc<TSupportedChain>>;\n  /**\n   * Metadata to pass to wallet connect and walletlink wallet connect. (Used to show *which* dApp is being connected to in mobile wallets that support it)\n   * Defaults to just the name being passed as `thirdweb powered dApp`.\n   */\n  dAppMeta?: DAppMetaData;\n  /**\n   * The chainId that your dApp is running on.\n   * While this *can* be `undefined` it is required to be passed. Passing `undefined` will cause no SDK to be instantiated.\n   * When passing a chainId, it **must** be part of the `supportedChains` array.\n   */\n  desiredChainId: TSupportedChain extends Chain\n    ? TSupportedChain[\"id\"]\n    : TSupportedChain | undefined;\n\n  /**\n   * The configuration used for thirdweb auth usage. Enables users to login\n   * to backends with their wallet.\n   * @beta\n   */\n  authConfig?: ThirdwebAuthConfig;\n\n  /**\n   * The storage interface to use with the sdk.\n   */\n  storageInterface?: IStorage;\n\n  /**\n   * The react-query client to use. (Defaults to a default client.)\n   * @beta\n   */\n  queryClient?: QueryClient;\n\n  /**\n   * Whether or not to attempt auto-connect to a wallet.\n   */\n  autoConnect?: boolean;\n}\n\n// SDK handles this under the hood for us\n\nconst defaultdAppMeta: DAppMetaData = {\n  name: \"thirdweb powered dApp\",\n};\n\nconst defaultWalletConnectors: Required<\n  ThirdwebProviderProps[\"walletConnectors\"]\n> = [\"metamask\", \"walletConnect\", \"walletLink\"];\n\n/**\n *\n * The `<ThirdwebProvider />` component lets you control what networks you want users to connect to, what types of wallets can connect to your app, and the settings for the [Typescript SDK](https://docs.thirdweb.com/typescript).\n *\n * @example\n * You can wrap your application with the provider as follows:\n *\n * ```jsx title=\"App.jsx\"\n * import { ThirdwebProvider, ChainId } from \"@thirdweb-dev/react\";\n *\n * const App = () => {\n *   return (\n *     <ThirdwebProvider desiredChainId={ChainId.Mainnet}>\n *       <YourApp />\n *     </ThirdwebProvider>\n *   );\n * };\n * ```\n *\n * @public\n *\n */\nexport const ThirdwebProvider = <\n  TSupportedChain extends SupportedChain = SupportedChain,\n>({\n  sdkOptions,\n  chainRpc = defaultChainRpc,\n  supportedChains = defaultSupportedChains.map(\n    (c) => c.id,\n  ) as TSupportedChain[],\n  walletConnectors = defaultWalletConnectors,\n  dAppMeta = defaultdAppMeta,\n  desiredChainId,\n  authConfig,\n  storageInterface,\n  queryClient,\n  autoConnect = true,\n  children,\n}: React.PropsWithChildren<ThirdwebProviderProps<TSupportedChain>>) => {\n  // construct the wagmi options\n\n  const _supporrtedChains = useMemo(() => {\n    return supportedChains\n      .map((c) => {\n        if (typeof c === \"number\") {\n          return defaultSupportedChains.find((sc) => sc.id === c);\n        }\n        return c as Chain;\n      })\n      .filter((c) => c !== undefined) as Chain[];\n  }, [supportedChains]);\n\n  const _rpcUrlMap = useMemo(() => {\n    return _supporrtedChains.reduce((prev, curr) => {\n      prev[curr.id] =\n        curr.id in chainRpc\n          ? (getProviderForNetwork(\n              chainRpc[curr.id as keyof ChainRpc<TSupportedChain>] ||\n                curr.rpcUrls[0],\n            ) as string)\n          : curr.rpcUrls[0];\n      return prev;\n    }, {} as Record<number, string>);\n  }, [chainRpc, _supporrtedChains]);\n\n  // Remove trailing slash from URL if present\n  const _authConfig = authConfig\n    ? {\n        ...authConfig,\n        authUrl: authConfig.authUrl.replace(/\\/$/, \"\"),\n      }\n    : undefined;\n\n  const wagmiProps: WagmiproviderProps = useMemo(() => {\n    const walletConnectClientMeta = {\n      name: dAppMeta.name,\n      url: dAppMeta.url || \"\",\n      icons: [dAppMeta.logoUrl || \"\"],\n      description: dAppMeta.description || \"\",\n    };\n\n    const walletLinkClientMeta = {\n      appName: dAppMeta.name,\n      appLogoUrl: dAppMeta.logoUrl,\n      darkMode: dAppMeta.isDarkMode,\n    };\n\n    return {\n      autoConnect,\n      connectorStorageKey: \"tw:provider:connectors\",\n      connectors: ({ chainId }: { chainId?: number }) => {\n        return walletConnectors\n          .map((connector) => {\n            // injected connector\n            if (\n              (typeof connector === \"string\" &&\n                (connector === \"injected\" || connector === \"metamask\")) ||\n              (typeof connector === \"object\" &&\n                (connector.name === \"injected\" ||\n                  connector.name === \"metamask\"))\n            ) {\n              return new InjectedConnector({\n                options:\n                  typeof connector === \"string\"\n                    ? { shimDisconnect: true, shimChainChangedDisconnect: true }\n                    : connector.options,\n                chains: _supporrtedChains,\n              });\n            }\n            if (\n              (typeof connector === \"string\" &&\n                connector === \"walletConnect\") ||\n              (typeof connector === \"object\" &&\n                connector.name === \"walletConnect\")\n            ) {\n              return new WalletConnectConnector({\n                options:\n                  typeof connector === \"string\"\n                    ? {\n                        chainId,\n                        rpc: _rpcUrlMap,\n                        clientMeta: walletConnectClientMeta,\n                        qrcode: true,\n                      }\n                    : {\n                        chainId,\n                        rpc: _rpcUrlMap,\n                        clientMeta: walletConnectClientMeta,\n                        qrcode: true,\n                        ...connector.options,\n                      },\n                chains: _supporrtedChains,\n              });\n            }\n            if (\n              (typeof connector === \"string\" &&\n                (connector === \"coinbase\" || connector === \"walletLink\")) ||\n              (typeof connector === \"object\" &&\n                (connector.name === \"coinbase\" ||\n                  connector.name === \"walletLink\"))\n            ) {\n              const jsonRpcUrl = _rpcUrlMap[chainId || desiredChainId || 1];\n              return new CoinbaseWalletConnector({\n                chains: _supporrtedChains,\n                options:\n                  typeof connector === \"string\"\n                    ? {\n                        ...walletLinkClientMeta,\n                        jsonRpcUrl,\n                      }\n                    : {\n                        ...walletLinkClientMeta,\n                        jsonRpcUrl,\n                        ...connector.options,\n                      },\n              });\n            }\n            if (typeof connector === \"object\" && connector.name === \"magic\") {\n              const jsonRpcUrl = _rpcUrlMap[chainId || desiredChainId || 1];\n              return new MagicConnector({\n                chains: _supporrtedChains,\n                options: {\n                  ...connector.options,\n                  network: { rpcUrl: jsonRpcUrl, chainId: desiredChainId || 1 },\n                  rpcUrls: _rpcUrlMap,\n                },\n              });\n            }\n            if (\n              (typeof connector === \"string\" && connector === \"gnosis\") ||\n              (typeof connector === \"object\" && connector.name === \"gnosis\")\n            ) {\n              return new GnosisSafeConnector({\n                chains: _supporrtedChains,\n              });\n            }\n            return null;\n          })\n          .filter((c) => c !== null);\n      },\n    } as WagmiproviderProps;\n  }, [walletConnectors, _supporrtedChains, dAppMeta]);\n\n  const readonlySettings: SDKOptionsOutput[\"readonlySettings\"] = useMemo(() => {\n    if (\n      sdkOptions?.readonlySettings?.rpcUrl &&\n      sdkOptions?.readonlySettings?.chainId\n    ) {\n      return sdkOptions.readonlySettings;\n    }\n    if (!desiredChainId) {\n      return undefined;\n    }\n    let rpcUrl = _rpcUrlMap[desiredChainId as keyof typeof _rpcUrlMap];\n    try {\n      rpcUrl = getProviderForNetwork(rpcUrl) as string;\n    } catch (e) {\n      console.error(\n        `failed to configure rpc url for chain: \"${desiredChainId}\". Did you forget to pass \"desiredChainId\" to the <ThirdwebProvider /> component?`,\n      );\n      // cannot set readonly without a valid rpc url\n      return undefined;\n    }\n    return {\n      chainId: desiredChainId,\n      rpcUrl,\n    };\n  }, [_rpcUrlMap, desiredChainId]);\n\n  const sdkOptionsWithDefaults = useMemo(() => {\n    const opts: SDKOptions = sdkOptions;\n    return {\n      ...opts,\n      readonlySettings,\n    };\n  }, [sdkOptions, readonlySettings]);\n\n  return (\n    <ThirdwebConfigProvider\n      value={{\n        rpcUrlMap: _rpcUrlMap,\n        supportedChains: _supporrtedChains,\n        authConfig: _authConfig,\n      }}\n    >\n      <WagmiProvider {...wagmiProps}>\n        <ThirdwebSDKProviderWagmiWrapper\n          queryClient={queryClient}\n          desiredChainId={desiredChainId}\n          sdkOptions={sdkOptionsWithDefaults}\n          storageInterface={storageInterface}\n        >\n          {children}\n        </ThirdwebSDKProviderWagmiWrapper>\n      </WagmiProvider>\n    </ThirdwebConfigProvider>\n  );\n};\n\nexport interface ThirdwebSDKProviderWagmiWrapper\n  extends Pick<\n    ThirdwebProviderProps,\n    \"desiredChainId\" | \"sdkOptions\" | \"storageInterface\"\n  > {\n  signer?: Signer;\n  provider: ChainOrRpc | SignerOrProvider;\n  queryClient?: QueryClient;\n}\n\nconst ThirdwebSDKProviderWagmiWrapper: React.FC<\n  React.PropsWithChildren<\n    Omit<ThirdwebSDKProviderWagmiWrapper, \"signer\" | \"provider\">\n  >\n> = ({ children, ...props }) => {\n  const provider = useProvider();\n  const signer = useSigner();\n  return (\n    <ThirdwebSDKProvider signer={signer} provider={provider} {...props}>\n      {children}\n    </ThirdwebSDKProvider>\n  );\n};\n\ninterface SDKContext {\n  sdk?: ThirdwebSDK;\n  _inProvider?: true;\n  desiredChainId: number;\n}\n\nconst ThirdwebSDKContext = createContext<SDKContext>({ desiredChainId: -1 });\n\nexport interface ThirdwebSDKProviderProps\n  extends Omit<ThirdwebSDKProviderWagmiWrapper, \"queryClient\"> {\n  queryClient?: QueryClient;\n}\n\n/**\n * A barebones wrapper around the Thirdweb SDK.\n *\n * You can use this in order to be able to pass a provider & signer directly to the SDK.\n *\n * @remarks Utilizing this provider will mean hooks for wallet management are not available, if you need those please use the {@link ThirdwebProvider} instead.\n *\n * @beta\n */\nexport const ThirdwebSDKProvider: React.FC<\n  React.PropsWithChildren<ThirdwebSDKProviderProps>\n> = ({\n  sdkOptions,\n  desiredChainId,\n  storageInterface,\n  provider,\n  signer,\n  queryClient,\n  children,\n}) => {\n  const queryClientWithDefault: QueryClient = useMemo(() => {\n    return queryClient ? queryClient : new QueryClient();\n  }, [queryClient]);\n\n  const sdk = useMemo(() => {\n    if (!desiredChainId || typeof window === \"undefined\") {\n      return undefined;\n    }\n    const _sdk = new ThirdwebSDK(provider, sdkOptions, storageInterface);\n    (_sdk as any)._chainId = desiredChainId;\n    return _sdk;\n  }, [provider, sdkOptions, storageInterface, desiredChainId]);\n\n  useEffect(() => {\n    if (signer && sdk && (sdk as any)._chainId === desiredChainId) {\n      sdk.updateSignerOrProvider(signer);\n    }\n  }, [signer, sdk, desiredChainId]);\n\n  const ctxValue = useMemo(\n    () => ({\n      sdk,\n      desiredChainId: desiredChainId || -1,\n      _inProvider: true as const,\n    }),\n    [sdk],\n  );\n\n  return (\n    <QueryClientProvider client={queryClientWithDefault}>\n      <ThirdwebSDKContext.Provider value={ctxValue}>\n        {children}\n      </ThirdwebSDKContext.Provider>\n    </QueryClientProvider>\n  );\n};\n\n/**\n * @internal\n */\nfunction useSDKContext(): SDKContext {\n  const ctx = React.useContext(ThirdwebSDKContext);\n  invariant(\n    ctx._inProvider,\n    \"useSDK must be called from within a ThirdwebProvider, did you forget to wrap your app in a <ThirdwebProvider />?\",\n  );\n  return ctx;\n}\n\n/**\n *\n * @returns {@link ThirdwebSDK}\n * Access the instance of the thirdweb SDK created by the ThirdwebProvider\n * to call methods using the connected wallet on the desiredChainId.\n * @example\n * ```javascript\n * const sdk = useSDK();\n * ```\n */\nexport function useSDK(): ThirdwebSDK | undefined {\n  const { sdk } = useSDKContext();\n  return sdk;\n}\n\n/**\n * @internal\n */\nexport function useDesiredChainId(): number {\n  const { desiredChainId } = useSDKContext();\n  return desiredChainId;\n}\n\n/**\n * @internal\n */\nexport function useActiveChainId(): SUPPORTED_CHAIN_ID | undefined {\n  const sdk = useSDK();\n  return (sdk as any)?._chainId;\n}\n","import { SupportedChainId } from \"../constants/chain\";\nimport { ContractAddress, RequiredParam, WalletAddress } from \"../types\";\nimport { QueryClient, QueryKey } from \"@tanstack/react-query\";\nimport type {\n  MarketplaceFilter,\n  QueryAllParams,\n  SUPPORTED_CHAIN_ID,\n} from \"@thirdweb-dev/sdk/dist/browser\";\nimport { BigNumberish, constants } from \"ethers\";\n\nconst TW_CACHE_KEY_PREFIX = \"tw-cache\";\n\n/**\n * @internal\n */\nfunction createCachekey(input: QueryKey): QueryKey {\n  if (input[0] === TW_CACHE_KEY_PREFIX) {\n    return input;\n  }\n  return [TW_CACHE_KEY_PREFIX, ...input];\n}\n\n/**\n * @internal\n */\nexport function createContractCacheKey(\n  contractAddress: string = constants.AddressZero,\n  input: QueryKey = [],\n): QueryKey {\n  return createCachekey([\"contract\", contractAddress, ...input]);\n}\n\n/**\n @internal\n */\nexport function createCacheKeyWithNetwork(\n  input: QueryKey,\n  chainId: RequiredParam<SUPPORTED_CHAIN_ID>,\n): QueryKey {\n  return cacheKeys.network.active(chainId).concat(input);\n}\n\n/**\n * @internal\n */\nexport function invalidateContractAndBalances(\n  queryClient: QueryClient,\n  contractAddress: RequiredParam<ContractAddress>,\n  chainId: RequiredParam<SUPPORTED_CHAIN_ID>,\n): Promise<unknown> {\n  return Promise.all([\n    queryClient.invalidateQueries(\n      createCacheKeyWithNetwork(\n        createContractCacheKey(contractAddress),\n        chainId,\n      ),\n    ),\n    queryClient.invalidateQueries(\n      createCacheKeyWithNetwork(createCachekey([\"balance\"]), chainId),\n    ),\n  ]);\n}\n\n/**\n @internal\n */\nexport const cacheKeys = {\n  auth: {\n    user: () => createCachekey([\"user\"]),\n  },\n  network: {\n    active: (chainId: RequiredParam<SUPPORTED_CHAIN_ID>) =>\n      createCachekey([\"chainId\", chainId]),\n  },\n  wallet: {\n    balance: (\n      chainId: SupportedChainId,\n      walletAddress: RequiredParam<WalletAddress>,\n      tokenAddress?: ContractAddress,\n    ) =>\n      createCacheKeyWithNetwork(\n        createCachekey([\"balance\", { walletAddress, tokenAddress }]),\n        chainId,\n      ),\n  },\n  contract: {\n    type: (contractAddress: RequiredParam<ContractAddress>) =>\n      createContractCacheKey(contractAddress, [\"contract-type\"]),\n    compilerMetadata: (contractAddress: RequiredParam<ContractAddress>) =>\n      createContractCacheKey(contractAddress, [\"publish-metadata\"]),\n    typeAndCompilerMetadata: (\n      contractAddress: RequiredParam<ContractAddress>,\n    ) =>\n      createContractCacheKey(contractAddress, [\"contract-type-and-metadata\"]),\n    metadata: (contractAddress: RequiredParam<ContractAddress>) =>\n      createContractCacheKey(contractAddress, [\"metadata\"]),\n    extractFunctions: (contractAddress: RequiredParam<ContractAddress>) =>\n      createContractCacheKey(contractAddress, [\"extractFunctions\"]),\n    call: (\n      contractAddress: RequiredParam<ContractAddress>,\n      functionName: RequiredParam<string>,\n      args: unknown[],\n    ) => createContractCacheKey(contractAddress, [\"call\", functionName, args]),\n\n    events: {\n      getEvents: (\n        contractAddress: RequiredParam<ContractAddress>,\n        eventName: string,\n      ) =>\n        createContractCacheKey(contractAddress, [\n          \"events\",\n          \"getEvents\",\n          { eventName },\n        ]),\n      getAllEvents: (contractAddress: RequiredParam<ContractAddress>) =>\n        createContractCacheKey(contractAddress, [\"events\", \"getAllEvents\"]),\n    },\n\n    // specific contract types\n    nft: {\n      get: (\n        contractAddress: RequiredParam<ContractAddress>,\n        tokenId: RequiredParam<BigNumberish>,\n      ) => createContractCacheKey(contractAddress, [\"get\", { tokenId }]),\n      balanceOf: (\n        contractAddress: RequiredParam<ContractAddress>,\n        owner: RequiredParam<WalletAddress>,\n        tokenId: RequiredParam<BigNumberish>,\n      ) =>\n        createContractCacheKey(contractAddress, [\n          \"balanceOf\",\n          { owner, tokenId },\n        ]),\n      query: {\n        all: (\n          contractAddress: RequiredParam<ContractAddress>,\n          params?: QueryAllParams,\n        ) =>\n          createContractCacheKey(\n            contractAddress,\n            params ? [\"query\", \"all\", params] : [\"query\", \"all\"],\n          ),\n        totalCirculatingSupply: (\n          contractAddress: RequiredParam<ContractAddress>,\n        ) =>\n          createContractCacheKey(contractAddress, [\n            \"query\",\n            \"totalCirculatingSupply\",\n          ]),\n        totalCount: (contractAddress: RequiredParam<ContractAddress>) =>\n          createContractCacheKey(contractAddress, [\"query\", \"totalCount\"]),\n        owned: {\n          all: (\n            contractAddress: RequiredParam<ContractAddress>,\n            owner: RequiredParam<WalletAddress>,\n          ) =>\n            createContractCacheKey(contractAddress, [\n              \"query\",\n              \"owned\",\n              \"all\",\n              owner,\n            ]),\n        },\n      },\n      drop: {\n        getAllUnclaimed: (\n          contractAddress: RequiredParam<ContractAddress>,\n          params?: QueryAllParams,\n        ) =>\n          createContractCacheKey(\n            contractAddress,\n            params ? [\"getAllUnclaimed\", params] : [\"getAllUnclaimed\"],\n          ),\n        totalUnclaimedSupply: (\n          contractAddress: RequiredParam<ContractAddress>,\n        ) => createContractCacheKey(contractAddress, [\"totalUnclaimedSupply\"]),\n        totalClaimedSupply: (contractAddress: RequiredParam<ContractAddress>) =>\n          createContractCacheKey(contractAddress, [\"totalClaimedSupply\"]),\n      },\n    },\n\n    token: {\n      totalSupply: (contractAddress: RequiredParam<ContractAddress>) =>\n        createContractCacheKey(contractAddress, [\"totalSupply\"]),\n      balanceOf: (\n        contractAddress: RequiredParam<ContractAddress>,\n        walletAddress: RequiredParam<ContractAddress>,\n      ) =>\n        createContractCacheKey(contractAddress, [\n          \"balanceOf\",\n          { walletAddress },\n        ]),\n    },\n    marketplace: {\n      getListing: (\n        contractAddress: RequiredParam<ContractAddress>,\n        listingId: RequiredParam<BigNumberish>,\n      ) =>\n        createContractCacheKey(contractAddress, [\"getListing\", { listingId }]),\n      getAllListings: (\n        contractAddress: RequiredParam<ContractAddress>,\n        params?: MarketplaceFilter,\n      ) =>\n        createContractCacheKey(\n          contractAddress,\n          params ? [\"getAllListings\", params] : [\"getAllListings\"],\n        ),\n      getActiveListings: (\n        contractAddress: RequiredParam<ContractAddress>,\n        params?: MarketplaceFilter,\n      ) =>\n        createContractCacheKey(\n          contractAddress,\n          params ? [\"getActiveListings\", params] : [\"getActiveListings\"],\n        ),\n      getBidBufferBps: (contractAddress: RequiredParam<ContractAddress>) =>\n        createContractCacheKey(contractAddress, [\"getBidBufferBps\"]),\n\n      auction: {\n        getWinningBid: (\n          contractAddress: RequiredParam<ContractAddress>,\n          listingId: RequiredParam<BigNumberish>,\n        ) =>\n          createContractCacheKey(contractAddress, [\n            \"auction\",\n            \"getWinningBid\",\n            { listingId },\n          ]),\n        getWinner: (\n          contractAddress: RequiredParam<ContractAddress>,\n          listingId: RequiredParam<BigNumberish>,\n        ) =>\n          createContractCacheKey(contractAddress, [\n            \"auction\",\n            \"getWinner\",\n            { listingId },\n          ]),\n      },\n    },\n  },\n  // extensions\n  extensions: {\n    claimConditions: {\n      getActive: (\n        contractAddress: RequiredParam<ContractAddress>,\n        tokenId?: BigNumberish,\n      ) =>\n        createContractCacheKey(\n          contractAddress,\n          tokenId\n            ? [\"claimConditions\", \"getActive\", { tokenId }]\n            : [\"claimConditions\", \"getActive\"],\n        ),\n      getAll: (\n        contractAddress: RequiredParam<ContractAddress>,\n        tokenId?: BigNumberish,\n      ) =>\n        createContractCacheKey(\n          contractAddress,\n          tokenId\n            ? [\"claimConditions\", \"getAll\", { tokenId }]\n            : [\"claimConditions\", \"getAll\"],\n        ),\n      getClaimIneligibilityReasons: (\n        contractAddress: RequiredParam<ContractAddress>,\n        params: { walletAddress?: WalletAddress; quantity: string | number },\n        tokenId?: BigNumberish,\n      ) =>\n        createContractCacheKey(\n          contractAddress,\n          tokenId\n            ? [\n                \"claimConditions\",\n                \"getIneligibilityReasons\",\n                { tokenId },\n                params,\n              ]\n            : [\"claimConditions\", \"getIneligibilityReasons\", params],\n        ),\n    },\n\n    // primary sale contracts\n    sales: {\n      getRecipient: (contractAddress: RequiredParam<ContractAddress>) =>\n        createContractCacheKey(contractAddress, [\"sales\"]),\n    },\n    // royalties\n    royalties: {\n      getDefaultRoyaltyInfo: (\n        contractAddress: RequiredParam<ContractAddress>,\n      ) => createContractCacheKey(contractAddress, [\"royalties\"]),\n    },\n    // platform fees\n    platformFees: {\n      get: (contractAddress: RequiredParam<ContractAddress>) =>\n        createContractCacheKey(contractAddress, [\"platformFees\"]),\n    },\n    // contract metadata\n    metadata: {\n      get: (contractAddress: RequiredParam<ContractAddress>) =>\n        createContractCacheKey(contractAddress, [\"metadata\"]),\n    },\n    roles: {\n      getAll: (contractAddress: RequiredParam<ContractAddress>) =>\n        createContractCacheKey(contractAddress, [\"roles\"]),\n      get: (contractAddress: RequiredParam<ContractAddress>, role: string) =>\n        createContractCacheKey(contractAddress, [\"roles\", { role }]),\n    },\n  },\n} as const;\n","import { useSDK } from \"../../Provider\";\nimport { useThirdwebConfigContext } from \"../../contexts/thirdweb-config\";\nimport { cacheKeys } from \"../../utils/cache-keys\";\nimport { useQueryClient } from \"@tanstack/react-query\";\nimport { LoginOptions } from \"@thirdweb-dev/sdk/dist/src/schema\";\nimport React from \"react\";\nimport invariant from \"tiny-invariant\";\n\nexport interface LoginConfig {\n  /**\n   * The URL to redirect to on login.\n   */\n  redirectTo?: string;\n  /**\n   * Function to run on error.\n   */\n  onError?: (error: string) => void;\n}\n\n/**\n * Hook to securely login to a backend with the connected wallet. The backend\n * authentication URL must be configured on the ThirdwebProvider.\n *\n * @param config - Configuration for the login.\n * @returns - A function to invoke to login with the connected wallet.\n *\n * @public\n */\nexport function useLogin(config?: LoginConfig) {\n  const sdk = useSDK();\n  const queryClient = useQueryClient();\n  const { authConfig } = useThirdwebConfigContext();\n\n  React.useEffect(() => {\n    const queryParams = new URLSearchParams(window.location.search);\n    const error = queryParams.get(\"error\");\n\n    if (error && config?.onError) {\n      // If there is an error, parse it and trigger the onError callback\n      config.onError(decodeURI(error));\n    }\n  }, [config?.onError]);\n\n  async function login(cfg?: LoginOptions) {\n    invariant(\n      authConfig,\n      \"Please specify an authConfig in the ThirdwebProvider\",\n    );\n    const payload = await sdk?.auth.login(authConfig.domain, cfg);\n\n    const encodedPayload = encodeURIComponent(btoa(JSON.stringify(payload)));\n    const encodedRedirectTo = encodeURIComponent(\n      config?.redirectTo || authConfig.loginRedirect || window.location.href,\n    );\n\n    queryClient.invalidateQueries(cacheKeys.auth.user());\n\n    // Redirect to the login URL with the encoded payload\n    window.location.href = `${authConfig.authUrl}/login?payload=${encodedPayload}&redirect=${encodedRedirectTo}`;\n  }\n\n  return login;\n}\n","import { useThirdwebConfigContext } from \"../../contexts/thirdweb-config\";\nimport { cacheKeys } from \"../../utils/cache-keys\";\nimport { useQueryClient } from \"@tanstack/react-query\";\nimport invariant from \"tiny-invariant\";\n\n/**\n * Hook to logout the connected wallet from the backend.\n * The backend logout URL must be configured on the ThirdwebProvider.\n *\n * @returns - A function to invoke to logout.\n *\n * @public\n */\nexport function useLogout() {\n  const queryClient = useQueryClient();\n  const { authConfig } = useThirdwebConfigContext();\n\n  function logout() {\n    invariant(\n      authConfig,\n      \"Please specify an authConfig in the ThirdwebProvider\",\n    );\n    queryClient.invalidateQueries(cacheKeys.auth.user());\n    window.location.href = `${authConfig.authUrl}/logout`;\n  }\n\n  return logout;\n}\n","import { useThirdwebConfigContext } from \"../../contexts/thirdweb-config\";\nimport { cacheKeys } from \"../../utils/cache-keys\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport invariant from \"tiny-invariant\";\n\ninterface ThirdwebAuthUser {\n  address: string;\n}\n\n/**\n * Hook to get the currently logged in user.\n *\n * @returns - The currently logged in user or null if not logged in, as well as a loading state.\n *\n * @public\n */\nexport function useUser() {\n  const { authConfig } = useThirdwebConfigContext();\n\n  const { data: user, isLoading } = useQuery(\n    cacheKeys.auth.user(),\n    async () => {\n      invariant(\n        authConfig,\n        \"Please specify an authConfig in the ThirdwebProvider\",\n      );\n      const res = await fetch(`${authConfig.authUrl}/user`);\n      return (await res.json()) as ThirdwebAuthUser;\n    },\n  );\n\n  return { user, isLoading };\n}\n","import { useSDK } from \"../../Provider\";\nimport {\n  ContractForContractType,\n  ContractType,\n} from \"@thirdweb-dev/sdk/dist/browser\";\n\n/**\n * @internal\n * @param contractType - the contract type\n * @param contractAddress - the contract address\n * @returns the instance of the contract for the given type and address\n */\nexport function useBuiltinContract<TContractType extends ContractType>(\n  contractType?: TContractType,\n  contractAddress?: string,\n): ContractForContractType<TContractType> | undefined {\n  const sdk = useSDK();\n  if (!sdk || !contractAddress || !contractType) {\n    return undefined;\n  }\n  return sdk.getBuiltInContract(contractAddress, contractType);\n}\n","import { useBuiltinContract } from \"./useBuiltinContract\";\nimport { EditionDrop } from \"@thirdweb-dev/sdk/dist/browser\";\n\n/**\n * Hook for getting an instance of an `EditionDrop` contract. This conract is used to interface with ERC1155 compliant NFTs that can be lazily minted.\n * @param contractAddress - the address of the Edition Drop contract, found in your thirdweb dashboard\n *\n * @example\n * ```javascript\n * import { useEditionDrop } from '@thirdweb-dev/react'\n *\n * export default function Component() {\n *   const editionDrop = useEditionDrop(\"<YOUR-CONTRACT-ADDRESS>\")\n *\n *   // Now you can use the edition drop contract in the rest of the component\n *\n *   // For example, this function will let the connected wallet claim a new NFT\n *   async function claim(tokenId, quantity) {\n *     await editionDrop.claim(tokenId, quantity)\n *   }\n *\n *   ...\n * }\n * ```\n * @public\n */\nexport function useEditionDrop(\n  contractAddress?: string,\n): EditionDrop | undefined {\n  return useBuiltinContract(\"edition-drop\", contractAddress);\n}\n","import { useBuiltinContract } from \"./useBuiltinContract\";\nimport { Edition } from \"@thirdweb-dev/sdk/dist/browser\";\n\n/**\n * Hook for getting an instance of an `Edition` contract. This contract is used to interface with ERC1155 compliant NFTs.\n * @param contractAddress - the address of the Edition contract, found in your thirdweb dashboard\n *\n * @example\n * ```javascript\n * import { useEdition } from '@thirdweb-dev/react'\n *\n * export default function Component() {\n *   const edition = useEdition(\"<YOUR-CONTRACT-ADDRESS>\")\n *\n *   // Now you can use the edition contract in the rest of the component\n *\n *   // For example, this function will return all the NFTs on this contract\n *   async function getNFTs() {\n *     const nfts = await edition.getAll()\n *     return nfts\n *   }\n *\n *   ...\n * }\n * ```\n * @public\n */\nexport function useEdition(contractAddress?: string): Edition | undefined {\n  return useBuiltinContract(\"edition\", contractAddress);\n}\n","import { useBuiltinContract } from \"./useBuiltinContract\";\nimport { NFTDrop } from \"@thirdweb-dev/sdk/dist/browser\";\n\n/**\n * Hook for getting an instance of an `NFTDrop` contract. This contract is meant to interface with ERC721 compliant NFTs that can be lazily minted.\n * @param contractAddress - the address of the NFT Drop contract, found in your thirdweb dashboard\n *\n * @example\n * ```javascript\n * import { useNFTDrop } from '@thirdweb-dev/react'\n *\n * export default function Component() {\n *   const nftDrop = useNFTDrop(\"<YOUR-CONTRACT-ADDRESS>\")\n *\n *   // Now you can use the nft drop contract in the rest of the component\n *\n *   // For example, this function will let the connected wallet claim a new NFT\n *   async function claim(quantity) {\n *     await nftDrop.claim(quantity)\n *   }\n *\n *   ...\n * }\n * ```\n * @public\n */\nexport function useNFTDrop(contractAddress?: string): NFTDrop | undefined {\n  return useBuiltinContract(\"nft-drop\", contractAddress);\n}\n","import { useBuiltinContract } from \"./useBuiltinContract\";\nimport { Marketplace } from \"@thirdweb-dev/sdk/dist/browser\";\n\n/**\n * Hook for getting an instance of a `Marketplace` contract. This contract is used to support marketplace for purchase and sale of on-chain assets.\n * @param contractAddress - the address of the Marketplace contract, found in your thirdweb dashboard\n *\n * @example\n * ```javascript\n * import { useMarketplace } from '@thirdweb-dev/react'\n *\n * export default function Component() {\n *   const marketplace = useMarketplace(\"<YOUR-CONTRACT-ADDRESS>\")\n *\n *   // Now you can use the marketplace contract in the rest of the component\n *\n *   // For example, this function will return all the listings on the marketplace\n *   async function getListings() {\n *     const listings = await marketplace.getAll()\n *     return listings\n *   }\n *\n *   ...\n * }\n * ```\n * @public\n */\nexport function useMarketplace(\n  contractAddress?: string,\n): Marketplace | undefined {\n  return useBuiltinContract(\"marketplace\", contractAddress);\n}\n","import { useBuiltinContract } from \"./useBuiltinContract\";\nimport { NFTCollection } from \"@thirdweb-dev/sdk/dist/browser\";\n\n/**\n * Hook for getting an instance of an `NFTCollection` contract. This contract is meant to interface with ERC721 compliant NFTs.\n * @param contractAddress - the address of the NFT Collection contract, found in your thirdweb dashboard\n *\n * @example\n * ```javascript\n * import { useNFTCollection } from '@thirdweb-dev/react'\n *\n * export default function Component() {\n *   const nftCollection = useNFTCollection(\"<YOUR-CONTRACT-ADDRESS>\")\n *\n *   // Now you can use the nftCollection contract in the rest of the component\n *\n *   // For example, this function will return all the NFTs on this contract\n *   async function getNFTs() {\n *     const nfts = await nftCollection.getAll()\n *     return nfts\n *   }\n *\n *   ...\n * }\n * ```\n * @public\n */\nexport function useNFTCollection(\n  contractAddress?: string,\n): NFTCollection | undefined {\n  return useBuiltinContract(\"nft-collection\", contractAddress);\n}\n","import { useBuiltinContract } from \"./useBuiltinContract\";\nimport { Pack } from \"@thirdweb-dev/sdk/dist/browser\";\n\n/**\n * Hook for getting an instance of a `Pack` contract. This contract supports the creation of on-chain luck-based lootboxes.\n * @param contractAddress - the address of the Pack contract, found in your thirdweb dashboard\n *\n * @example\n * ```javascript\n * import { usePack } from '@thirdweb-dev/react'\n *\n * export default function Component() {\n *   const pack = usePack(\"<YOUR-CONTRACT-ADDRESS>\")\n *\n *   // Now you can use the pack contract in the rest of the component\n *\n *   // For example, this function will get all the packs on this contract\n *   async function getPacks() {\n *     const packs = await pack.getAll()\n *     return packs\n *   }\n *\n *   ...\n * }\n * ```\n * @public\n */\nexport function usePack(contractAddress?: string): Pack | undefined {\n  return useBuiltinContract(\"pack\", contractAddress);\n}\n","import { useBuiltinContract } from \"./useBuiltinContract\";\nimport { Token } from \"@thirdweb-dev/sdk/dist/browser\";\n\n/**\n * Hook for getting an instance of an `Token` contract. This contract supports ERC20 compliant tokens.\n * @param contractAddress - the address of the Token contract, found in your thirdweb dashboard\n *\n * @example\n * ```javascript\n * import { useToken } from '@thirdweb-dev/react'\n *\n * export default function Component() {\n *   const token = useToken(\"<YOUR-CONTRACT-ADDRESS>\")\n *\n *   // Now you can use the token contract in the rest of the component\n *\n *   // For example, this function will get the connected wallets token balance\n *   async function balance() {\n *     const balance = await token.balance()\n *     return balance\n *   }\n *\n *   ...\n * }\n * ```\n * @public\n */\nexport function useToken(contractAddress?: string): Token | undefined {\n  return useBuiltinContract(\"token\", contractAddress);\n}\n","import { useBuiltinContract } from \"./useBuiltinContract\";\nimport { TokenDrop } from \"@thirdweb-dev/sdk/dist/browser\";\n\n/**\n * Returns a Token contract instance\n * @param contractAddress - the address of the Token contract, found in your thirdweb dashboard\n * @internal\n */\nexport function useTokenDrop(contractAddress?: string): TokenDrop | undefined {\n  return useBuiltinContract(\"token-drop\", contractAddress);\n}\n","import { useBuiltinContract } from \"./useBuiltinContract\";\nimport { Vote } from \"@thirdweb-dev/sdk/dist/browser\";\n\n/**\n * Hook for getting an instance of an `Vote` contract. This contract enables fully featured voting-based decentralized governance systems.\n * @param contractAddress - the address of the Vote contract, found in your thirdweb dashboard\n *\n * @example\n * ```javascript\n * import { useVote } from '@thirdweb-dev/react'\n *\n * export default function Component() {\n *   const vote = useVote(\"<YOUR-CONTRACT-ADDRESS>\")\n *\n *   // Now you can use the vote contract in the rest of the component\n *\n *   // For example, this function will get all the proposals on this contract\n *   async function getProposals() {\n *     const proposals = await vote.getAll()\n *     return proposals\n *   }\n *\n *   ...\n * }\n * ```\n * @public\n */\nexport function useVote(contractAddress?: string): Vote | undefined {\n  return useBuiltinContract(\"vote\", contractAddress);\n}\n","import { useBuiltinContract } from \"./useBuiltinContract\";\nimport { Split } from \"@thirdweb-dev/sdk/dist/browser\";\n\n/**\n * Hook for getting an instance of a `Split` contract. This contract supports fund distribution to multiple parties.\n * @param contractAddress - the address of the Split contract, found in your thirdweb dashboard\n *\n * @example\n * ```javascript\n * import { useSplit } from '@thirdweb-dev/react'\n *\n * export default function Component() {\n *   const split = useSplit(\"<YOUR-CONTRACT-ADDRESS>\")\n *\n *   // Now you can use the split contract in the rest of the component\n *\n *   // For example, this function will retrun all the receipients of the split\n *   async function getRecipients() {\n *     const recipients = await split.getAllRecipients()\n *     return recipients\n *   }\n *\n *   ...\n * }\n * ```\n * @public\n */\nexport function useSplit(contractAddress?: string): Split | undefined {\n  return useBuiltinContract(\"split\", contractAddress);\n}\n","import { useBuiltinContract } from \"./useBuiltinContract\";\nimport { Multiwrap } from \"@thirdweb-dev/sdk/dist/browser\";\n\n/**\n * Hook for getting an instance of an `Multiwrap` contract. This contract is an ERC721 in which you can wrap ERC721, ERC1155 and ERC20 tokens.\n * @param contractAddress - the address of the Multiwrap contract, found in your thirdweb dashboard\n *\n * @example\n * ```javascript\n * import { useMultiwrap } from '@thirdweb-dev/react'\n *\n * export default function Component() {\n *   const multiwrap = useMultiwrap(\"<YOUR-CONTRACT-ADDRESS>\")\n *\n *   // Now you can use the multiwrap contract in the rest of the component\n *\n *   // For example, this function will let the connected wallet wrap tokens\n *   async function wrap(tokensToWrap, wrappedNFTMetadata) {\n *     await multiwrap.wrap(tokensToWrap, wrappedNFTMetadata)\n *   }\n *\n *   ...\n * }\n * ```\n * @public\n */\nexport function useMultiwrap(contractAddress?: string): Multiwrap | undefined {\n  return useBuiltinContract(\"multiwrap\", contractAddress);\n}\n","import { useBuiltinContract } from \"./useBuiltinContract\";\nimport { SignatureDrop } from \"@thirdweb-dev/sdk/dist/browser\";\n\n/**\n * Hook for getting an instance of an `SignatureDrop` contract. This contract is meant to interface with ERC721 compliant NFTs that can be lazily minted.\n * @param contractAddress - the address of the NFT Drop contract, found in your thirdweb dashboard\n *\n * @example\n * ```javascript\n * import { useSignatureDrop } from '@thirdweb-dev/react'\n *\n * export default function Component() {\n *   const signatureDrop = useSignatureDrop(\"<YOUR-CONTRACT-ADDRESS>\")\n *\n *   // Now you can use the Signature drop contract in the rest of the component\n *\n *   // For example, this function will let the connected wallet claim a new NFT\n *   async function claim(quantity) {\n *     await signatureDrop.claim(quantity)\n *   }\n *\n *   ...\n * }\n * ```\n * @public\n */\nexport function useSignatureDrop(\n  contractAddress?: string,\n): SignatureDrop | undefined {\n  return useBuiltinContract(\"signature-drop\", contractAddress);\n}\n","import { useConnect as useWagmiConnect } from \"wagmi\";\n\n/**\n * for now just re-exported\n * @internal\n */\nexport function useConnect() {\n  return useWagmiConnect();\n}\n","import { GnosisSafeConnector } from \"../connectors/gnosis-safe\";\nimport { useConnect } from \"./useConnect\";\nimport { useAccount } from \"wagmi\";\n\n/**\n * Hook for disconnecting the currently connected wallet\n *\n * ```javascript\n * import { useDisconnect } from \"@thirdweb-dev/react\"\n * ```\n *\n *\n * @example\n * The following will enable users to disconnect their wallet from the page.\n * ```javascript\n * import { useDisconnect } from \"@thirdweb-dev/react\"\n *\n * const App = () => {\n *   const disconnect = useDisconnect()\n *\n *   return (\n *     <button onClick={disconnect}>\n *       Disconnect\n *     </button>\n *   )\n * }\n * ```\n *\n * Once users disconnect their wallet, the `useAddress`, `useChainId`, `useAccount`, and `useNetwork` hooks will no longer return values until a user connects their wallet again.\n *\n * @public\n */\nexport function useDisconnect(options?: { reconnectAfterGnosis?: boolean }) {\n  const optsWithDefaults = { ...{ reconnectAfterGnosis: true }, ...options };\n  const [, connect] = useConnect();\n  const [data, disconnect] = useAccount();\n\n  return async () => {\n    const previousConnector =\n      (data.data?.connector instanceof GnosisSafeConnector &&\n        data.data.connector.previousConnector) ||\n      undefined;\n    // if it's gnosis, just connect the previous connector\n    if (optsWithDefaults.reconnectAfterGnosis && previousConnector) {\n      try {\n        return await connect(previousConnector);\n      } catch (err) {\n        console.error(\"failed to re-connect to previous connector\", err);\n        // if it fails for whatever reason just disconnect\n        return disconnect();\n      }\n    }\n\n    return disconnect();\n  };\n}\n","import { useAccount } from \"wagmi\";\n\n/**\n * Hook for accessing the address of the connected wallet\n *\n * ```javascript\n * import { useAddress } from \"@thirdweb-dev/react\"\n * ```\n *\n *\n * @example\n * To get the address of the connected wallet, you can use the hook as follows:\n *\n * ```javascript\n * import { useAddress } from \"@thirdweb-dev/react\"\n *\n * const App = () => {\n *   const address = useAddress()\n *\n *   return <div>{address}</div>\n * }\n * ```\n *\n * The `address` variable will hold the address of the connected wallet if a user has connected using one of the supported wallet connection hooks.\n *\n * @public\n */\nexport function useAddress(): string | undefined {\n  const [account] = useAccount();\n  return account.data?.address;\n}\n","import {\n  IStorage,\n  SDKOptions,\n  ThirdwebSDK,\n} from \"@thirdweb-dev/sdk/dist/browser\";\nimport { useMemo } from \"react\";\n\n/**\n * @internal\n */\nexport function useReadonlySDK(\n  readonlyRpcUrl: string,\n  sdkOptions: SDKOptions,\n  storageInterface?: IStorage,\n): ThirdwebSDK {\n  return useMemo(() => {\n    return new ThirdwebSDK(\n      readonlyRpcUrl,\n      {\n        ...sdkOptions,\n        readonlySettings: {\n          ...sdkOptions?.readonlySettings,\n          rpcUrl: readonlyRpcUrl,\n        },\n      },\n      storageInterface,\n    );\n  }, [readonlyRpcUrl, sdkOptions]);\n}\n","import {\n  BotInfo,\n  BrowserInfo,\n  NodeInfo,\n  ReactNativeInfo,\n  SearchBotDeviceInfo,\n  detect,\n} from \"detect-browser\";\n\nfunction detectEnv(\n  userAgent?: string,\n):\n  | BrowserInfo\n  | BotInfo\n  | NodeInfo\n  | SearchBotDeviceInfo\n  | ReactNativeInfo\n  | null {\n  return detect(userAgent);\n}\n\n/**\n * @internal\n */\nexport function isAndroid(): boolean {\n  const os = detectOS();\n  return os ? os.toLowerCase().includes(\"android\") : false;\n}\n\n/**\n * @internal\n */\nexport function isIOS(): boolean {\n  const os = detectOS();\n  return os\n    ? os.toLowerCase().includes(\"ios\") ||\n        (os.toLowerCase().includes(\"mac\") && navigator.maxTouchPoints > 1)\n    : false;\n}\n\n/**\n * @internal\n */\nfunction detectOS() {\n  const env = detectEnv();\n  return env?.os ? env.os : undefined;\n}\n\n/**\n * @internal\n */\nexport function isMobile(): boolean {\n  const os = detectOS();\n  return os ? isAndroid() || isIOS() : false;\n}\n","import { isAndroid, isMobile } from \"../../utils/isMobile\";\nimport { useConnect } from \"../useConnect\";\nimport invariant from \"tiny-invariant\";\n\n/**\n * Hook for connecting to a Metamask wallet.\n *\n * ```javascript\n * import { useMetamask } from \"@thirdweb-dev/react\"\n * ```\n *\n *\n * @example\n * We can allow users to connect their metamask wallets as follows:\n * ```javascript\n * import { useMetamask } from \"@thirdweb-dev/react\"\n *\n * const App = () => {\n *   const connectWithMetamask = useMetamask()\n *\n *   return (\n *     <button onClick={connectWithMetamask}>\n *       Connect Metamask\n *     </button>\n *   )\n * }\n * ```\n * Here, we use the `useMetamask` hook to handle metamask connection.\n * When a user clicks the button, we'll call the `connectWithMetamask` function, which will prompt users to connect their metamask wallet.\n *\n * @public\n */\nexport function useMetamask() {\n  const [connectors, connect] = useConnect();\n  if (connectors.loading) {\n    return () => Promise.reject(\"Metamask connector not ready to be used, yet\");\n  }\n\n  const isMetaMaskInjected =\n    typeof window !== \"undefined\" && window.ethereum?.isMetaMask;\n\n  const shouldUseWalletConnect = isMobile() && !isMetaMaskInjected;\n\n  // injected connector\n  const injectedConnector = connectors.data.connectors.find(\n    (c) => c.id === \"injected\",\n  );\n  // walletConnect connector\n  const walletConnectConnector = connectors.data.connectors.find(\n    (c) => c.id === \"walletConnect\",\n  );\n\n  const connector =\n    (shouldUseWalletConnect ? walletConnectConnector : injectedConnector) ||\n    injectedConnector;\n\n  invariant(\n    connector,\n    \"No connector found, please make sure you provide the InjectedConnector to your <ThirdwebProvider />\",\n  );\n\n  return async () => {\n    // if we don't have an injected provider\n    if (!isMetaMaskInjected) {\n      // this is the fallback uri that should work no matter what\n      let uri = `https://metamask.app.link/dapp/${\n        window.location.host + window.location.pathname + window.location.search\n      }`;\n\n      // if we have walletconnect etc, we can try to use that\n      if (shouldUseWalletConnect && connector.id === \"walletConnect\") {\n        try {\n          uri = (await connector.getProvider()).connector.uri;\n          // if android we can use the uri straight\n          uri = isAndroid()\n            ? uri\n            : // otherwise we have to use /dapp link for now\n              `https://metamask.app.link/dapp/${\n                window.location.host +\n                window.location.pathname +\n                window.location.search\n              }`;\n        } catch (err) {\n          console.warn(\"failed to get provider.connector.uri\", err);\n        }\n      }\n      // open whatever uri we end up with in a new tab\n      window.open(uri, \"_blank\");\n\n      return Promise.resolve({\n        error: new Error(\"metamask not injected\"),\n      });\n    }\n\n    // otherwise we have MM avaiable, so we can just use it\n    return await connect(connector);\n  };\n}\n","import { useConnect } from \"../useConnect\";\nimport invariant from \"tiny-invariant\";\n\n/**\n * Hook for connecting to a mobile wallet with Wallet Connect\n *\n * ```javascript\n * import { useWalletConnect } from \"@thirdweb-dev/react\"\n * ```\n *\n *\n * @example\n * We can allows user to connect their mobile wallets as follows:\n * ```javascript\n * import { useWalletConnect } from \"@thirdweb-dev/react\"\n *\n * const App = () => {\n *   const connectWithWalletConnect = useWalletConnect()\n *\n *   return (\n *     <button onClick={connectWithWalletConnect}>\n *       Connect WalletConnect\n *     </button>\n *   )\n * }\n * ```\n *\n * When users click this button, a popup will appear on the screen prompting them to scan a QR code from their phone to connect their mobile wallets.\n * Once they scan the QR code from a wallet connect supported mobile wallet, their wallet will then be connected to the page as expected.\n *\n * @public\n */\nexport function useWalletConnect() {\n  const [connectors, connect] = useConnect();\n  if (connectors.loading) {\n    return () =>\n      Promise.reject(\"WalletConnect connector not ready to be used, yet\");\n  }\n  const connector = connectors.data.connectors.find(\n    (c) => c.id === \"walletConnect\",\n  );\n  invariant(\n    connector,\n    \"WalletConnect connector not found, please make sure it is provided to your <ThirdwebProvider />\",\n  );\n\n  return () => connect(connector);\n}\n","import { useConnect } from \"../useConnect\";\nimport invariant from \"tiny-invariant\";\n\n/**\n * Hook for connecting to a Coinbase wallet.\n *\n * ```javascript\n * import { useCoinbaseWallet } from \"@thirdweb-dev/react\"\n * ```\n *\n *\n * @example\n * We can allow users to connect with Coinbase Wallet as follows:\n * ```javascript\n * import { useCoinbaseWallet } from \"@thirdweb-dev/react\"\n *\n * const App = () => {\n *   const connectWithCoinbaseWallet = useCoinbaseWallet()\n *\n *   return (\n *     <button onClick={connectWithCoinbaseWallet}>\n *       Connect Coinbase Wallet\n *     </button>\n *   )\n * }\n * ```\n *\n * Upon clicking this button, users will be prompted with a popup asking them scan a QR code with their Coinbase Wallet.\n * Once they scan the QR code, their wallet will then be connected to the page as expected.\n *\n * @public\n */\nexport function useCoinbaseWallet() {\n  const [connectors, connect] = useConnect();\n  if (connectors.loading) {\n    return () => Promise.reject(\"Coinbase connector not ready to be used, yet\");\n  }\n  const connector = connectors.data.connectors.find(\n    (c) => c.id === \"coinbasewallet\",\n  );\n  invariant(\n    connector,\n    \"Coinbase connector not found, please make sure it is provided to your <ThirdwebProvider />\",\n  );\n\n  return () => connect(connector);\n}\n\n/**\n * Convienience hook for connecting to a wallet via WalletLink (coinbase wallet)\n * @returns a function that will prompt the user to connect their wallet via WalletLink (coinbase wallet)\n * @internal\n */\nexport function useWalletLink() {\n  return useCoinbaseWallet();\n}\n","import {\n  GnosisConnectorArguments,\n  GnosisSafeConnector,\n} from \"../../connectors/gnosis-safe\";\nimport { useConnect } from \"../useConnect\";\nimport { utils } from \"ethers\";\nimport invariant from \"tiny-invariant\";\n\n/**\n * Hook for connecting to a Gnosis Safe. This enables multisig wallets to connect to your application and sing transactions.\n *\n * ```javascript\n * import { useGnosis } from \"@thirdweb-dev/react\"\n * ```\n *\n *\n * @example\n * ```javascript\n * import { useGnosis } from \"@thirdweb-dev/react\"\n *\n * const App = () => {\n *   const connectWithGnosis = useGnosis()\n *\n *   return (\n *     <button onClick={() => connectWithGnosis({ safeAddress: \"0x...\", safeChainId: 1 })}>\n *       Connect Gnosis Safe\n *     </button>\n *   )\n * }\n * ```\n *\n * @public\n */\nexport function useGnosis() {\n  const [connectors, connect] = useConnect();\n  if (connectors.loading) {\n    return () => Promise.reject(\"Gnosis connector not ready to be used, yet\");\n  }\n  const connector = connectors.data.connectors.find((c) => c.id === \"gnosis\");\n  invariant(\n    connector,\n    \"Gnosis connector not found, please make sure it is provided to your <ThirdwebProvider />\",\n  );\n\n  return async (config: GnosisConnectorArguments) => {\n    const previousConnector = connectors.data.connector;\n    const previousConnectorChain = await previousConnector?.getChainId();\n    invariant(\n      !!previousConnector,\n      \"Cannot connect to Gnosis Safe without first being connected to a personal wallet.\",\n    );\n    invariant(\n      previousConnectorChain === config.safeChainId,\n      \"Gnosis safe chain id must match personal wallet chain id.\",\n    );\n    invariant(\n      utils.isAddress(config.safeAddress),\n      \"Gnosis safe address must be a valid address.\",\n    );\n    (connector as GnosisSafeConnector).setConfiguration(\n      previousConnector,\n      config,\n    );\n    return connect(connector);\n  };\n}\n","import { MagicConnector } from \"../../connectors/magic\";\nimport { useConnect } from \"../useConnect\";\nimport { LoginWithMagicLinkConfiguration } from \"magic-sdk\";\nimport invariant from \"tiny-invariant\";\n\n/**\n * Hook for connecting to an email wallet using magic link.\n * This enables users without their own wallets to connect to your application and sign transactions securely using their email.\n *\n * ```javascript\n * import { useMagic } from \"@thirdweb-dev/react\"\n * ```\n *\n *\n * @example\n * Before using this hook, you first need to set up the magic configuration in your `ThirdwebProvider`, including your magic API key.\n *\n * ```javascript\n * // Add the magic configuration object to your wallet connectors\n * const connectors = [\n *   \"metamask\",\n *   \"walletConnect\",\n *   \"walletLink\",\n *   {\n *     name: \"magic\",\n *     options: {\n *       apiKey: \"your-magic-api-key\",\n *     }\n *   }\n * ]\n *\n * // Add the above to the walletConnectors prop of your <ThirdwebProvider />\n * const Provider = ({ children }) => (\n *   return (\n *     <ThirdwebProvider\n *       walletConnectors={connectors}\n *       // Specify remaining parameters\n *       ...\n *     >\n *       {children}\n *     </ThirdwebProvider>\n *   )\n * }\n * ```\n *\n * In order to use the hook to connect users with magic link, you just need to provide the users email to the connect function.\n *\n * You can setup the hook with the following configuration:\n * ```javascript\n * import { useMagic } from \"@thirdweb-dev/react\"\n * import { useState } from \"react\"\n *\n * const LoginWithMagicLink = () => {\n *   const connectWithMagic = useMagic()\n *   const [email, setEmail] = useState()\n *\n *   return (\n *     <div>\n *       <input value={email} onChange={(e) => setEmail(e.target.value)} />\n *       <button onClick={() => connectWithMagic({ email })}>Login</button>\n *     </div>\n *   )\n * }\n * ```\n *\n * @public\n */\nexport function useMagic() {\n  const [connectors, connect] = useConnect();\n  if (connectors.loading) {\n    return () => Promise.reject(\"Magic connector not ready to be used, yet\");\n  }\n\n  const connector = connectors.data.connectors.find((c) => c.id === \"magic\");\n\n  invariant(\n    connector,\n    \"Magic connector not found, please make sure it is provided to your <ThirdwebProvider />\",\n  );\n\n  return (configuration: LoginWithMagicLinkConfiguration) => {\n    (connector as MagicConnector).setConfiguration(configuration);\n    return connect(connector);\n  };\n}\n","import { useNetwork } from \"wagmi\";\n\n/**\n * Hook for accessing the chain ID of the network the current wallet is connected to\n *\n * ```javascript\n * import { useChainId } from \"@thirdweb-dev/react\"\n * ```\n *\n * @example\n * You can get the chain ID of the connected wallet by using the hook as follows:\n * ```javascript\n * import { useChainId } from \"@thirdweb-dev/react\"\n *\n * const App = () => {\n *   const chainId = useChainId()\n *\n *   return <div>{chainId}</div>\n * }\n * ```\n * @public\n */\nexport function useChainId(): number | undefined {\n  return useNetwork()[\"0\"].data.chain?.id;\n}\n","import { useDesiredChainId } from \"../Provider\";\nimport { useChainId } from \"./useChainId\";\n\n/**\n * Hook for checking whether the connected wallet is on the correct network specified by the `desiredChainId` passed to the `<ThirdwebProvider />`.\n *\n * ```javascript\n * import { useNetworkMistmatch } from \"@thirdweb-dev/react\"\n * ```\n *\n * @returns `true` if the chainId of the connected wallet is different from the desired chainId passed into <ThirdwebProvider />\n *\n * @example\n * You can check if a users wallet is connected to the correct chain ID as follows:\n * ```javascript\n * import { useNetworkMismatch } from \"@thirdweb-dev/react\"\n *\n * const App = () => {\n *   const isMismatched = useNetworkMismatch()\n *\n *   return <div>{isMismatched}</div>\n * }\n * ```\n *\n * From here, you can prompt users to switch their network using the `useNetwork` hook.\n *\n * @public\n */\nexport function useNetworkMismatch() {\n  const desiredChainId = useDesiredChainId();\n  const activeChainId = useChainId();\n\n  if (desiredChainId === -1) {\n    // means no desiredChainId is set in the <ThirdwebProvider />, so we don't care about the network mismatch\n    return false;\n  }\n  if (!activeChainId) {\n    // means no wallet is connected yet, so we don't care about the network mismatch\n    return false;\n  }\n  // check if the chainIds are different\n  return desiredChainId !== activeChainId;\n}\n","import { useNetwork as useWagmiNetwork } from \"wagmi\";\n\n/**\n * Hook for getting metadata about the network the current wallet is connected to and switching networks\n *\n * @example\n * ```javascript\n * import { useNetwork, ChainId } from \"@thirdweb-dev/react\";\n *\n * const App = () => {\n *   const [, switchNetwork] = useNetwork();\n *\n *   return (\n *     <button onClick={() => switchNetwork(ChainId.Polygon)}>\n *        Switch Network\n *     </button>\n *   );\n * };\n```\n *\n * It's important to note that some wallet apps do not support programmatic network switching and switchNetwork will be undefined.\n * For those situations, you can typically switch networks in the wallet app this hook will still work.\n *\n * @public\n */\n\nexport function useNetwork() {\n  return useWagmiNetwork();\n}\n","// contract hooks\nexport * from \"./Provider\";\nexport * from \"./hooks/auth\";\nexport * from \"./hooks/contracts\";\nexport * from \"./hooks/useDisconnect\";\nexport * from \"./hooks/useConnect\";\nexport * from \"./hooks/useSigner\";\nexport * from \"./hooks/useAddress\";\nexport * from \"./hooks/useReadonlySDK\";\nexport * from \"./hooks/connectors/useMetamask\";\nexport * from \"./hooks/connectors/useWalletConnect\";\nexport * from \"./hooks/connectors/useWalletLink\";\nexport * from \"./hooks/connectors/useGnosis\";\nexport * from \"./hooks/connectors/useMagic\";\nexport * from \"./hooks/useChainId\";\nexport * from \"./hooks/useNetworkMismatch\";\nexport * from \"./hooks/useNetwork\";\n\n// re-exports\nexport { defaultChains, defaultL2Chains, useAccount, useProvider } from \"wagmi\";\nexport { ChainId, IpfsStorage } from \"@thirdweb-dev/sdk/dist/browser\";\n// ui components\nexport * from \"./components/MediaRenderer\";\nexport * from \"./components/NftMedia\";\n\n// async hooks\nexport * from \"./hooks/async/contracts\";\nexport * from \"./hooks/async/nft\";\nexport * from \"./hooks/async/drop\";\nexport * from \"./hooks/async/marketplace\";\nexport * from \"./hooks/async/token\";\nexport * from \"./hooks/async/claim-conditions\";\nexport * from \"./hooks/async/wallet\";\nexport * from \"./hooks/async/contract-settings\";\nexport * from \"./hooks/async/roles\";\n\n// types\nexport * from \"./types\";\n","export const DEFAULT_IPFS_GATEWAY = \"https://gateway.ipfscdn.io/ipfs/\";\n\nexport interface IPFSResolverOptions {\n  gatewayUrl: string;\n}\n\nexport const DEFAULT_IPFS_RESOLVER_OPTIONS: IPFSResolverOptions = {\n  gatewayUrl: DEFAULT_IPFS_GATEWAY,\n};\n","import { DEFAULT_IPFS_RESOLVER_OPTIONS } from \"../constants/ipfs\";\nimport mime from \"mime/lite.js\";\n\nexport function resolveIpfsUri(\n  uri?: string,\n  options = DEFAULT_IPFS_RESOLVER_OPTIONS,\n) {\n  if (!uri) {\n    return undefined;\n  }\n  if (uri.startsWith(\"ipfs://\")) {\n    return uri.replace(\"ipfs://\", options.gatewayUrl);\n  }\n  return uri;\n}\n\nexport async function resolveMimeType(url?: string) {\n  if (!url) {\n    return undefined;\n  }\n  const mimeType = mime.getType(url);\n  if (mimeType) {\n    return mimeType;\n  }\n\n  const res = await fetch(url, {\n    method: \"HEAD\",\n  });\n  if (res.ok && res.headers.has(\"content-type\")) {\n    return res.headers.get(\"content-type\") ?? undefined;\n  }\n  // we failed to resolve the mime type, return null\n  return undefined;\n}\n","let video: HTMLVideoElement;\n\nfunction supportsVideoType(mimeType?: string) {\n  if (\n    typeof window === \"undefined\" ||\n    !mimeType ||\n    !mimeType.startsWith(\"video/\")\n  ) {\n    return \"\";\n  }\n\n  if (!video) {\n    video = document.createElement(\"video\");\n  }\n\n  return video.canPlayType(mimeType);\n}\n\nexport function shouldRenderVideoTag(mimeType?: string) {\n  return !!supportsVideoType(mimeType);\n}\n\nlet audio: HTMLAudioElement;\n\nfunction supportsAudioType(mimeType?: string) {\n  if (\n    typeof window === \"undefined\" ||\n    !mimeType ||\n    !mimeType.startsWith(\"audio/\")\n  ) {\n    return \"\";\n  }\n\n  if (!audio) {\n    audio = document.createElement(\"audio\");\n  }\n\n  return audio.canPlayType(mimeType);\n}\n\nexport function shouldRenderAudioTag(mimeType?: string) {\n  return !!supportsAudioType(mimeType);\n}\n","export function mergeRefs<T = any>(\n  refs: Array<React.MutableRefObject<T> | React.LegacyRef<T>>,\n): React.RefCallback<T> {\n  return (value) => {\n    refs.forEach((ref) => {\n      if (typeof ref === \"function\") {\n        ref(value);\n        // eslint-disable-next-line eqeqeq\n      } else if (ref != null) {\n        (ref as React.MutableRefObject<T | null>).current = value;\n      }\n    });\n  };\n}\n","import React, { SVGProps } from \"react\";\n\nexport const CarbonDocumentUnknown: React.VFC<SVGProps<SVGSVGElement>> = (\n  props,\n) => {\n  return (\n    <svg width=\"1em\" height=\"1em\" viewBox=\"0 0 32 32\" {...props}>\n      <circle cx=\"9\" cy=\"28.5\" r=\"1.5\" fill=\"currentColor\"></circle>\n      <path\n        fill=\"currentColor\"\n        d=\"M10 25H8v-4h2a2 2 0 0 0 0-4H8a2.002 2.002 0 0 0-2 2v.5H4V19a4.005 4.005 0 0 1 4-4h2a4 4 0 0 1 0 8Z\"\n      ></path>\n      <path\n        fill=\"currentColor\"\n        d=\"m27.7 9.3l-7-7A.908.908 0 0 0 20 2H10a2.006 2.006 0 0 0-2 2v8h2V4h8v6a2.006 2.006 0 0 0 2 2h6v16H14v2h12a2.006 2.006 0 0 0 2-2V10a.91.91 0 0 0-.3-.7ZM20 10V4.4l5.6 5.6Z\"\n      ></path>\n    </svg>\n  );\n};\n\nexport const CarbonDocumentAudio: React.VFC<SVGProps<SVGSVGElement>> = (\n  props,\n) => {\n  return (\n    <svg width=\"1em\" height=\"1em\" viewBox=\"0 0 32 32\" {...props}>\n      <path\n        fill=\"currentColor\"\n        d=\"M29 31a.999.999 0 0 1-.625-.22L23.65 27H20a1 1 0 0 1-1-1v-5a1 1 0 0 1 1-1h3.65l4.726-3.78A1 1 0 0 1 30 17v13a1 1 0 0 1-1 1Zm-8-6h3a1 1 0 0 1 .625.22L28 27.92v-8.84l-3.376 2.7A1 1 0 0 1 24 22h-3Z\"\n      ></path>\n      <path\n        fill=\"currentColor\"\n        d=\"M16 28H8V4h8v6a2.006 2.006 0 0 0 2 2h6v3h2v-5a.91.91 0 0 0-.3-.7l-7-7A.909.909 0 0 0 18 2H8a2.006 2.006 0 0 0-2 2v24a2.006 2.006 0 0 0 2 2h8Zm2-23.6l5.6 5.6H18Z\"\n      ></path>\n    </svg>\n  );\n};\n\nexport const CarbonPauseFilled: React.VFC<SVGProps<SVGSVGElement>> = (\n  props,\n) => {\n  return (\n    <svg width=\"1em\" height=\"1em\" viewBox=\"0 0 32 32\" {...props}>\n      <path\n        fill=\"currentColor\"\n        d=\"M12 6h-2a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2zm10 0h-2a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2z\"\n      ></path>\n    </svg>\n  );\n};\n\nexport const CarbonPlayFilledAlt: React.VFC<SVGProps<SVGSVGElement>> = (\n  props,\n) => {\n  return (\n    <svg width=\"1em\" height=\"1em\" viewBox=\"0 0 32 32\" {...props}>\n      <path\n        fill=\"currentColor\"\n        d=\"M7 28a1 1 0 0 1-1-1V5a1 1 0 0 1 1.482-.876l20 11a1 1 0 0 1 0 1.752l-20 11A1 1 0 0 1 7 28Z\"\n      ></path>\n    </svg>\n  );\n};\n","import { resolveIpfsUri, resolveMimeType } from \"../utils/ipfs\";\nimport { shouldRenderAudioTag, shouldRenderVideoTag } from \"../utils/media\";\nimport { mergeRefs } from \"../utils/react\";\nimport {\n  CarbonDocumentAudio,\n  CarbonDocumentUnknown,\n  CarbonPauseFilled,\n  CarbonPlayFilledAlt,\n} from \"./Icons\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport React, { useEffect, useMemo, useRef, useState } from \"react\";\nimport useDimensions from \"react-cool-dimensions\";\n\nexport interface SharedMediaProps {\n  className?: string;\n  style?: React.CSSProperties;\n  width?: HTMLIFrameElement[\"width\"];\n  height?: HTMLIFrameElement[\"height\"];\n  /**\n   * Require user interaction to play the media. (default false)\n   */\n  requireInteraction?: boolean;\n  /**\n   * Show the media controls (where applicable) (default false)\n   */\n  controls?: HTMLVideoElement[\"controls\"];\n}\n\n/**\n *\n * The props for the {@link MediaRenderer} component.\n * @public\n */\nexport interface MediaRendererProps extends SharedMediaProps {\n  /**\n   * The media source uri.\n   */\n  src?: string | null;\n  /**\n   * The alt text for the media.\n   */\n  alt?: string;\n  /**\n   * The media poster image uri. (if applicable)\n   */\n  poster?: string | null;\n}\n\ninterface PlayButtonProps {\n  onClick: () => void;\n  isPlaying: boolean;\n}\n\nconst PlayButton: React.VFC<PlayButtonProps> = ({ onClick, isPlaying }) => {\n  const [isHovering, setIsHovering] = useState(false);\n  const onMouseEnter = () => setIsHovering(true);\n  const onMouseLeave = () => setIsHovering(false);\n  const onMouseDown = () => setIsHovering(false);\n  const onMouseUp = () => setIsHovering(true);\n  return (\n    <button\n      style={{\n        position: \"absolute\",\n        bottom: 0,\n        right: 0,\n        transform: \"translate(-25%, -25%)\",\n        maxWidth: \"32px\",\n        width: \"8%\",\n        minWidth: \"24px\",\n        aspectRatio: \"1\",\n        zIndex: 3,\n        backgroundColor: \"#fff\",\n        color: \"rgb(138, 147, 155)\",\n        display: \"grid\",\n        placeItems: \"center\",\n        borderRadius: \"50%\",\n        border: \"1px solid rgb(229, 232, 235)\",\n        cursor: \"pointer\",\n        ...(isHovering\n          ? {\n              color: \"rgb(53, 56, 64)\",\n              boxShadow: \"rgb(4 17 29 / 25%) 0px 0px 8px 0px\",\n            }\n          : {}),\n      }}\n      onClick={onClick}\n      onMouseEnter={onMouseEnter}\n      onMouseLeave={onMouseLeave}\n      onMouseDown={onMouseDown}\n      onMouseUp={onMouseUp}\n    >\n      {!isPlaying ? (\n        <CarbonPlayFilledAlt style={{ width: \"66%\", height: \"66%\" }} />\n      ) : (\n        <CarbonPauseFilled style={{ width: \"66%\", height: \"66%\" }} />\n      )}\n    </button>\n  );\n};\n\nconst VideoPlayer = React.forwardRef<\n  HTMLVideoElement,\n  React.PropsWithChildren<MediaRendererProps>\n>(\n  (\n    {\n      src,\n      alt,\n      poster,\n      requireInteraction,\n      children,\n      style,\n      width,\n      height,\n      controls,\n      ...restProps\n    },\n    ref,\n  ) => {\n    const videoRef = useRef<HTMLVideoElement>(null);\n    const [playing, setPlaying] = useState(!requireInteraction);\n    const [muted, setMuted] = useState(true);\n\n    useEffect(() => {\n      if (videoRef.current) {\n        if (playing) {\n          videoRef.current.play();\n        } else {\n          videoRef.current.pause();\n          videoRef.current.currentTime = 0;\n        }\n      }\n    }, [playing]);\n\n    return (\n      <div style={{ position: \"relative\", ...style }} {...restProps}>\n        <video\n          ref={mergeRefs([videoRef, ref])}\n          src={src ?? undefined}\n          poster={poster ?? undefined}\n          loop\n          playsInline\n          muted={muted}\n          preload={poster ? \"metadata\" : \"auto\"}\n          onCanPlay={() => {\n            if (playing) {\n              videoRef.current?.play();\n            }\n          }}\n          width={width}\n          height={height}\n          controls={controls}\n          style={{\n            height: \"100%\",\n            width: \"100%\",\n            objectFit: \"contain\",\n            zIndex: 1,\n            transition: \"opacity .5s\",\n            opacity: !poster ? 1 : playing ? 1 : 0,\n          }}\n        />\n        {poster && (\n          <img\n            src={poster}\n            style={{\n              objectFit: \"contain\",\n              pointerEvents: \"none\",\n              position: \"absolute\",\n              width: \"100%\",\n              height: \"100%\",\n              zIndex: 2,\n              transition: \"opacity .5s\",\n              opacity: playing ? 0 : 1,\n              top: 0,\n              left: 0,\n              right: 0,\n              bottom: 0,\n            }}\n          />\n        )}\n        <PlayButton\n          onClick={() => {\n            setPlaying((prev) => !prev);\n            setMuted(false);\n          }}\n          isPlaying={playing}\n        />\n      </div>\n    );\n  },\n);\n\nconst AudioPlayer = React.forwardRef<\n  HTMLAudioElement,\n  React.PropsWithChildren<MediaRendererProps>\n>(\n  (\n    {\n      src,\n      alt,\n      poster,\n      requireInteraction,\n      children,\n      style,\n      height,\n      width,\n      controls,\n      ...restProps\n    },\n    ref,\n  ) => {\n    const audioRef = useRef<HTMLAudioElement>(null);\n    const [playing, setPlaying] = useState(false);\n    const [muted, setMuted] = useState(true);\n\n    useEffect(() => {\n      if (audioRef.current) {\n        if (playing) {\n          audioRef.current.play();\n        } else {\n          audioRef.current.pause();\n          audioRef.current.currentTime = 0;\n        }\n      }\n    }, [playing]);\n\n    return (\n      <div style={{ position: \"relative\", ...style }} {...restProps}>\n        {poster ? (\n          <img\n            height={height}\n            width={width}\n            src={poster}\n            style={{\n              height: \"100%\",\n              width: \"100%\",\n              pointerEvents: \"none\",\n              objectFit: \"contain\",\n            }}\n          />\n        ) : (\n          <div\n            style={{\n              width: \"100%\",\n              height: \"100%\",\n              display: \"grid\",\n              placeItems: \"center\",\n              pointerEvents: \"none\",\n              backgroundColor: \"#fff\",\n              color: \"rgb(138, 147, 155)\",\n            }}\n          >\n            <CarbonDocumentAudio style={{ height: \"64px\", width: \"64px\" }} />\n          </div>\n        )}\n\n        <PlayButton\n          onClick={() => {\n            setPlaying((prev) => !prev);\n            setMuted(false);\n          }}\n          isPlaying={playing}\n        />\n        <audio\n          ref={mergeRefs([audioRef, ref])}\n          src={src ?? undefined}\n          loop\n          playsInline\n          muted={muted}\n          style={{\n            position: \"absolute\",\n            opacity: 0,\n            pointerEvents: \"none\",\n            zIndex: -1,\n            visibility: \"hidden\",\n          }}\n        />\n      </div>\n    );\n  },\n);\n\nconst IframePlayer = React.forwardRef<\n  HTMLIFrameElement,\n  React.PropsWithChildren<MediaRendererProps>\n>(\n  (\n    {\n      src,\n      alt,\n      poster,\n      requireInteraction,\n      children,\n      style,\n      height,\n      width,\n      controls,\n      ...restProps\n    },\n    ref,\n  ) => {\n    const { observe, width: elWidth } = useDimensions<HTMLDivElement | null>();\n    const [playing, setPlaying] = useState(!requireInteraction);\n\n    if (elWidth < 300) {\n      return (\n        <div ref={observe}>\n          <LinkPlayer style={style} src={src} alt={alt} {...restProps} />\n        </div>\n      );\n    }\n\n    return (\n      <div\n        style={{ position: \"relative\", ...style }}\n        {...restProps}\n        ref={observe}\n      >\n        <iframe\n          src={playing ? src ?? undefined : undefined}\n          ref={ref}\n          style={{\n            objectFit: \"contain\",\n            zIndex: 1,\n            height: \"100%\",\n            width: \"100%\",\n            transition: \"opacity .5s\",\n            opacity: !poster ? 1 : playing ? 1 : 0,\n          }}\n        />\n        {poster && (\n          <img\n            src={poster}\n            style={{\n              objectFit: \"contain\",\n              pointerEvents: \"none\",\n              position: \"absolute\",\n              width: \"100%\",\n              height: \"100%\",\n              zIndex: 2,\n              transition: \"opacity .5s\",\n              opacity: playing ? 0 : 1,\n              top: 0,\n              left: 0,\n              right: 0,\n              bottom: 0,\n            }}\n          />\n        )}\n        <PlayButton\n          onClick={() => {\n            setPlaying((prev) => !prev);\n          }}\n          isPlaying={playing}\n        />\n      </div>\n    );\n  },\n);\nconst LinkPlayer = React.forwardRef<\n  HTMLAnchorElement,\n  React.PropsWithChildren<MediaRendererProps>\n>(\n  (\n    {\n      src,\n      alt,\n      poster,\n      requireInteraction,\n      children,\n      style,\n      height,\n      width,\n      controls,\n      ...restProps\n    },\n    ref,\n  ) => {\n    return (\n      <div style={{ position: \"relative\", ...style }} {...restProps}>\n        <div\n          style={{\n            width: \"100%\",\n            height: \"100%\",\n            display: \"grid\",\n            placeItems: \"center\",\n            backgroundColor: \"#fff\",\n            color: \"rgb(138, 147, 155)\",\n          }}\n        >\n          <div\n            style={{\n              display: \"flex\",\n              flexDirection: \"column\",\n              gap: \"8px\",\n              alignItems: \"center\",\n              flexWrap: \"nowrap\",\n            }}\n          >\n            <CarbonDocumentUnknown\n              style={{\n                maxWidth: \"128px\",\n                minWidth: \"48px\",\n                width: \"50%\",\n                aspectRatio: \"1\",\n              }}\n            />\n            <a\n              rel=\"noopener noreferrer\"\n              style={{\n                textDecoration: \"underline\",\n                color: \"rgb(138, 147, 155)\",\n              }}\n              href={src ?? undefined}\n              target=\"_blank\"\n              ref={ref as unknown as React.LegacyRef<HTMLAnchorElement>}\n            >\n              {alt || \"File\"}\n            </a>\n          </div>\n        </div>\n      </div>\n    );\n  },\n);\n\n/**\n * This component can be used to render any media type, including image, audio, video, and html files.\n * Its convenient for rendering NFT media files, as these can be a variety of different types.\n * The component falls back to a external link if the media type is not supported.\n *\n * Props: {@link MediaRendererProps}\n *\n * @example\n * We can take a video file hosted on IPFS and render it using this component as follows\n * ```jsx\n * const Component = () => {\n *   return <MediaRenderer\n *     src=\"ipfs://Qmb9ZV5yznE4C4YvyJe8DVFv1LSVkebdekY6HjLVaKmHZi\"\n *     alt=\"A mp4 video\"\n *   />\n * }\n * ```\n *\n * You can try switching out the `src` prop to different types of URLs and media types to explore the possibilities.\n */\nexport const MediaRenderer = React.forwardRef<\n  HTMLMediaElement,\n  React.PropsWithChildren<MediaRendererProps>\n>(\n  (\n    {\n      children,\n      src,\n      poster,\n      alt,\n      requireInteraction = false,\n      style,\n      ...restProps\n    },\n    ref,\n  ) => {\n    const mergedStyle: React.CSSProperties = { objectFit: \"contain\", ...style };\n    const videoOrImageSrc = useResolvedMediaType(src ?? undefined);\n    const possiblePosterSrc = useResolvedMediaType(poster ?? undefined);\n    if (!videoOrImageSrc.mimeType) {\n      return (\n        <img\n          style={mergedStyle}\n          {...restProps}\n          ref={ref as unknown as React.LegacyRef<HTMLImageElement>}\n        />\n      );\n    } else if (videoOrImageSrc.mimeType === \"text/html\") {\n      return (\n        <IframePlayer\n          style={mergedStyle}\n          src={videoOrImageSrc.url}\n          poster={possiblePosterSrc.url}\n          requireInteraction={requireInteraction}\n          {...restProps}\n        />\n      );\n    } else if (shouldRenderVideoTag(videoOrImageSrc.mimeType)) {\n      return (\n        <VideoPlayer\n          style={mergedStyle}\n          src={videoOrImageSrc.url}\n          poster={possiblePosterSrc.url}\n          requireInteraction={requireInteraction}\n          {...restProps}\n        />\n      );\n    } else if (shouldRenderAudioTag(videoOrImageSrc.mimeType)) {\n      return (\n        <AudioPlayer\n          style={mergedStyle}\n          src={videoOrImageSrc.url}\n          poster={possiblePosterSrc.url}\n          requireInteraction={requireInteraction}\n          {...restProps}\n        />\n      );\n    } else if (videoOrImageSrc.mimeType.startsWith(\"image/\")) {\n      return (\n        <img\n          style={mergedStyle}\n          src={videoOrImageSrc.url}\n          alt={alt}\n          ref={ref as unknown as React.LegacyRef<HTMLImageElement>}\n          {...restProps}\n        />\n      );\n    }\n    return (\n      <LinkPlayer\n        style={mergedStyle}\n        src={videoOrImageSrc.url}\n        alt={alt}\n        ref={ref as unknown as React.Ref<HTMLAnchorElement>}\n        {...restProps}\n      />\n    );\n  },\n);\n\nexport interface MediaType {\n  url?: string;\n  mimeType?: string;\n}\n\n/**\n * @param uri - the uri to resolve (can be a url or a ipfs://\\<cid\\>)\n * @returns the fully resolved url + mime type of the media\n *\n * @example\n * Usage with fully formed url:\n * ```jsx\n * const Component = () => {\n *   const resolved = useResolvedMediaType(\"https://example.com/video.mp4\");\n *   console.log(\"mime type\", resolved.data.mimeType);\n *   console.log(\"url\", resolved.data.url);\n *   return null;\n * }\n * ```\n *\n * Usage with ipfs cid:\n * ```jsx\n * const Component = () => {\n *   const resolved = useResolvedMediaType(\"ipfs://QmWATWQ7fVPP2EFGu71UkfnqhYXDYH566qy47CnJDgvsd\");\n *   console.log(\"mime type\", resolved.data.mimeType);\n *   console.log(\"url\", resolved.data.url);\n *   return null;\n * }\n * ```\n */\nexport function useResolvedMediaType(uri?: string) {\n  const resolvedUrl = useMemo(() => resolveIpfsUri(uri), [uri]);\n  const resolvedMimType = useQuery(\n    [\"mime-type\", resolvedUrl],\n    () => resolveMimeType(resolvedUrl),\n    {\n      enabled: !!resolvedUrl,\n    },\n  );\n\n  return {\n    url: resolvedUrl,\n    mimeType: resolvedMimType.data,\n  };\n}\n","import { MediaRenderer, SharedMediaProps } from \"./MediaRenderer\";\nimport { NFTMetadata } from \"@thirdweb-dev/sdk/dist/browser\";\nimport React from \"react\";\n\n/**\n * The props for the {@link ThirdwebNftMedia} component.\n */\nexport interface ThirdwebNftMediaProps extends SharedMediaProps {\n  /**\n   * The NFT metadata of the NFT returned by the thirdweb sdk.\n   */\n  metadata: NFTMetadata;\n}\n\n/**\n *\n * @example\n * ```jsx\n * import { ThirdwebNftMedia, useNFTCollection, useNFT } from \"@thirdweb-dev/react\";\n * export default function NFTCollectionRender() {\n *   const contract = useNFTCollection(<your-contract-address>);\n *   const { data: nft, isLoading } = useNFT(contract, 0);\n *\n *   return (\n *     <div>\n *       {!isLoading && nft ? (\n *         <ThirdwebNftMedia metadata={nft.metadata} />\n *       ) : (\n *         <p>Loading...</p>\n *       )}\n *     </div>\n *   );\n * }\n * ```\n *\n * Use this to get the primary sales recipient of your {@link SmartContract}\n * @param contract - an instance of a {@link SmartContract}\n * @returns the wallet address of the primary sales recipient\n * @beta\n */\nexport const ThirdwebNftMedia = React.forwardRef<\n  HTMLMediaElement,\n  ThirdwebNftMediaProps\n>(({ metadata, ...props }, ref) => {\n  return (\n    <MediaRenderer\n      src={metadata.animation_url || metadata.image}\n      poster={metadata.image}\n      alt={metadata.name}\n      ref={ref}\n      {...props}\n    />\n  );\n});\n","import { useActiveChainId } from \"../../Provider\";\nimport { createCacheKeyWithNetwork } from \"../../utils/cache-keys\";\nimport {\n  QueryFunction,\n  QueryKey,\n  UseQueryOptions,\n  UseQueryResult,\n  useQuery,\n} from \"@tanstack/react-query\";\n\n/** @internal */\nexport function useQueryWithNetwork<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    \"queryKey\" | \"queryFn\"\n  >,\n): UseQueryResult<TData, TError> {\n  const activeChainId = useActiveChainId();\n\n  const mergedOptions: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    \"queryKey\" | \"queryFn\"\n  > = {\n    ...options,\n    enabled: !!(activeChainId && options?.enabled),\n  };\n\n  return useQuery<TQueryFnData, TError, TData, TQueryKey>(\n    createCacheKeyWithNetwork(queryKey, activeChainId) as TQueryKey,\n    queryFn,\n    mergedOptions,\n  );\n}\n","import { useActiveChainId, useSDK } from \"../../Provider\";\nimport { ContractAddress, RequiredParam } from \"../../types\";\nimport {\n  cacheKeys,\n  createCacheKeyWithNetwork,\n  createContractCacheKey,\n} from \"../../utils/cache-keys\";\nimport { useQueryWithNetwork } from \"../query-utils/useQueryWithNetwork\";\nimport {\n  QueryClient,\n  useMutation,\n  useQuery,\n  useQueryClient,\n} from \"@tanstack/react-query\";\nimport type {\n  ContractEvent,\n  EventQueryFilter,\n  ThirdwebSDK,\n} from \"@thirdweb-dev/sdk/dist/browser\";\n// eslint-disable-next-line no-duplicate-imports\nimport { CONTRACTS_MAP, SmartContract } from \"@thirdweb-dev/sdk/dist/browser\";\nimport type {\n  CustomContractMetadata,\n  PublishedMetadata,\n} from \"@thirdweb-dev/sdk/dist/src/schema/contracts/custom\";\nimport { CallOverrides } from \"ethers\";\nimport { useEffect, useMemo } from \"react\";\nimport invariant from \"tiny-invariant\";\n\nasync function fetchContractType(\n  contractAddress: RequiredParam<string>,\n  sdk: RequiredParam<ThirdwebSDK>,\n) {\n  if (!contractAddress || !sdk) {\n    return;\n  }\n  try {\n    return await sdk.resolveContractType(contractAddress);\n  } catch (err) {\n    // expected error, return custom type instead\n    return \"custom\" as const;\n  }\n}\n\nasync function fetchContractCompilerMetadata(\n  contractAddress: RequiredParam<string>,\n  sdk: RequiredParam<ThirdwebSDK>,\n) {\n  if (!contractAddress || !sdk) {\n    return;\n  }\n\n  return await (\n    await sdk.getPublisher()\n  ).fetchCompilerMetadataFromAddress(contractAddress);\n}\nasync function fetchContractTypeAndCompilerMetadata(\n  queryClient: QueryClient,\n  contractAddress?: string,\n  sdk?: ThirdwebSDK,\n) {\n  if (!contractAddress || !sdk) {\n    return;\n  }\n  const contractType = await queryClient.fetchQuery(\n    createCacheKeyWithNetwork(\n      cacheKeys.contract.type(contractAddress),\n      (sdk as any)._chainId,\n    ),\n    () => fetchContractType(contractAddress, sdk),\n    // is immutable, so infinite stale time\n    { staleTime: Infinity },\n  );\n  if (contractType !== \"custom\") {\n    return {\n      contractType,\n      compilerMetadata: null,\n    };\n  }\n  const compilerMetadata = await queryClient.fetchQuery(\n    createCacheKeyWithNetwork(\n      cacheKeys.contract.compilerMetadata(contractAddress),\n      (sdk as any)._chainId,\n    ),\n    () => fetchContractCompilerMetadata(contractAddress, sdk),\n    // is immutable, so infinite stale time\n    { staleTime: Infinity },\n  );\n  return {\n    contractType,\n    compilerMetadata,\n  };\n}\n\nfunction getContractAbi(\n  input: RequiredParam<\n    Awaited<ReturnType<typeof fetchContractTypeAndCompilerMetadata>>\n  >,\n) {\n  if (!input || !input.contractType) {\n    return null;\n  }\n  let contractAbi: PublishedMetadata[\"abi\"] | null = null;\n  if (input.contractType !== \"custom\") {\n    contractAbi = CONTRACTS_MAP[input.contractType].contractAbi;\n  }\n  if (input.contractType === \"custom\" && input.compilerMetadata) {\n    contractAbi = input.compilerMetadata?.abi;\n  }\n\n  return contractAbi;\n}\n\nfunction getContractFromCombinedTypeAndCompilerMetadata(\n  contractAddress: RequiredParam<ContractAddress>,\n  input: RequiredParam<\n    Awaited<ReturnType<typeof fetchContractTypeAndCompilerMetadata>>\n  >,\n  sdk: RequiredParam<ThirdwebSDK>,\n) {\n  if (!input || !sdk || !contractAddress || !input.contractType) {\n    return null;\n  }\n\n  const contractAbi = getContractAbi(input);\n\n  invariant(\n    contractAbi,\n    `could not resolve any ABI for contract${contractAddress}`,\n  );\n  return sdk.getContractFromAbi(contractAddress, contractAbi);\n}\n\n/**\n *\n * @internal\n *\n * @param contractAddress - contract address\n * @returns the contract abi\n */\nexport function useContractAbi(\n  contractAddress: RequiredParam<ContractAddress>,\n) {\n  const sdk = useSDK();\n\n  const contractTypeAndCompilerMetadata =\n    useContractTypeAndCompilerMetadata(contractAddress);\n\n  if (\n    !contractAddress ||\n    !sdk ||\n    !contractTypeAndCompilerMetadata.data?.contractType\n  ) {\n    return {\n      ...contractTypeAndCompilerMetadata,\n      abi: null,\n    };\n  }\n\n  const abi = getContractAbi(contractTypeAndCompilerMetadata.data);\n  return { ...contractTypeAndCompilerMetadata, abi };\n}\n\n/**\n * Use this to get the contract type for a (built-in or custom) contract.\n *\n * @example\n * ```javascript\n * const { data: contractType, isLoading, error } = useContractType(\"{{contract_address}}\");\n * ```\n *\n * @param contractAddress - the address of the deployed contract\n * @returns a response object that includes the contract type of the contract\n * @beta\n */\nexport function useContractType(\n  contractAddress: RequiredParam<ContractAddress>,\n) {\n  const sdk = useSDK();\n  return useQueryWithNetwork(\n    cacheKeys.contract.type(contractAddress),\n    () => fetchContractType(contractAddress, sdk),\n    {\n      enabled: !!sdk && !!contractAddress,\n      // never stale, a contract's publish metadata is immutable\n      staleTime: Infinity,\n    },\n  );\n}\n\n/**\n * Use this to get the publish metadata for a deployed contract.\n *\n * @example\n * ```javascript\n * const { data: compilerMetadata, isLoading, error } = useContractCompilerMetadata(\"{{contract_address}}\");\n * ```\n *\n * @param contractAddress - the address of the deployed contract\n * @returns a response object that includes the published metadata (name, abi, bytecode) of the contract\n * @beta\n */\nexport function useContractCompilerMetadata(\n  contractAddress: RequiredParam<ContractAddress>,\n) {\n  const sdk = useSDK();\n  return useQueryWithNetwork(\n    cacheKeys.contract.compilerMetadata(contractAddress),\n    () => fetchContractCompilerMetadata(contractAddress, sdk),\n    {\n      enabled: !!sdk && !!contractAddress,\n      // never stale, a contract's publish metadata is immutable\n      staleTime: Infinity,\n    },\n  );\n}\n\n/**\n * @internal\n */\nfunction useContractTypeAndCompilerMetadata(\n  contractAddress: RequiredParam<ContractAddress>,\n) {\n  const sdk = useSDK();\n  const queryClient = useQueryClient();\n  return useQueryWithNetwork(\n    cacheKeys.contract.typeAndCompilerMetadata(contractAddress),\n    () =>\n      fetchContractTypeAndCompilerMetadata(queryClient, contractAddress, sdk),\n    {\n      enabled: !!sdk && !!contractAddress,\n      // combination of type and publish metadata is immutable\n      staleTime: Infinity,\n    },\n  );\n}\n\n/**\n * Use this resolve a contract address to a thirdweb (built-in / custom) contract instance.\n *\n * @example\n * ```javascript\n * const { contract, isLoading, error } = useContract(\"{{contract_address}}\");\n * ```\n *\n * @param contractAddress - the address of the deployed contract\n * @returns a response object that includes the contract once it is resolved\n * @beta\n */\nexport function useContract(contractAddress: RequiredParam<ContractAddress>) {\n  const sdk = useSDK();\n\n  const contractTypeAndCompilerMetadata =\n    useContractTypeAndCompilerMetadata(contractAddress);\n\n  if (\n    !contractAddress ||\n    !sdk ||\n    !contractTypeAndCompilerMetadata.data?.contractType\n  ) {\n    return {\n      ...contractTypeAndCompilerMetadata,\n      contract: null,\n    };\n  }\n\n  const contract = getContractFromCombinedTypeAndCompilerMetadata(\n    contractAddress,\n    contractTypeAndCompilerMetadata.data,\n    sdk,\n  );\n  return { ...contractTypeAndCompilerMetadata, contract };\n}\n\n/**\n * Use this to get the contract metadata for a (built-in or custom) contract.\n *\n * @example\n * ```javascript\n * const { data: contractMetadata, isLoading, error } = useContractMetadata(\"{{contract_address}}\");\n * ```\n *\n * @param contractAddress - the address of the deployed contract\n * @returns a response object that includes the contract metadata of the deployed contract\n * @beta\n */\nexport function useContractMetadata(\n  contractAddress: RequiredParam<ContractAddress>,\n) {\n  const sdk = useSDK();\n  const queryClient = useQueryClient();\n  const activeChainId = useActiveChainId();\n  return useQueryWithNetwork(\n    cacheKeys.contract.metadata(contractAddress),\n    async () => {\n      const typeAndCompilerMetadata = await queryClient.fetchQuery(\n        createCacheKeyWithNetwork(\n          cacheKeys.contract.typeAndCompilerMetadata(contractAddress),\n          activeChainId,\n        ),\n        () =>\n          fetchContractTypeAndCompilerMetadata(\n            queryClient,\n            contractAddress,\n            sdk,\n          ),\n        // is immutable, so infinite stale time\n        { staleTime: Infinity },\n      );\n      const contract = getContractFromCombinedTypeAndCompilerMetadata(\n        contractAddress,\n        typeAndCompilerMetadata,\n        sdk,\n      );\n      invariant(contract?.metadata?.get, \"contract metadata is not available\");\n      return (await contract.metadata.get()) as CustomContractMetadata;\n    },\n    {\n      enabled: !!contractAddress || !!sdk,\n    },\n  );\n}\n\n/**\n @internal\n */\nexport function useContractFunctions(\n  contractAddress: RequiredParam<ContractAddress>,\n) {\n  const sdk = useSDK();\n  const queryClient = useQueryClient();\n  const activeChainId = useActiveChainId();\n  return useQueryWithNetwork(\n    cacheKeys.contract.extractFunctions(contractAddress),\n    async () => {\n      const typeAndCompilerMetadata = await queryClient.fetchQuery(\n        createCacheKeyWithNetwork(\n          cacheKeys.contract.typeAndCompilerMetadata(contractAddress),\n          activeChainId,\n        ),\n        () =>\n          fetchContractTypeAndCompilerMetadata(\n            queryClient,\n            contractAddress,\n            sdk,\n          ),\n        // is immutable, so infinite stale time\n        { staleTime: Infinity },\n      );\n      const contract = getContractFromCombinedTypeAndCompilerMetadata(\n        contractAddress,\n        typeAndCompilerMetadata,\n        sdk,\n      );\n      if (contract instanceof SmartContract) {\n        return contract.publishedMetadata.extractFunctions();\n      }\n      return null;\n    },\n    {\n      enabled: !!contractAddress || !!sdk,\n      // functions are based on publish metadata (abi), so this is immutable\n      staleTime: Infinity,\n    },\n  );\n}\n\n/**\n * Use this to get data from a contract read-function call.\n *\n * @example\n * ```javascript\n * const { contract } = useContract(\"{{contract_address}}\");\n * const { data, isLoading, error } = useContractData(contract, \"functionName\", ...args);\n *```\n *\n * @param contract - the contract instance of the contract to call a function on\n * @param functionName - the name of the function to call\n * @param args - The arguments to pass to the function (if any), with optional call arguments as the last parameter\n * @returns a response object that includes the data returned by the function call\n *\n * @beta\n */\nexport function useContractData(\n  contract: RequiredParam<ReturnType<typeof useContract>[\"contract\"]>,\n  functionName: RequiredParam<string>,\n  ...args: unknown[] | [...unknown[], CallOverrides]\n) {\n  const contractAddress = contract?.getAddress();\n  return useQueryWithNetwork(\n    cacheKeys.contract.call(contractAddress, functionName, args),\n    () => {\n      invariant(contract, \"contract must be defined\");\n      invariant(functionName, \"function name must be provided\");\n      return contract.call(functionName, ...args);\n    },\n    {\n      enabled: !!contract && !!functionName,\n    },\n  );\n}\n\n/**\n * Use this to get a function to make a write call to your contract\n *\n * @example\n * ```javascript\n * const { contract } = useContract(\"{{contract_address}}\");\n * const { mutate: myFunction, isLoading, error } = useContractCall(contract, \"myFunction\");\n *\n * // the function can be called as follows:\n * // myFunction([\"param 1\", \"param 2\", ...])\n *```\n *\n * @param contract - the contract instance of the contract to call a function on\n * @param functionName - the name of the function to call\n * @returns a response object that includes the write function to call\n *\n * @beta\n */\nexport function useContractCall(\n  contract: RequiredParam<ReturnType<typeof useContract>[\"contract\"]>,\n  functionName: RequiredParam<string>,\n) {\n  const activeChainId = useActiveChainId();\n  const contractAddress = contract?.getAddress();\n  const queryClient = useQueryClient();\n\n  return useMutation(\n    async (callParams?: unknown[] | [...unknown[], CallOverrides]) => {\n      invariant(contract, \"contract must be defined\");\n      invariant(functionName, \"function name must be provided\");\n      if (!callParams?.length) {\n        return contract.call(functionName);\n      }\n      return contract.call(functionName, ...callParams);\n    },\n    {\n      onSettled: () =>\n        queryClient.invalidateQueries(\n          createCacheKeyWithNetwork(\n            createContractCacheKey(contractAddress),\n            activeChainId,\n          ),\n        ),\n    },\n  );\n}\n\n/**\n * Use this to query (and subscribe) to all events on a contract.\n *\n * @param contract - the contract instance of the contract to call a function on\n * @param options - options incldues the filters ({@link QueryAllEvents}) for the query as well as if you want to subscribe to real-time updates (default: true)\n * @returns a response object that includes the contract events\n * @beta\n */\nexport function useAllContractEvents(\n  contract: RequiredParam<ReturnType<typeof useContract>[\"contract\"]>,\n  options: { queryFilter?: EventQueryFilter; subscribe?: boolean } = {\n    subscribe: true,\n  },\n) {\n  const contractAddress = contract?.getAddress();\n  const queryEnabled = !!contract;\n  const queryClient = useQueryClient();\n  const activeChainId = useActiveChainId();\n\n  const cacheKey = useMemo(\n    () =>\n      createCacheKeyWithNetwork(\n        cacheKeys.contract.events.getAllEvents(contractAddress),\n        activeChainId,\n      ),\n    [contractAddress],\n  );\n  useEffect(() => {\n    // if we're not subscribing or query is not enabled yet we can early exit\n    if (!options.subscribe || !queryEnabled || !contract) {\n      return;\n    }\n\n    const cleanupListener = contract.events.listenToAllEvents(\n      (contractEvent) => {\n        // insert new event to the front of the array (no duplicates, though)\n        queryClient.setQueryData(\n          cacheKey,\n          (oldData: ContractEvent[] | undefined) => {\n            if (!oldData) {\n              return [contractEvent];\n            }\n            const eventIsNotAlreadyInEventsList =\n              oldData.findIndex(\n                (e) =>\n                  e.transaction.transactionHash ===\n                    contractEvent.transaction.transactionHash &&\n                  e.transaction.logIndex === contractEvent.transaction.logIndex,\n              ) === -1;\n            if (eventIsNotAlreadyInEventsList) {\n              return [contractEvent, ...oldData];\n            }\n            return oldData;\n          },\n        );\n      },\n    );\n    // cleanup listener on unmount\n    return cleanupListener;\n  }, [queryEnabled, options.subscribe, cacheKey]);\n\n  return useQuery(\n    cacheKey,\n    () => {\n      invariant(contract, \"contract must be defined\");\n      return contract.events.getAllEvents(options.queryFilter);\n    },\n    {\n      enabled: queryEnabled,\n      // we do not need to re-fetch if we're subscribing\n      refetchOnWindowFocus: !options.subscribe,\n      refetchOnMount: true,\n      refetchOnReconnect: true,\n    },\n  );\n}\n\n/**\n * Use this to query (and subscribe) to a specific event on a contract.\n *\n * @param contract - the contract instance of the contract to call a function on\n * @param options - options incldues the filters ({@link QueryAllEvents}) for the query as well as if you want to subscribe to real-time updates (default: true)\n * @returns a response object that includes the contract events\n * @beta\n */\nexport function useContractEvents(\n  contract: RequiredParam<ReturnType<typeof useContract>[\"contract\"]>,\n  eventName: string,\n  options: { queryFilter?: EventQueryFilter; subscribe?: boolean } = {\n    subscribe: true,\n  },\n) {\n  const contractAddress = contract?.getAddress();\n  const queryEnabled = !!contract && !!eventName;\n  const queryClient = useQueryClient();\n  const activeChainId = useActiveChainId();\n\n  const cacheKey = useMemo(\n    () =>\n      createCacheKeyWithNetwork(\n        cacheKeys.contract.events.getAllEvents(contractAddress),\n        activeChainId,\n      ),\n    [contractAddress],\n  );\n  useEffect(() => {\n    // if we're not subscribing or query is not enabled yet we can early exit\n    if (!options.subscribe || !queryEnabled || !contract || !eventName) {\n      return;\n    }\n\n    const cleanupListener = contract.events.listenToAllEvents(\n      (contractEvent) => {\n        // insert new event to the front of the array (no duplicates, though)\n        queryClient.setQueryData(\n          cacheKey,\n          (oldData: ContractEvent[] | undefined) => {\n            if (!oldData) {\n              return [contractEvent];\n            }\n            const eventIsNotAlreadyInEventsList =\n              oldData.findIndex(\n                (e) =>\n                  e.transaction.transactionHash ===\n                    contractEvent.transaction.transactionHash &&\n                  e.transaction.logIndex === contractEvent.transaction.logIndex,\n              ) === -1;\n            if (eventIsNotAlreadyInEventsList) {\n              return [contractEvent, ...oldData];\n            }\n            return oldData;\n          },\n        );\n      },\n    );\n    // cleanup listener on unmount\n    return cleanupListener;\n  }, [queryEnabled, options.subscribe, cacheKey, eventName]);\n\n  return useQuery(\n    cacheKey,\n    () => {\n      invariant(contract, \"contract must be defined\");\n      return contract.events.getEvents(eventName, options.queryFilter);\n    },\n    {\n      enabled: queryEnabled,\n      // we do not need to re-fetch if we're subscribing\n      refetchOnWindowFocus: !options.subscribe,\n      refetchOnMount: true,\n      refetchOnReconnect: true,\n    },\n  );\n}\n","import { useActiveChainId } from \"../../Provider\";\nimport {\n  AirdropNFTParams,\n  BurnNFTParams,\n  MintNFTParams,\n  MintNFTReturnType,\n  MintNFTSupplyParams,\n  NFT,\n  NFTContract,\n  RequiredParam,\n  TransferNFTParams,\n  WalletAddress,\n  useNFTBalanceParams,\n  useTotalCirculatingSupplyParams,\n} from \"../../types\";\nimport {\n  cacheKeys,\n  invalidateContractAndBalances,\n} from \"../../utils/cache-keys\";\nimport { useQueryWithNetwork } from \"../query-utils/useQueryWithNetwork\";\nimport { useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport {\n  Erc721,\n  Erc1155,\n  QueryAllParams,\n} from \"@thirdweb-dev/sdk/dist/browser\";\nimport { BigNumber, BigNumberish } from \"ethers\";\nimport invariant from \"tiny-invariant\";\n\n/**\n * @internal\n */\nfunction convertResponseToNFTType(\n  contract: NFTContract,\n  metadata: Awaited<ReturnType<typeof contract[\"get\"]>>,\n): NFT<typeof contract> {\n  if (contract instanceof Erc721) {\n    return {\n      type: \"ERC721\",\n      supply: 1,\n      owner: \"\",\n      ...metadata,\n    } as NFT<Erc721>;\n  }\n  return {\n    type: \"ERC1155\",\n    supply: 0,\n    owner: \"\",\n    ...metadata,\n  } as NFT<Erc1155>;\n}\n\n/**\n * @internal\n */\nfunction convertResponseToNFTTypeArray(\n  contract: NFTContract,\n  metadata: Awaited<ReturnType<typeof contract[\"get\"]>>[],\n): NFT<typeof contract>[] {\n  return metadata.map((m) => convertResponseToNFTType(contract, m));\n}\n/** **********************/\n/**     READ  HOOKS     **/\n/** **********************/\n\n/**\n * Use this to get an individual NFT token of your {@link NFTContract}.\n *\n * @example\n * ```javascript\n * const nftDrop = useNFTDrop(<ContractAddress>);\n * const { data: nft, isLoading, error } = useNFT(nftDrop, <tokenId>);\n * ```\n * @example\n * ```javascript\n * const { contract } = useContract(<ContractAddress>);\n * const { data: nft, isLoading, error } = useNFT(contract?.nft, <tokenId>);\n * ```\n *\n * @param contract - an instance of a {@link NFTContract}\n * @param tokenId - the tokenId to look up\n * @returns a response object that includes the metadata for the given tokenId\n * @beta\n */\nexport function useNFT<TContract extends NFTContract>(\n  contract: RequiredParam<TContract>,\n  tokenId: RequiredParam<BigNumberish>,\n) {\n  const contractAddress = contract?.getAddress();\n\n  return useQueryWithNetwork<NFT<TContract>>(\n    cacheKeys.contract.nft.get(contractAddress, tokenId),\n    async () => {\n      invariant(contract, \"No Contract instance provided\");\n      invariant(contract.get, \"Contract instance does not support get\");\n\n      return convertResponseToNFTType(\n        contract,\n        await contract.get(BigNumber.from(tokenId || 0)),\n      );\n    },\n    {\n      enabled: !!contract && tokenId !== undefined,\n    },\n  );\n}\n\n/**\n * Use this to get a list of NFT tokens of your {@link NFTContract}.\n *\n * @example\n * ```javascript\n * const nftDrop = useNFTDrop(<ContractAddress>);\n * const { data: nfts, isLoading, error } = useNFTs(nftDrop, { start: 0, count: 100 });\n * ```\n * @example\n * ```javascript\n * const { contract } = useContract(<ContractAddress>);\n * const { data: nfts, isLoading, error } = useNFTs(contract?.nft, { start: 0, count: 100 });\n * ```\n *\n * @param contract - an instance of a {@link NFTContract}\n * @param queryParams - query params to pass to the query for the sake of pagination\n * @returns a response object that includes an array of NFTs\n * @beta\n */\nexport function useNFTs<TContract extends NFTContract>(\n  contract: RequiredParam<TContract>,\n  queryParams?: QueryAllParams,\n) {\n  const contractAddress = contract?.getAddress();\n  return useQueryWithNetwork<NFT<TContract>[]>(\n    cacheKeys.contract.nft.query.all(contractAddress, queryParams),\n    async () => {\n      invariant(contract, \"No Contract instance provided\");\n      invariant(\n        contract.query?.all,\n        \"Contract instance does not support query.all\",\n      );\n\n      return convertResponseToNFTTypeArray(\n        contract,\n        await contract.query.all(queryParams),\n      );\n    },\n    {\n      enabled: !!contract || !contractAddress,\n      keepPreviousData: true,\n    },\n  );\n}\n\n/**\n * Use this to get a the total (minted) supply of your {@link NFTContract}.\n *\n *  * @example\n * ```javascript\n * const nftDrop = useNFTDrop(<ContractAddress>);\n * const { data: totalSupply, isLoading, error } = useNFTSupply(nftDrop);\n * ```\n * @example\n * ```javascript\n * const { contract } = useContract(<ContractAddress>);\n * const { data: totalSupply, isLoading, error } = useNFTSupply(contract?.nft);\n * ```\n *\n * @param contract - an instance of a {@link NFTContract}\n * @returns a response object that incudes the total minted supply\n * @beta\n */\nexport function useTotalCirculatingSupply<TContract extends NFTContract>(\n  ...[contract, tokenId]: useTotalCirculatingSupplyParams<TContract>\n) {\n  const contractAddress = contract?.getAddress();\n  return useQueryWithNetwork(\n    cacheKeys.contract.nft.query.totalCirculatingSupply(contractAddress),\n    () => {\n      invariant(contract, \"No Contract instance provided\");\n      if (contract instanceof Erc721) {\n        invariant(\n          contract?.query?.totalCirculatingSupply,\n          \"Contract instance does not support query.totalCirculatingSupply\",\n        );\n        return contract.query.totalCirculatingSupply();\n      }\n      invariant(\n        contract.query?.totalCirculatingSupply,\n        \"Contract instance does not support query.getTotalCount\",\n      );\n      invariant(tokenId, \"No tokenId provided\");\n      return contract.query.totalCirculatingSupply(tokenId);\n    },\n    {\n      enabled: !!contract,\n    },\n  );\n}\n\n/**\n * Use this to get a the number of tokens in your {@link NFTContract}.\n *\n * @remarks The `total count` and `total supply` are the same for {@link ERC721} based contracts.\n * For {@link ERC1155} the `total count` is the number of NFTs that exist on the contract, **not** the sum of all supply of each token. (Since ERC1155 can have multiple owners per token.)\n *\n * @example\n * ```javascript\n * const nftDrop = useNFTDrop(<ContractAddress>);\n * const { data: totalCount, isLoading, error } = useTotalCount(nftDrop);\n * ```\n * @example\n * ```javascript\n * const { contract } = useContract(<ContractAddress>);\n * const { data: totalCount, isLoading, error } = useTotalCount(contract?.nft);\n * ```\n *\n * @param contract - an instance of a {@link NFTContract}\n * @returns a response object that incudes the total number of tokens in the contract\n * @beta\n */\nexport function useTotalCount(contract: RequiredParam<NFTContract>) {\n  const contractAddress = contract?.getAddress();\n  return useQueryWithNetwork(\n    cacheKeys.contract.nft.query.totalCount(contractAddress),\n    () => {\n      invariant(contract, \"No Contract instance provided\");\n      if (contract instanceof Erc721) {\n        invariant(\n          contract?.query?.totalCirculatingSupply,\n          \"Contract instance does not support query.totalCirculatingSupply\",\n        );\n        return contract.query.totalCirculatingSupply();\n      }\n      invariant(\n        contract.query?.totalCount,\n        \"Contract instance does not support query.totalCount\",\n      );\n      return contract.query.totalCount();\n    },\n    {\n      enabled: !!contract,\n    },\n  );\n}\n\n/**\n * Use this to get a the owned NFTs for a specific {@link NFTContract} and wallet address.\n *\n * @example\n * ```javascript\n * const nftDrop = useNFTDrop(<ContractAddress>);\n * const { data: ownedNFTs, isLoading, error } = useOwnedNFTs(nftDrop, <OwnerWalletAddress>);\n * ```\n * @example\n * ```javascript\n * const { contract } = useContract(<ContractAddress>);\n * const { data: ownedNFTs, isLoading, error } = useOwnedNFTs(contract?.nft, <OwnerWalletAddress>);\n * ```\n *\n * @param contract - an instance of a {@link NFTContract}\n * @param ownerWalletAddress - the wallet adress to get owned tokens for\n * @returns a response object that includes the list of owned tokens\n * @beta\n */\nexport function useOwnedNFTs<TContract extends NFTContract>(\n  contract: RequiredParam<TContract>,\n  ownerWalletAddress: RequiredParam<WalletAddress>,\n) {\n  const contractAddress = contract?.getAddress();\n  return useQueryWithNetwork<NFT<TContract>[]>(\n    cacheKeys.contract.nft.query.owned.all(contractAddress, ownerWalletAddress),\n    async () => {\n      invariant(contract, \"No Contract instance provided\");\n      if (contract instanceof Erc721) {\n        invariant(\n          contract.query?.owned?.all,\n          \"Contract instance does not support query.owned.all\",\n        );\n        return convertResponseToNFTTypeArray(\n          contract,\n          await contract.query.owned.all(ownerWalletAddress),\n        );\n      }\n      invariant(\n        contract.query?.owned,\n        \"Contract instance does not support query.owned\",\n      );\n      return convertResponseToNFTTypeArray(\n        contract,\n        await contract.query.owned(ownerWalletAddress),\n      );\n    },\n    {\n      enabled: !!contract && !!ownerWalletAddress,\n    },\n  );\n}\n\n/**\n * Use this to get a the total balance of a {@link NFTContract} and wallet address.\n *\n *  @example\n * ```javascript\n * const nftDrop = useNFTDrop(<ContractAddress>);\n * const { data: ownerBalance, isLoading, error } = useNFTBalance(nftDrop, <OwnerWalletAddress>);\n * ```\n * @example\n * ```javascript\n * const { contract } = useContract(<ContractAddress>);\n * const { data: ownerBalance, isLoading, error } = useNFTBalance(contract?.nft, <OwnerWalletAddress>);\n * ```\n *\n * @param contract - an instance of a {@link NFTContract}\n * @param ownerWalletAddress - the wallet adress to check the balance of\n * @returns a response object that includes the total balance of the owner\n * @beta\n */\nexport function useNFTBalance<TContract extends NFTContract>(\n  ...[contract, ownerWalletAddress, tokenId]: useNFTBalanceParams<TContract>\n) {\n  const contractAddress = contract?.getAddress();\n  return useQueryWithNetwork(\n    cacheKeys.contract.nft.balanceOf(\n      contractAddress,\n      ownerWalletAddress,\n      tokenId,\n    ),\n    () => {\n      invariant(contract, \"No Contract instance provided\");\n      invariant(\n        contract.balanceOf,\n        \"Contract instance does not support balanceOf\",\n      );\n      invariant(ownerWalletAddress, \"No owner wallet address provided\");\n      if (contract instanceof Erc1155) {\n        invariant(tokenId, \"No tokenId provided\");\n        return contract.balanceOf(ownerWalletAddress, tokenId);\n      }\n      return contract.balanceOf(ownerWalletAddress);\n    },\n    {\n      enabled: !!contract && !!ownerWalletAddress,\n    },\n  );\n}\n\n/** **********************/\n/**     WRITE HOOKS     **/\n/** **********************/\n\n/**\n * Use this to mint a new NFT on your {@link NFTContract}\n *\n * @example\n * ```jsx\n * const Component = () => {\n *   const nftDrop = useNFTDrop(<ContractAddress>);\n *   const {\n *     mutate: mintNft,\n *     isLoading,\n *     error,\n *   } = useMintNFT(nftDrop);\n *\n *   if (error) {\n *     console.error(\"failed to mint nft\", error);\n *   }\n *\n *   return (\n *     <button\n *       disabled={isLoading}\n *       onClick={() => mintNft({ name: \"My awesome NFT!\", to: \"0x...\" })}\n *     >\n *       Mint!\n *     </button>\n *   );\n * };\n * ```\n * @example\n * ```jsx\n * const Component = () => {\n *   const { contract } = useContract(<ContractAddress>);\n *   const {\n *     mutate: mintNft,\n *     isLoading,\n *     error,\n *   } = useMintNFT(contract?.nft);\n *\n *   if (error) {\n *     console.error(\"failed to mint nft\", error);\n *   }\n *\n *   return (\n *     <button\n *       disabled={isLoading}\n *       onClick={() => mintNft({ name: \"My awesome NFT!\", to: \"0x...\" })}\n *     >\n *       Mint!\n *     </button>\n *   );\n * };\n * ```\n *\n * @param contract - an instance of a {@link NFTContract}\n * @returns a mutation object that can be used to mint a new NFT token to the connected wallet\n * @beta\n */\nexport function useMintNFT<TContract extends NFTContract>(\n  contract: RequiredParam<TContract>,\n) {\n  const activeChainId = useActiveChainId();\n  const contractAddress = contract?.getAddress();\n  const queryClient = useQueryClient();\n\n  return useMutation(\n    async (data: MintNFTParams<TContract>) => {\n      invariant(data.to, 'No \"to\" address provided');\n      invariant(contract?.mint?.to, \"contract does not support mint.to\");\n      if (contract instanceof Erc1155) {\n        invariant(\"supply\" in data, \"supply not provided\");\n        const { to, metadata, supply } = data;\n        return (await contract.mint.to(to, {\n          metadata,\n          supply: BigNumber.from(supply || 1),\n        })) as MintNFTReturnType<TContract>;\n      }\n      return (await contract.mint.to(\n        data.to,\n        data.metadata,\n      )) as MintNFTReturnType<TContract>;\n    },\n    {\n      onSettled: () =>\n        invalidateContractAndBalances(\n          queryClient,\n          contractAddress,\n          activeChainId,\n        ),\n    },\n  );\n}\n\n/**\n * Use this to mint a new NFT on your {@link NFTContract}\n *\n * @example\n * ```jsx\n * const Component = () => {\n *   const nftDrop = useNFTDrop(<ContractAddress>);\n *   const {\n *     mutate: mintNftSupply,\n *     isLoading,\n *     error,\n *   } = useMintNFTSupply(nftDrop);\n *\n *   if (error) {\n *     console.error(\"failed to mint additional supply\", error);\n *   }\n *\n *   return (\n *     <button\n *       disabled={isLoading}\n *       onClick={() => mintNftSupply({ tokenId: 0, additionalSupply: 100, to: \"0x...\"})}\n *     >\n *       Mint Additional Supply!\n *     </button>\n *   );\n * };\n * ```\n * @example\n * ```jsx\n * const Component = () => {\n *   const { contract } = useContract(<ContractAddress>);\n *   const {\n *     mutate: mintNftSupply,\n *     isLoading,\n *     error,\n *   } = useMintNFTSupply(contract?.nft);\n *\n *   if (error) {\n *     console.error(\"failed to mint additional supply\", error);\n *   }\n *\n *   return (\n *     <button\n *       disabled={isLoading}\n *       onClick={() => mintNftSupply({ tokenId: 0, additionalSupply: 100, to: \"0x...\"})}\n *     >\n *       Mint Additional Supply!\n *     </button>\n *   );\n * };\n * ```\n *\n * @param contract - an instance of a {@link Erc1155}\n * @returns a mutation object that can be used to mint a more supply of a token id to the provided wallet\n * @beta\n */\nexport function useMintNFTSupply(contract: Erc1155) {\n  const activeChainId = useActiveChainId();\n  const contractAddress = contract?.getAddress();\n  const queryClient = useQueryClient();\n\n  return useMutation(\n    async (data: MintNFTSupplyParams) => {\n      invariant(data.to, 'No \"to\" address provided');\n      invariant(\n        contract?.mint?.additionalSupplyTo,\n        \"contract does not support mint.additionalSupplyTo\",\n      );\n\n      invariant(\"tokenId\" in data, \"tokenId not provided\");\n      invariant(\"additionalSupply\" in data, \"additionalSupply not provided\");\n      const { to, tokenId, additionalSupply } = data;\n      return await contract.mint.additionalSupplyTo(\n        to,\n        tokenId,\n        additionalSupply,\n      );\n    },\n    {\n      onSettled: () =>\n        invalidateContractAndBalances(\n          queryClient,\n          contractAddress,\n          activeChainId,\n        ),\n    },\n  );\n}\n\n/**\n * Use this to transfer tokens on your {@link NFTContract}\n *\n * @example\n * ```jsx\n * const Component = () => {\n *   const nftDrop = useNFTDrop(<ContractAddress>);\n *   const {\n *     mutate: transferNFT,\n *     isLoading,\n *     error,\n *   } = useTransferNFT(nftDrop);\n *\n *   if (error) {\n *     console.error(\"failed to transfer nft\", error);\n *   }\n *\n *   return (\n *     <button\n *       disabled={isLoading}\n *       onClick={() => transferNFT({ to: \"0x...\", tokenId: 2 })}\n *     >\n *       Transfer NFT!\n *     </button>\n *   );\n * };\n * ```\n * @example\n * ```jsx\n * const Component = () => {\n *   const { contract } = useContract(<ContractAddress>);\n *   const {\n *     mutate: transferNFT,\n *     isLoading,\n *     error,\n *   } = useTransferNFT(contract?.nft);\n *\n *   if (error) {\n *     console.error(\"failed to transfer nft\", error);\n *   }\n *\n *   return (\n *     <button\n *       disabled={isLoading}\n *       onClick={() => transferNFT({ to: \"0x...\", tokenId: 2 })}\n *     >\n *       Transfer\n *     </button>\n *   );\n * };\n * ```\n *\n * @param contract - an instance of a {@link NFTContract}\n * @returns a mutation object that can be used to transfer NFTs\n * @beta\n */\nexport function useTransferNFT<TContract extends NFTContract>(\n  contract: RequiredParam<TContract>,\n) {\n  const activeChainId = useActiveChainId();\n  const contractAddress = contract?.getAddress();\n  const queryClient = useQueryClient();\n\n  return useMutation(\n    (data: TransferNFTParams<TContract>) => {\n      invariant(contract?.transfer, \"contract does not support transfer\");\n      if (contract instanceof Erc1155) {\n        invariant(\"amount\" in data, \"amount not provided\");\n        return contract.transfer(data.to, data.tokenId, data.amount);\n      }\n\n      return contract.transfer(data.to, data.tokenId);\n    },\n    {\n      onSettled: () =>\n        invalidateContractAndBalances(\n          queryClient,\n          contractAddress,\n          activeChainId,\n        ),\n    },\n  );\n}\n\n/**\n * Use this to transfer tokens on your {@link Erc1155}\n *\n * @example\n * ```jsx\n * const Component = () => {\n *   const editionDrop = useEditionDrop(<ContractAddress>);\n *   const {\n *     mutate: airdropNFT,\n *     isLoading,\n *     error,\n *   } = useAirdropNFT(editionDrop);\n *\n *   if (error) {\n *     console.error(\"failed to transfer batch NFTs\", error);\n *   }\n *\n *   return (\n *     <button\n *       disabled={isLoading}\n *       onClick={() => airdropNFT({\n *          tokenId: 2,\n *          addresses: [{ address: \"0x...\", quantity: 2 }, { address: \"0x...\", quantity: 4 } }]\n *       )}\n *     >\n *       Airdrop NFT\n *     </button>\n * };\n * ```\n * @example\n * ```jsx\n * const Component = () => {\n *   const { contract } = useContract(<ContractAddress>);\n *   const {\n *     mutate: airdropNFT,\n *     isLoading,\n *     error,\n *   } = useAirdropNFT(contract?.nft);\n *\n *   if (error) {\n *     console.error(\"failed to transfer batch NFTs\", error);\n *   }\n *\n *   return (\n *     <button\n *       disabled={isLoading}\n *       onClick={() => airdropNFT({\n *          tokenId: 2,\n *          addresses: [{ address: \"0x...\", quantity: 2 }, { address: \"0x...\", quantity: 4 } }]\n *       )}\n *     >\n *       Airdrop NFT\n *     </button>\n *   );\n * };\n * ```\n *\n * @param contract - an instance of a {@link Erc1155}\n * @returns a mutation object that can be used to transfer batch NFTs\n * @beta\n */\nexport function useAirdropNFT(contract: Erc1155) {\n  const activeChainId = useActiveChainId();\n  const contractAddress = contract?.getAddress();\n  const queryClient = useQueryClient();\n\n  return useMutation(\n    ({ tokenId, addresses }: AirdropNFTParams) => {\n      invariant(contract?.airdrop, \"contract does not support airdrop\");\n\n      return contract.airdrop(tokenId, addresses);\n    },\n    {\n      onSettled: () =>\n        invalidateContractAndBalances(\n          queryClient,\n          contractAddress,\n          activeChainId,\n        ),\n    },\n  );\n}\n\n/** **********************/\n/**     WRITE HOOKS     **/\n/** **********************/\n\n/**\n * Use this to burn an NFT on your {@link NFTContract}\n *\n * @example\n * ```jsx\n * const Component = () => {\n *   const nftDrop = useNFTDrop(<ContractAddress>);\n *   const {\n *     mutate: burnNft,\n *     isLoading,\n *     error,\n *   } = useBurnNFT(nftDrop);\n *\n *   if (error) {\n *     console.error(\"failed to burn nft\", error);\n *   }\n *\n *   return (\n *     <button\n *       disabled={isLoading}\n *       onClick={() => burnNft({ tokenId: 0 })}\n *     >\n *       Burn!\n *     </button>\n *   );\n * };\n * ```\n * @example\n * ```jsx\n * const Component = () => {\n *   const { contract } = useContract(<ContractAddress>);\n *   const {\n *     mutate: burnNft,\n *     isLoading,\n *     error,\n *   } = useBurnNFT(contract?.nft);\n *\n *   if (error) {\n *     console.error(\"failed to burn nft\", error);\n *   }\n *\n *   return (\n *     <button\n *       disabled={isLoading}\n *       onClick={() => burnNft({ tokenId: 0 })}\n *     >\n *       Burn!\n *     </button>\n *   );\n * };\n * ```\n *\n * @param contract - an instance of a {@link NFTContract}\n * @returns a mutation object that can be used to burn an NFT token from the connected wallet\n * @beta\n */\nexport function useBurnNFT<TContract extends NFTContract>(\n  contract: RequiredParam<TContract>,\n) {\n  const activeChainId = useActiveChainId();\n  const contractAddress = contract?.getAddress();\n  const queryClient = useQueryClient();\n\n  return useMutation(\n    async (data: BurnNFTParams<TContract>) => {\n      invariant(data.tokenId, \"No tokenId provided\");\n      invariant(contract?.burn, \"contract does not support burn\");\n      if (contract instanceof Erc1155) {\n        invariant(\"amount\" in data, \"amount not provided\");\n        const { tokenId, amount } = data;\n        return await contract.burn.tokens(tokenId, amount);\n      }\n      const { tokenId } = data;\n      return await contract.burn.token(tokenId);\n    },\n    {\n      onSettled: () =>\n        invalidateContractAndBalances(\n          queryClient,\n          contractAddress,\n          activeChainId,\n        ),\n    },\n  );\n}\n","import { useActiveChainId } from \"../../Provider\";\nimport {\n  ClaimNFTParams,\n  ClaimNFTReturnType,\n  DropContract,\n  NFTContract,\n  RequiredParam,\n} from \"../../types\";\nimport {\n  cacheKeys,\n  invalidateContractAndBalances,\n} from \"../../utils/cache-keys\";\nimport { useQueryWithNetwork } from \"../query-utils/useQueryWithNetwork\";\nimport { useNFTs } from \"./nft\";\nimport { useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport {\n  Erc1155,\n  NFTDrop,\n  NFTMetadataInput,\n  QueryAllParams,\n  SignatureDrop,\n  UploadProgressEvent,\n} from \"@thirdweb-dev/sdk/dist/browser\";\nimport invariant from \"tiny-invariant\";\n\n/** **********************/\n/**       READ HOOKS    **/\n/** **********************/\n\n/**\n * Use this to get a list of *unclaimed* NFT tokens of your ERC721 Drop contract.\n *\n * @example\n * ```javascript\n * const { data: unclaimedNfts, isLoading, error } = useUnclaimedNFTs(<YourERC721DropContractInstance>, { start: 0, count: 100 });\n * ```\n *\n * @param contract - an instance of a contract that extends the Erc721 spec (nft drop, custom contract that follows the Erc721 & drop spec)\n * @param queryParams - query params to pass to the query for the sake of pagination\n * @returns a response object that includes an array of NFTs that are unclaimed\n * @beta\n */\nexport function useUnclaimedNFTs(\n  contract: RequiredParam<NFTDrop>,\n  queryParams?: QueryAllParams,\n) {\n  const contractAddress = contract?.getAddress();\n  return useQueryWithNetwork(\n    cacheKeys.contract.nft.drop.getAllUnclaimed(contractAddress, queryParams),\n    () => {\n      invariant(contract, \"No Contract instance provided\");\n      invariant(\n        contract.getAllUnclaimed,\n        \"Contract instance does not support getAllUnclaimed\",\n      );\n      return contract.getAllUnclaimed(queryParams);\n    },\n    { enabled: !!contract },\n  );\n}\n\n/**\n * Use this to get a list of *claimed* (minted) NFT tokens of your ERC721 Drop contract.\n *\n * @remarks Equivalent to using {@link useNFTs}.\n *\n * @example\n * ```javascript\n * const { data: claimedNFTs, isLoading, error } = useClaimedNFTs(<YourERC721DropContractInstance>, { start: 0, count: 100 });\n * ```\n *\n * @param contract - an instance of a {@link DropContract}\n * @param queryParams - query params to pass to the query for the sake of pagination\n * @returns a response object that includes an array of NFTs that are claimed\n * @beta\n */\nexport function useClaimedNFTs(\n  contract: RequiredParam<DropContract>,\n  queryParams?: QueryAllParams,\n) {\n  return useNFTs(contract, queryParams);\n}\n/**\n *\n * @param contract - an instance of a {@link NFTDrop}\n * @returns a response object that includes the number of NFTs that are unclaimed\n */\nexport function useUnclaimedNFTSupply(\n  contract: RequiredParam<NFTDrop | SignatureDrop>,\n) {\n  const contractAddress = contract?.getAddress();\n  return useQueryWithNetwork(\n    cacheKeys.contract.nft.drop.totalUnclaimedSupply(contractAddress),\n    () => {\n      invariant(contract, \"No Contract instance provided\");\n\n      invariant(\n        contract.totalUnclaimedSupply,\n        \"Contract instance does not support totalUnclaimedSupply\",\n      );\n      return contract.totalUnclaimedSupply();\n    },\n    { enabled: !!contract },\n  );\n}\n\n/**\n *\n * @param contract - an instance of a {@link DropContract}\n * @returns a response object that includes the number of NFTs that are claimed\n */\nexport function useClaimedNFTSupply(contract: RequiredParam<DropContract>) {\n  const contractAddress = contract?.getAddress();\n  return useQueryWithNetwork(\n    cacheKeys.contract.nft.drop.totalClaimedSupply(contractAddress),\n    () => {\n      invariant(contract, \"No Contract instance provided\");\n      if (contract instanceof Erc1155) {\n        return contract.getTotalCount();\n      }\n      invariant(\n        contract.totalClaimedSupply,\n        \"Contract instance does not support totalClaimedSupply\",\n      );\n      return contract.totalClaimedSupply();\n    },\n    { enabled: !!contract },\n  );\n}\n\n/** **********************/\n/**     WRITE HOOKS     **/\n/** **********************/\n/**\n * Use this to claim a NFT on your {@link DropContract}\n *\n * @example\n * ```jsx\n * const Component = () => {\n *   const {\n *     mutate: claimNft,\n *     isLoading,\n *     error,\n *   } = useClaimNFT(DropContract);\n *\n *   if (error) {\n *     console.error(\"failed to claim nft\", error);\n *   }\n *\n *   return (\n *     <button\n *       disabled={isLoading}\n *       onClick={() => claimNft({ to: \"0x...\", quantity: 1 })}\n *     >\n *       Claim NFT!\n *     </button>\n *   );\n * };\n * ```\n *\n * @param contract - an instance of a {@link DropContract}\n * @returns a mutation object that can be used to claim a NFT to the wallet specificed in the params\n * @beta\n */\nexport function useClaimNFT<TContract extends DropContract>(\n  contract: RequiredParam<TContract>,\n) {\n  const activeChainId = useActiveChainId();\n  const contractAddress = contract?.getAddress();\n  const queryClient = useQueryClient();\n\n  return useMutation(\n    async (data: ClaimNFTParams<TContract>) => {\n      invariant(data.to, 'No \"to\" address provided');\n      invariant(contract?.claimTo, \"contract does not support claimTo\");\n      if (contract instanceof Erc1155) {\n        invariant(\"tokenId\" in data, \"tokenId not provided\");\n        const { to, tokenId, quantity } = data;\n        return (await contract.claimTo(\n          to,\n          tokenId,\n          quantity,\n          data.checkERC20Allowance,\n        )) as ClaimNFTReturnType<TContract>;\n      }\n      return (await contract.claimTo(\n        data.to,\n        data.quantity,\n        data.checkERC20Allowance,\n      )) as ClaimNFTReturnType<TContract>;\n    },\n    {\n      onSettled: () =>\n        invalidateContractAndBalances(\n          queryClient,\n          contractAddress,\n          activeChainId,\n        ),\n    },\n  );\n}\n\n/**\n * Use this to lazy mint a batch of NFTs on your {@link DropContract}\n *\n * @param contract - an instance of a {@link NFTContract} with the drop extension\n * @param onProgress - an optional callback that will be called with the progress of the upload\n * @returns a mutation object that can be used to lazy mint a batch of NFTs\n * @beta\n */\nexport function useLazyMint<TContract extends NFTContract>(\n  contract: RequiredParam<TContract>,\n  onProgress?: (progress: UploadProgressEvent) => void,\n) {\n  const activeChainId = useActiveChainId();\n  const contractAddress = contract?.getAddress();\n  const queryClient = useQueryClient();\n\n  return useMutation(\n    async (data: { metadatas: NFTMetadataInput[] }) => {\n      invariant(\n        contract?.drop?.lazyMint,\n        \"contract does not support drop.lazyMint\",\n      );\n      let options;\n      if (onProgress) {\n        options = {\n          onProgress,\n        };\n      }\n      return await contract.drop.lazyMint(data.metadatas, options);\n    },\n    {\n      onSettled: () =>\n        invalidateContractAndBalances(\n          queryClient,\n          contractAddress,\n          activeChainId,\n        ),\n    },\n  );\n}\n","import { useActiveChainId } from \"../../Provider\";\nimport { BuyNowParams, MakeBidParams, RequiredParam } from \"../../types\";\nimport {\n  cacheKeys,\n  invalidateContractAndBalances,\n} from \"../../utils/cache-keys\";\nimport { useQueryWithNetwork } from \"../query-utils/useQueryWithNetwork\";\nimport { useAddress } from \"../useAddress\";\nimport { useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport type {\n  Marketplace,\n  MarketplaceFilter,\n  NewAuctionListing,\n  NewDirectListing,\n} from \"@thirdweb-dev/sdk/dist/browser\";\n// eslint-disable-next-line no-duplicate-imports\nimport { ListingType } from \"@thirdweb-dev/sdk/dist/browser\";\nimport { BigNumber, BigNumberish } from \"ethers\";\nimport invariant from \"tiny-invariant\";\n\n/** **********************/\n/**     READ  HOOKS     **/\n/** **********************/\n\n/**\n * Use this to get a specific listing from the marketplace.\n *\n * @example\n * ```javascript\n * const { data: listing, isLoading, error } = useListing(<YourMarketplaceContractInstance>, <listingId>);\n * ```\n *\n * @param contract - an instance of a marketplace contract\n * @param listingId - the listing id to check\n * @returns a response object that includes an array of listings\n * @beta\n */\nexport function useListing(\n  contract: RequiredParam<Marketplace>,\n  listingId: RequiredParam<BigNumberish>,\n) {\n  const contractAddress = contract?.getAddress();\n  return useQueryWithNetwork(\n    cacheKeys.contract.marketplace.getListing(contractAddress, listingId),\n    () => {\n      invariant(contract, \"No Contract instance provided\");\n      return contract.getListing(BigNumber.from(listingId || 0));\n    },\n    {\n      enabled: !!contract || !contractAddress,\n      keepPreviousData: true,\n    },\n  );\n}\n\n/**\n * Use this to get a list all listings from your marketplace contract.\n *\n * @example\n * ```javascript\n * const { data: listings, isLoading, error } = useListings(<YourMarketplaceContractInstance>, { start: 0, count: 100 });\n * ```\n *\n * @param contract - an instance of a marketplace contract\n * @param filter - filter to pass to the query for the sake of pagination & filtering\n * @returns a response object that includes an array of listings\n * @beta\n */\nexport function useListings(\n  contract: RequiredParam<Marketplace>,\n  filter?: MarketplaceFilter,\n) {\n  const contractAddress = contract?.getAddress();\n  return useQueryWithNetwork(\n    cacheKeys.contract.marketplace.getAllListings(contractAddress, filter),\n    () => {\n      invariant(contract, \"No Contract instance provided\");\n      return contract.getAllListings(filter);\n    },\n    {\n      enabled: !!contract || !contractAddress,\n      keepPreviousData: true,\n    },\n  );\n}\n\n/**\n * Use this to get a list active listings from your marketplace contract.\n *\n * @example\n * ```javascript\n * const { data: listings, isLoading, error } = useActiveListings(<YourMarketplaceContractInstance>, { seller: \"0x...\", tokenContract: \"0x...\", tokenId: 1, start: 0, count: 100 });\n * ```\n *\n * @param contract - an instance of a marketplace contract\n * @param filter - filter to pass to the query for the sake of pagination & filtering\n * @returns a response object that includes an array of listings\n * @beta\n */\nexport function useActiveListings(\n  contract: RequiredParam<Marketplace>,\n  filter?: MarketplaceFilter,\n) {\n  const contractAddress = contract?.getAddress();\n  return useQueryWithNetwork(\n    cacheKeys.contract.marketplace.getActiveListings(contractAddress, filter),\n    () => {\n      invariant(contract, \"No Contract instance provided\");\n\n      return contract.getActiveListings(filter);\n    },\n    {\n      enabled: !!contract || !contractAddress,\n      keepPreviousData: true,\n    },\n  );\n}\n\n/**\n * Use this to get a the winning bid for an auction listing from your marketplace contract.\n *\n * @example\n * ```javascript\n * const { data: winningBid, isLoading, error } = useWinningBid(<YourMarketplaceContractInstance>, <listingId>);\n * ```\n *\n * @param contract - an instance of a marketplace contract\n * @param listingId - the listing id to check\n * @returns a response object that includes the {@link Offer} that is winning the auction\n * @beta\n */\nexport function useWinningBid(\n  contract: RequiredParam<Marketplace>,\n  listingId: RequiredParam<BigNumberish>,\n) {\n  const contractAddress = contract?.getAddress();\n  return useQueryWithNetwork(\n    cacheKeys.contract.marketplace.auction.getWinningBid(\n      contractAddress,\n      listingId,\n    ),\n    () => {\n      invariant(contract, \"No Contract instance provided\");\n      return contract.auction.getWinningBid(BigNumber.from(listingId || 0));\n    },\n    {\n      enabled: !!contract && listingId !== undefined,\n    },\n  );\n}\n\n/**\n * Use this to get the winner of an auction listing from your marketplace contract.\n *\n * @example\n * ```javascript\n * const { data: auctionWinner, isLoading, error } = useAuctionWinner(<YourMarketplaceContractInstance>, <listingId>);\n * ```\n *\n * @param contract - an instance of a marketplace contract\n * @param listingId - the listing id to check\n * @returns a response object that includes the address of the winner of the auction or undefined if there is no winner yet\n * @beta\n */\nexport function useAuctionWinner(\n  contract: RequiredParam<Marketplace>,\n  listingId: RequiredParam<BigNumberish>,\n) {\n  const contractAddress = contract?.getAddress();\n  return useQueryWithNetwork(\n    cacheKeys.contract.marketplace.auction.getWinner(\n      contractAddress,\n      listingId,\n    ),\n    async () => {\n      invariant(contract, \"No Contract instance provided\");\n      let winner: string | undefined;\n      try {\n        winner = await contract.auction.getWinner(\n          BigNumber.from(listingId || 0),\n        );\n      } catch (err) {\n        if (!(err as Error)?.message?.includes(\"Could not find auction\")) {\n          throw err;\n        }\n      }\n      return winner;\n    },\n    {\n      enabled: !!contract && listingId !== undefined,\n    },\n  );\n}\n\n/**\n * Use this to get the buffer in basis points between offers from your marketplace contract.\n *\n * @example\n * ```javascript\n * const { data: auctionWinner, isLoading, error } = useBidBuffer(<YourMarketplaceContractInstance>);\n * ```\n *\n * @param contract - an instance of a marketplace contract\n\n * @returns a response object that includes an array of listings\n * @beta\n */\nexport function useBidBuffer(contract: RequiredParam<Marketplace>) {\n  const contractAddress = contract?.getAddress();\n  return useQueryWithNetwork(\n    cacheKeys.contract.marketplace.getBidBufferBps(contractAddress),\n    () => {\n      invariant(contract, \"No Contract instance provided\");\n      return contract.getBidBufferBps();\n    },\n    {\n      enabled: !!contract,\n    },\n  );\n}\n\n/** **********************/\n/**     WRITE HOOKS     **/\n/** **********************/\n\n/**\n * Use this to create a new Direct Listing on your marketplace contract.\n *\n * @example\n * ```jsx\n * const Component = () => {\n *   const {\n *     mutate: createDirectListing,\n *     isLoading,\n *     error,\n *   } = useCreateDirectListing(\">>YourMarketplaceContractInstance<<\");\n *\n *   if (error) {\n *     console.error(\"failed to create direct listing\", error);\n *   }\n *\n *   return (\n *     <button\n *       disabled={isLoading}\n *       onClick={() => createDirectListing(directListingData)}\n *     >\n *       Create Direct Listing!\n *     </button>\n *   );\n * };\n * ```\n *\n * @param contract - an instance of a Marketplace contract\n * @returns a mutation object that can be used to create a new direct listing\n * @beta\n */\nexport function useCreateDirectListing(contract: RequiredParam<Marketplace>) {\n  const activeChainId = useActiveChainId();\n  const contractAddress = contract?.getAddress();\n  const queryClient = useQueryClient();\n  const walletAddress = useAddress();\n  return useMutation(\n    async (data: NewDirectListing) => {\n      invariant(walletAddress, \"no wallet connected, cannot create listing\");\n      invariant(\n        contract?.direct?.createListing,\n        \"contract does not support direct.createListing\",\n      );\n      return await contract.direct.createListing(data);\n    },\n    {\n      onSettled: () =>\n        invalidateContractAndBalances(\n          queryClient,\n          contractAddress,\n          activeChainId,\n        ),\n    },\n  );\n}\n\n/**\n * Use this to create a new Auction Listing on your marketplace contract.\n *\n * @example\n * ```jsx\n * const Component = () => {\n *   const {\n *     mutate: createAuctionListing,\n *     isLoading,\n *     error,\n *   } = useCreateAuctionListing(\">>YourMarketplaceContractInstance<<\");\n *\n *   if (error) {\n *     console.error(\"failed to create auction listing\", error);\n *   }\n *\n *   return (\n *     <button\n *       disabled={isLoading}\n *       onClick={() => createAuctionListing(auctionListingData)}\n *     >\n *       Create Auction Listing!\n *     </button>\n *   );\n * };\n * ```\n *\n * @param contract - an instance of a Marketplace contract\n * @returns a mutation object that can be used to create a new auction listing\n * @beta\n */\nexport function useCreateAuctionListing(contract: RequiredParam<Marketplace>) {\n  const activeChainId = useActiveChainId();\n  const contractAddress = contract?.getAddress();\n  const queryClient = useQueryClient();\n  const walletAddress = useAddress();\n  return useMutation(\n    async (data: NewAuctionListing) => {\n      invariant(walletAddress, \"no wallet connected, cannot create listing\");\n      invariant(\n        contract?.direct?.createListing,\n        \"contract does not support auction.createListing\",\n      );\n      return await contract.auction.createListing(data);\n    },\n    {\n      onSettled: () =>\n        invalidateContractAndBalances(\n          queryClient,\n          contractAddress,\n          activeChainId,\n        ),\n    },\n  );\n}\n\n/**\n * Use this to place a bid on an auction listing from your marketplace contract.\n *\n * @example\n * ```jsx\n * const Component = () => {\n *   const {\n *     mutate: makeBid,\n *     isLoading,\n *     error,\n *   } = useMakeBid(\">>YourMarketplaceContractInstance<<\");\n *\n *   if (error) {\n *     console.error(\"failed to make a bid\", error);\n *   }\n *\n *   return (\n *     <button\n *       disabled={isLoading}\n *       onClick={() => makeBid({ listingId: 1, bid: 2 })}\n *     >\n *       Bid!\n *     </button>\n *   );\n * };\n * ```\n *\n * @param contract - an instance of a Marketplace contract\n * @returns a mutation object that can be used to make a bid on an auction listing\n * @beta\n */\nexport function useMakeBid(contract: RequiredParam<Marketplace>) {\n  const activeChainId = useActiveChainId();\n  const contractAddress = contract?.getAddress();\n  const queryClient = useQueryClient();\n  const walletAddress = useAddress();\n  return useMutation(\n    async (data: MakeBidParams) => {\n      invariant(walletAddress, \"no wallet connected, cannot make bid\");\n      invariant(\n        contract?.auction?.makeBid,\n        \"contract does not support auction.makeBid\",\n      );\n      return await contract.auction.makeBid(data.listingId, data.bid);\n    },\n    {\n      onSettled: () =>\n        invalidateContractAndBalances(\n          queryClient,\n          contractAddress,\n          activeChainId,\n        ),\n    },\n  );\n}\n\n/**\n * Use this to buy out an auction listing from your marketplace contract.\n *\n * @example\n * ```jsx\n * const Component = () => {\n *   const {\n *     mutate: buyNow,\n *     isLoading,\n *     error,\n *   } = useBuyNow(\">>YourMarketplaceContractInstance<<\");\n *\n *   if (error) {\n *     console.error(\"failed to buyout listing\", error);\n *   }\n *\n *   return (\n *     <button\n *       disabled={isLoading}\n *       onClick={() => buyNow({listingId: 1, type: ListingType.Auction})}\n *     >\n *       Buy listing!\n *     </button>\n *   );\n * };\n * ```\n *\n * @param contract - an instance of a Marketplace contract\n * @returns a mutation object that can be used to buy out an auction listing\n * @beta\n */\nexport function useBuyNow(contract: RequiredParam<Marketplace>) {\n  const activeChainId = useActiveChainId();\n  const contractAddress = contract?.getAddress();\n  const queryClient = useQueryClient();\n  const walletAddress = useAddress();\n  return useMutation(\n    async (data: BuyNowParams) => {\n      invariant(walletAddress, \"no wallet connected, cannot make bid\");\n      if (data.type === ListingType.Direct) {\n        invariant(\n          contract?.direct.buyoutListing,\n          \"contract does not support direct.buyoutListing\",\n        );\n\n        return await contract.direct.buyoutListing(\n          data.id,\n          data.buyAmount,\n          data.buyForWallet,\n        );\n      }\n      invariant(\n        contract?.auction?.buyoutListing,\n        \"contract does not support auction.buyoutListing\",\n      );\n      return await contract.auction.buyoutListing(data.id);\n    },\n    {\n      onSettled: () =>\n        invalidateContractAndBalances(\n          queryClient,\n          contractAddress,\n          activeChainId,\n        ),\n    },\n  );\n}\n","import { useActiveChainId } from \"../../Provider\";\nimport {\n  ClaimTokenParams,\n  RequiredParam,\n  TokenBurnParams,\n  TokenParams,\n  WalletAddress,\n} from \"../../types\";\nimport {\n  cacheKeys,\n  invalidateContractAndBalances,\n} from \"../../utils/cache-keys\";\nimport { useQueryWithNetwork } from \"../query-utils/useQueryWithNetwork\";\nimport { useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport type { Erc20, TokenDrop } from \"@thirdweb-dev/sdk/dist/browser\";\nimport invariant from \"tiny-invariant\";\n\n/** **********************/\n/**     READ  HOOKS     **/\n/** **********************/\n\n/**\n * Use this to get a the total supply of your {@link Erc20} contract.\n *\n * @example\n * ```javascript\n * const { data: totalSupply, isLoading, error } = useTokenSupply(<YourTokenContractInstance>);\n * ```\n *\n * @param contract - an instance of a Token contract.\n * @returns a response object that incudes the total minted supply\n * @beta\n */\nexport function useTokenSupply(contract: RequiredParam<Erc20>) {\n  const contractAddress = contract?.getAddress();\n  return useQueryWithNetwork(\n    cacheKeys.contract.token.totalSupply(contractAddress),\n    () => {\n      invariant(contract, \"No Contract instance provided\");\n      return contract.totalSupply();\n    },\n    {\n      enabled: !!contract || !!contractAddress,\n    },\n  );\n}\n\n/**\n * Use this to get the balance of your {@link Erc20} contract for a given address.\n *\n * @example\n * ```javascript\n * const { data: balance, isLoading, error } = useTokenBalance(<YourTokenContractInstance>);\n * ```\n *\n * @param contract - an instance of a Token contract.\n * @returns a response object that includes the balance of the address\n * @beta\n */\nexport function useTokenBalance(\n  contract: RequiredParam<Erc20>,\n  walletAddress: RequiredParam<WalletAddress>,\n) {\n  const contractAddress = contract?.getAddress();\n  return useQueryWithNetwork(\n    cacheKeys.contract.token.balanceOf(contractAddress, walletAddress),\n    async () => {\n      invariant(contract, \"No Contract instance provided\");\n      invariant(walletAddress, \"No address provided\");\n      return await contract.balanceOf(walletAddress);\n    },\n    {\n      enabled: !!walletAddress && !!contract,\n    },\n  );\n}\n\n/** **********************/\n/**     WRITE HOOKS     **/\n/** **********************/\n\n/**\n * Use this to mint new tokens on your {@link Erc20} contract\n *\n * @example\n * ```jsx\n * const Component = () => {\n *   const {\n *     mutate: mintTokens,\n *     isLoading,\n *     error,\n *   } = useMintToken(\">>YourERC20ContractInstance<<\");\n *\n *   if (error) {\n *     console.error(\"failed to mint tokens\", error);\n *   }\n *\n *   return (\n *     <button\n *       disabled={isLoading}\n *       onClick={() => mintTokens({ to: \"0x...\", amount: 1000 })}\n *     >\n *       Mint!\n *     </button>\n *   );\n * };\n * ```\n *\n * @param contract - an instance of a contract that extends the ERC20 spec (token, token drop, custom contract that follows the ERC20 spec)\n * @returns a mutation object that can be used to mint new tokens to the connected wallet\n * @beta\n */\nexport function useMintToken(contract: RequiredParam<Erc20>) {\n  const activeChainId = useActiveChainId();\n  const contractAddress = contract?.getAddress();\n  const queryClient = useQueryClient();\n\n  return useMutation(\n    (data: TokenParams) => {\n      const { to, amount } = data;\n      invariant(contract?.mint?.to, \"contract does not support mint.to\");\n      return contract.mint.to(to, amount);\n    },\n    {\n      onSettled: () =>\n        invalidateContractAndBalances(\n          queryClient,\n          contractAddress,\n          activeChainId,\n        ),\n    },\n  );\n}\n\n/**\n * Use this to claim tokens on your {@link TokenDrop}\n *\n * @example\n * ```jsx\n * const Component = () => {\n *   const {\n *     mutate: claimTokens,\n *     isLoading,\n *     error,\n *   } = useClaimToken(TokenDropContract);\n *\n *   if (error) {\n *     console.error(\"failed to claim tokens\", error);\n *   }\n *\n *   return (\n *     <button\n *       disabled={isLoading}\n *       onClick={() => claimTokens({ to: \"0x...\", amount: 100 })}\n *     >\n *       Claim Tokens!\n *     </button>\n *   );\n * };\n * ```\n *\n * @param contract - an instance of a {@link TokenDrop}\n * @returns a mutation object that can be used to tokens to the wallet specificed in the params\n * @beta\n */\nexport function useClaimToken<TContract extends TokenDrop>(\n  contract: RequiredParam<TContract>,\n) {\n  const activeChainId = useActiveChainId();\n  const contractAddress = contract?.getAddress();\n  const queryClient = useQueryClient();\n\n  return useMutation(\n    async (data: ClaimTokenParams) => {\n      invariant(data.to, 'No \"to\" address provided');\n      invariant(contract?.claimTo, \"contract does not support claimTo\");\n      return await contract.claimTo(\n        data.to,\n        data.amount,\n        data.checkERC20Allowance,\n      );\n    },\n    {\n      onSettled: () =>\n        invalidateContractAndBalances(\n          queryClient,\n          contractAddress,\n          activeChainId,\n        ),\n    },\n  );\n}\n\n/**\n * Use this to transfer tokens on your {@link Erc20} contract\n *\n * @example\n * ```jsx\n * const Component = () => {\n *   const {\n *     mutate: transferTokens,\n *     isLoading,\n *     error,\n *   } = useTransferToken(\">>YourERC20ContractInstance<<\");\n *\n *   if (error) {\n *     console.error(\"failed to transfer tokens\", error);\n *   }\n *\n *   return (\n *     <button\n *       disabled={isLoading}\n *       onClick={() => transferTokens({ to: \"0x...\", amount: 1000 })}\n *     >\n *       Transfer\n *     </button>\n *   );\n * };\n * ```\n *\n * @param contract - an instance of a contract that extends the ERC20 spec (token, token drop, custom contract that follows the ERC20 spec)\n * @returns a mutation object that can be used to transfer tokens\n * @beta\n */\nexport function useTransferToken(contract: RequiredParam<Erc20>) {\n  const activeChainId = useActiveChainId();\n  const contractAddress = contract?.getAddress();\n  const queryClient = useQueryClient();\n\n  return useMutation(\n    (data: TokenParams) => {\n      const { to, amount } = data;\n      invariant(contract?.transfer, \"contract does not support transfer\");\n      return contract.transfer(to, amount);\n    },\n    {\n      onSettled: () =>\n        invalidateContractAndBalances(\n          queryClient,\n          contractAddress,\n          activeChainId,\n        ),\n    },\n  );\n}\n\n/**\n * Use this to transfer batch tokens on your {@link Erc20} contract\n *\n * @example\n * ```jsx\n * const Component = () => {\n *   const {\n *     mutate: transferBatchTokens,\n *     isLoading,\n *     error,\n *   } = useTransferToken(\">>YourERC20ContractInstance<<\");\n *\n *   if (error) {\n *     console.error(\"failed to transfer batch tokens\", error);\n *   }\n *\n *   return (\n *     <button\n *       disabled={isLoading}\n *       onClick={() => transferBatchTokens([{ to: \"0x...\", amount: 1000 }, { to: \"0x...\", amount: 2000 }])}\n *     >\n *       Transfer Batch\n *     </button>\n *   );\n * };\n * ```\n *\n * @param contract - an instance of a contract that extends the ERC20 spec (token, token drop, custom contract that follows the ERC20 spec)\n * @returns a mutation object that can be used to transfer batch tokens\n * @beta\n */\nexport function useTransferBatchToken(contract: RequiredParam<Erc20>) {\n  const activeChainId = useActiveChainId();\n  const contractAddress = contract?.getAddress();\n  const queryClient = useQueryClient();\n\n  return useMutation(\n    (data: TokenParams[]) => {\n      invariant(\n        contract?.transferBatch,\n        \"contract does not support transferBatch\",\n      );\n      const convertedData = data.map((token) => ({\n        toAddress: token.to,\n        amount: token.amount,\n      }));\n\n      return contract.transferBatch(convertedData);\n    },\n    {\n      onSettled: () =>\n        invalidateContractAndBalances(\n          queryClient,\n          contractAddress,\n          activeChainId,\n        ),\n    },\n  );\n}\n\n/**\n * Use this to burn tokens on your {@link Erc20} contract\n *\n * @example\n * ```jsx\n * const Component = () => {\n *   const {\n *     mutate: burnTokens,\n *     isLoading,\n *     error,\n *   } = useBurnToken(\">>YourERC20ContractInstance<<\");\n *\n *   if (error) {\n *     console.error(\"failed to burn tokens\", error);\n *   }\n *\n *   return (\n *     <button\n *       disabled={isLoading}\n *       onClick={() => burnTokens({ amount: 1000 })}\n *     >\n *       Burn!\n *     </button>\n *   );\n * };\n * ```\n *\n * @param contract - an instance of a contract that extends the ERC20 spec (token, token drop, custom contract that follows the ERC20 spec)\n * @returns a mutation object that can be used to burn tokens from the connected wallet\n * @beta\n */\nexport function useBurnToken(contract: RequiredParam<Erc20>) {\n  const activeChainId = useActiveChainId();\n  const contractAddress = contract?.getAddress();\n  const queryClient = useQueryClient();\n\n  return useMutation(\n    (data: TokenBurnParams) => {\n      const { amount } = data;\n      invariant(contract?.burn, \"contract does not support burn\");\n      return contract.burn.tokens(amount);\n    },\n    {\n      onSettled: () =>\n        invalidateContractAndBalances(\n          queryClient,\n          contractAddress,\n          activeChainId,\n        ),\n    },\n  );\n}\n","import { RequiredParam, WalletAddress } from \"../../types\";\nimport { cacheKeys } from \"../../utils/cache-keys\";\nimport { useQueryWithNetwork } from \"../query-utils/useQueryWithNetwork\";\nimport {\n  EditionDrop,\n  Erc1155,\n  NFTDrop,\n  SignatureDrop,\n  TokenDrop,\n} from \"@thirdweb-dev/sdk/dist/browser\";\nimport { BigNumberish } from \"ethers\";\nimport invariant from \"tiny-invariant\";\n\ntype ActiveClaimConditionParams<TContract> = TContract extends Erc1155\n  ? [contract: RequiredParam<TContract>, tokenId: RequiredParam<BigNumberish>]\n  : [contract: RequiredParam<TContract>];\n\n/** **********************/\n/**     READ  HOOKS     **/\n/** **********************/\n\n/**\n * Use this to get the active claim conditon for ERC20, ERC721 or ERC1155 based contracts. They need to extend the `claimCondition` extension for this hook to work.\n *\n * @example\n * ```javascript\n * const { data: activeClaimCondition, isLoading, error } = useActiveClaimCondition(<YourERC20ContractInstance>);\n * ```\n * @example\n * ```javascript\n * const { data: activeClaimCondition, isLoading, error } = useActiveClaimCondition(<YourERC721ContractInstance>);\n * ```\n * @example\n * ```javascript\n * const { data: activeClaimCondition, isLoading, error } = useActiveClaimCondition(<YourERC1155ContractInstance>, <tokenId>);\n * ```\n *\n * @param contract - an instance of a contract that extends the ERC721 or ERC1155 spec and implements the `claimConditions` extension.\n * @param tokenId - the id of the token to fetch the claim conditions for (if the contract is an ERC1155 contract)\n * @returns a response object with the currently active claim condition\n *\n * @beta\n */\nexport function useActiveClaimCondition<\n  TContract extends NFTDrop | EditionDrop | TokenDrop | SignatureDrop,\n>(...[contract, tokenId]: ActiveClaimConditionParams<TContract>) {\n  const contractAddress = contract?.getAddress();\n\n  return useQueryWithNetwork(\n    cacheKeys.extensions.claimConditions.getActive(contractAddress, tokenId),\n    () => {\n      invariant(contract, \"No Contract instance provided\");\n      invariant(\n        contract.claimConditions.getActive,\n        \"Contract instance does not support claimConditions.getActive\",\n      );\n      if (contract instanceof Erc1155) {\n        invariant(tokenId, \"tokenId is required for ERC1155 claim conditions\");\n        return contract.claimConditions.getActive(tokenId);\n      }\n      return contract.claimConditions.getActive();\n    },\n    {\n      // Checks that happen here:\n      // 1. if the contract is based on  ERC1155 contract => tokenId cannot be `undefined`\n      // 2. if the contract is NOT based on ERC1155 => contract has to still be provided\n      enabled: contract instanceof Erc1155 ? tokenId !== undefined : !!contract,\n    },\n  );\n}\n\n/**\n * Use this to get all claim conditons for ERC20, ERC721 or ERC1155 based contracts. They need to extend the `claimCondition` extension for this hook to work.\n *\n * @example\n * ```javascript\n * const { data: claimConditions, isLoading, error } = useClaimConditions(<YourERC20ContractInstance>);\n * ```\n * @example\n * ```javascript\n * const { data: claimConditions, isLoading, error } = useClaimConditions(<YourERC721ContractInstance>);\n * ```\n * @example\n * ```javascript\n * const { data: claimConditions, isLoading, error } = useClaimConditions(<YourERC1155ContractInstance>, <tokenId>);\n * ```\n *\n * @param contract - an instance of a contract that extends the ERC721 or ERC1155 spec and implements the `claimConditions` extension.\n * @param tokenId - the id of the token to fetch the claim conditions for (if the contract is an ERC1155 contract)\n * @returns a response object with the list of claim conditions\n *\n * @beta\n */\nexport function useClaimConditions<\n  TContract extends NFTDrop | EditionDrop | TokenDrop | SignatureDrop,\n>(...[contract, tokenId]: ActiveClaimConditionParams<TContract>) {\n  const contractAddress = contract?.getAddress();\n\n  return useQueryWithNetwork(\n    cacheKeys.extensions.claimConditions.getAll(contractAddress, tokenId),\n    () => {\n      invariant(contract, \"No Contract instance provided\");\n      invariant(\n        contract.claimConditions.getAll,\n        \"Contract instance does not support claimConditions.getAll\",\n      );\n      if (contract instanceof Erc1155) {\n        invariant(tokenId, \"tokenId is required for ERC1155 claim conditions\");\n        return contract.claimConditions.getAll(tokenId);\n      }\n      return contract.claimConditions.getAll();\n    },\n    {\n      // Checks that happen here:\n      // 1. if the contract is based on  ERC1155 contract => tokenId cannot be `undefined`\n      // 2. if the contract is NOT based on ERC1155 => contract has to still be provided\n      enabled: contract instanceof Erc1155 ? tokenId !== undefined : !!contract,\n    },\n  );\n}\n\n/**\n * The options to be passed as the second parameter to the `useClaimIneligibilityReasons` hook.\n *\n * @beta\n */\nexport type ClaimIneligibilityParameters = {\n  // the wallet address to check claim eligibility for\n  walletAddress: WalletAddress;\n  // the amount of tokens to check claim eligibility for\n  quantity: string | number;\n};\n\ntype ClaimIneligibilityInputParams<TContract> = TContract extends Erc1155\n  ? [\n      contract: RequiredParam<TContract>,\n      eligibilityParams: ClaimIneligibilityParameters,\n      tokenId: RequiredParam<BigNumberish>,\n    ]\n  : [\n      contract: RequiredParam<TContract>,\n      eligibilityParams: ClaimIneligibilityParameters,\n    ];\n\n/**\n * Use this to check for reasons that prevent claiming for either  ERC20, ERC721 or ERC1155 based contracts. They need to extend the `claimCondition` extension for this hook to work.\n * @example\n * ```javascript\n * const { data: activeClaimCondition, isLoading, error } = useClaimIneligibilityReasons(<YourERC20ContractInstance>, { walletAddress: <walletAddress> });\n * ```\n * @example\n * ```javascript\n * const { data: claimIneligibilityReasons, isLoading, error } = useClaimIneligibilityReasons(<YourERC721ContractInstance>, { quantity: <quantity>, walletAddress: <walletAddress> });\n * ```\n * @example\n * ```javascript\n * const { data: claimIneligibilityReasons, isLoading, error } = useClaimIneligibilityReasons(<YourERC1155ContractInstance>, { quantity: <quantity>, walletAddress: <walletAddress> }, <tokenId>);\n * ```\n *\n * @param contract - an instance of a contract that extends the  ERC20, ERC721 or ERC1155 spec and implements the `claimConditions` extension.\n * @param eligibilityParams - the parameters for the eligibility check, see: {@link ClaimIneligibilityParameters}\n * @param tokenId - the id of the token to fetch the claim conditions for (if the contract is an ERC1155 contract)\n * @returns a response object with the resons for the claim ineligibility\n *\n * @beta\n */\nexport function useClaimIneligibilityReasons<\n  TContract extends NFTDrop | EditionDrop | TokenDrop | SignatureDrop,\n>(...[contract, params, tokenId]: ClaimIneligibilityInputParams<TContract>) {\n  const contractAddress = contract?.getAddress();\n\n  return useQueryWithNetwork(\n    cacheKeys.extensions.claimConditions.getClaimIneligibilityReasons(\n      contractAddress,\n      params,\n      tokenId,\n    ),\n    () => {\n      invariant(contract, \"No Contract instance provided\");\n      invariant(\n        contract.claimConditions.getClaimIneligibilityReasons,\n        \"Contract instance does not support claimConditions.getClaimIneligibilityReasons\",\n      );\n      if (contract instanceof Erc1155) {\n        invariant(\n          tokenId,\n          \"tokenId is required for ERC1155 claim ineligibility reasons\",\n        );\n        return contract.claimConditions.getClaimIneligibilityReasons(\n          tokenId,\n          params.quantity,\n          params.walletAddress,\n        );\n      }\n      return contract.claimConditions.getClaimIneligibilityReasons(\n        params.quantity,\n        params.walletAddress,\n      );\n    },\n    {\n      // Checks that happen here:\n      // 1. if the contract is based on  ERC1155 contract => tokenId cannot be `undefined`\n      // 2. if the contract is NOT based on ERC1155 => contract has to still be provided\n      // 3. has a params object been passed?\n      // 4. does params have an address in it?\n      enabled:\n        (contract instanceof Erc1155 ? tokenId !== undefined : !!contract) &&\n        !!params &&\n        !!params.walletAddress,\n    },\n  );\n}\n","import { SupportedChainId } from \"../../constants/chain\";\nimport { useThirdwebConfigContext } from \"../../contexts/thirdweb-config\";\nimport { ContractAddress } from \"../../types\";\nimport { cacheKeys } from \"../../utils/cache-keys\";\nimport { useAddress } from \"../useAddress\";\nimport { useChainId } from \"../useChainId\";\nimport { useSigner } from \"../useSigner\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { UserWallet } from \"@thirdweb-dev/sdk/dist/browser\";\nimport { useMemo } from \"react\";\n\n/**\n * A hook to get the native or (optional) ERC20 token balance of the connected wallet.\n *\n * @param tokenAddress - the address of the token contract, if empty will use the chain's native token\n * @returns the balance of the connected wallet (native or ERC20)\n * @beta\n */\nexport function useBalance(tokenAddress?: ContractAddress) {\n  const { rpcUrlMap } = useThirdwebConfigContext();\n  const chainId = useChainId() as SupportedChainId;\n  const signer = useSigner();\n  const walletAddress = useAddress();\n\n  const walletSDK = useMemo(() => {\n    if (signer) {\n      return new UserWallet(signer, {\n        readonlySettings: {\n          rpcUrl: rpcUrlMap[chainId],\n          chainId,\n        },\n      });\n    }\n    return undefined;\n  }, [signer, chainId]);\n\n  const cacheKey = useMemo(() => {\n    return cacheKeys.wallet.balance(chainId, walletAddress, tokenAddress);\n  }, [chainId, tokenAddress, walletAddress]);\n\n  return useQuery(\n    cacheKey,\n    () => {\n      return walletSDK?.balance(tokenAddress);\n    },\n    {\n      // if user is not logged in no reason to try to fetch\n      enabled: !!walletSDK && !!walletAddress,\n      retry: true,\n      keepPreviousData: false,\n    },\n  );\n}\n","import { useActiveChainId } from \"../../Provider\";\nimport { RequiredParam, WalletAddress } from \"../../types\";\nimport {\n  cacheKeys,\n  invalidateContractAndBalances,\n} from \"../../utils/cache-keys\";\nimport { useQueryWithNetwork } from \"../query-utils/useQueryWithNetwork\";\nimport { useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport type {\n  SmartContract,\n  ValidContractInstance,\n} from \"@thirdweb-dev/sdk/dist/browser\";\nimport type { CustomContractMetadata } from \"@thirdweb-dev/sdk/dist/src/schema/contracts/custom\";\nimport invariant from \"tiny-invariant\";\n\n// primary sales\n\n/**\n *\n * @example\n * ```jsx\n * const { data: recipient, isLoading, error } = usePrimarySalesRecipient(SmartContract);\n * ```\n *\n * Use this to get the primary sales recipient of your {@link SmartContract}\n * @param contract - an instance of a {@link SmartContract}\n * @returns the wallet address of the primary sales recipient\n * @beta\n */\nexport function usePrimarySaleRecipient(\n  contract: RequiredParam<SmartContract | ValidContractInstance>,\n) {\n  const contractAddress = contract?.getAddress();\n  return useQueryWithNetwork(\n    cacheKeys.extensions.sales.getRecipient(contractAddress),\n    () => {\n      invariant(contract, \"No contract provided\");\n      invariant(\n        \"sales\" in contract && contract.sales,\n        \"Contract does not support primarySale\",\n      );\n      return contract.sales.getRecipient();\n    },\n    { enabled: !!contract || !!contractAddress },\n  );\n}\n\n/**\n * Use this to update the primary sales recipient of your {@link SmartContract}\n *\n * @example\n * ```jsx\n * const Component = () => {\n *   const {\n *     mutate: updatePrimarySalesRecipient,\n *     isLoading,\n *     error,\n *   } = useUpdatePrimarySaleRecipient(SmartContract);\n *\n *   if (error) {\n *     console.error(\"failed to update recipient\", error);\n *   }\n *\n *   return (\n *     <button\n *       disabled={isLoading}\n *       onClick={() => updatePrimarySalesRecipient({ newRecipient: \"0x123\" })}\n *     >\n *       Update Recipient\n *     </button>\n *   );\n * };\n * ```\n *\n * @param contract - an instance of a {@link SmartContract}\n * @returns a mutation object that can be used to update the primary sales recipient\n * @beta\n */\nexport function useUpdatePrimarySaleRecipient(\n  contract: RequiredParam<SmartContract | ValidContractInstance>,\n) {\n  const queryClient = useQueryClient();\n  const contractAddress = contract?.getAddress();\n  const activeChainId = useActiveChainId();\n  return useMutation(\n    (newRecipient: WalletAddress) => {\n      invariant(contract, \"No contract provided\");\n      invariant(\n        \"sales\" in contract && contract.sales,\n        \"Contract does not support primarySale\",\n      );\n      return contract.sales.setRecipient(newRecipient);\n    },\n    {\n      onSettled: () =>\n        invalidateContractAndBalances(\n          queryClient,\n          contractAddress,\n          activeChainId,\n        ),\n    },\n  );\n}\n\n// end prinary sales\n\n// royalties\n\n/**\n * Use this to get the royalty settings of your {@link SmartContract}\n *\n * @example\n * ```jsx\n * const { data: settings, isLoading, error } = useRoyaltySettings(SmartContract);\n * ```\n *\n * @param contract - an instance of a {@link SmartContract}\n * @returns an object containing recipient address and the royalty basis points\n * @beta\n */\nexport function useRoyaltySettings(\n  contract: RequiredParam<SmartContract | ValidContractInstance>,\n) {\n  const contractAddress = contract?.getAddress();\n  return useQueryWithNetwork(\n    cacheKeys.extensions.royalties.getDefaultRoyaltyInfo(contractAddress),\n    () => {\n      invariant(contract, \"No contract provided\");\n      invariant(\n        \"royalties\" in contract && contract.royalties,\n        \"Contract does not support royalties\",\n      );\n      return contract.royalties.getDefaultRoyaltyInfo();\n    },\n    { enabled: !!contract || !!contractAddress },\n  );\n}\n\n/**\n * Use this to update the royalty settings of your {@link SmartContract}\n *\n * @example\n * ```jsx\n * const Component = () => {\n *   const {\n *     mutate: updateRoyaltySettings,\n *     isLoading,\n *     error,\n *   } = useUpdateRoyaltySettings(SmartContract);\n *\n *   if (error) {\n *     console.error(\"failed to update royalty settings\", error);\n *   }\n *\n *   return (\n *     <button\n *       disabled={isLoading}\n *       onClick={() => updateRoyaltySettings({ updatePayload: { fee_recipient: \"0x123\", seller_fee_basis_points: 5_00 } })}\n *     >\n *       Update Royalty Settings\n *     </button>\n *   );\n * };\n * ```\n *\n * @param contract - an instance of a {@link SmartContract}\n * @returns a mutation object that can be used to update the royalty settings\n * @beta\n */\nexport function useUpdateRoyaltySettings(\n  contract: RequiredParam<SmartContract | ValidContractInstance>,\n) {\n  const queryClient = useQueryClient();\n  const contractAddress = contract?.getAddress();\n  const activeChainId = useActiveChainId();\n  return useMutation(\n    (updatePayload: {\n      seller_fee_basis_points?: number;\n      fee_recipient?: WalletAddress;\n    }) => {\n      invariant(contract, \"No contract provided\");\n      invariant(\n        \"royalties\" in contract && contract.royalties,\n        \"Contract does not support royalties\",\n      );\n      return contract.royalties.setDefaultRoyaltyInfo(updatePayload);\n    },\n    {\n      onSettled: () =>\n        invalidateContractAndBalances(\n          queryClient,\n          contractAddress,\n          activeChainId,\n        ),\n    },\n  );\n}\n\n// end royalties\n\n// platformFees\n\n/**\n * Use this to get the platform fees settings of your {@link SmartContract}\n *\n * @example\n * ```jsx\n * const { data: platformFees, isLoading, error } = usePlatformFees(SmartContract);\n * ```\n *\n * @param contract - an instance of a {@link SmartContract}\n * @returns an object containing the platform fee basis points and the fee recipient address\n * @beta\n */\nexport function usePlatformFees(\n  contract: RequiredParam<SmartContract | ValidContractInstance>,\n) {\n  const contractAddress = contract?.getAddress();\n  return useQueryWithNetwork(\n    cacheKeys.extensions.platformFees.get(contractAddress),\n    () => {\n      invariant(contract, \"No contract provided\");\n      invariant(\n        \"platformFees\" in contract && contract.platformFees,\n        \"Contract does not support platformFees\",\n      );\n      return contract.platformFees.get();\n    },\n    { enabled: !!contract || !!contractAddress },\n  );\n}\n\n/**\n * Use this to update the platform fees settings of your {@link SmartContract}\n *\n * @example\n * ```jsx\n * const Component = () => {\n *   const {\n *     mutate: updatePlatformFees,\n *     isLoading,\n *     error,\n *   } = useUpdatePlatformFees(SmartContract);\n *\n *   if (error) {\n *     console.error(\"failed to update platform fees\", error);\n *   }\n *\n *   return (\n *     <button\n *       disabled={isLoading}\n *       onClick={() => updatePlatformFees({ updatePayload: { fee_recipient: \"0x123\", platform_fee_basis_points: 5_00 } })}\n *     >\n *       Update Platform fees\n *     </button>\n *   );\n * };\n * ```\n * @param contract - an instance of a {@link SmartContract}\n * @returns a mutation object that can be used to update the platform fees settings\n * @beta\n */\nexport function useUpdatePlatformFees(\n  contract: RequiredParam<SmartContract | ValidContractInstance>,\n) {\n  const queryClient = useQueryClient();\n  const contractAddress = contract?.getAddress();\n  const activeChainId = useActiveChainId();\n  return useMutation(\n    (updatePayload: {\n      platform_fee_basis_points?: number;\n      fee_recipient?: WalletAddress;\n    }) => {\n      invariant(contract, \"No contract provided\");\n      invariant(\n        \"platformFees\" in contract && contract.platformFees,\n        \"Contract does not support platformFees\",\n      );\n      return contract.platformFees.set(updatePayload);\n    },\n    {\n      onSettled: () =>\n        invalidateContractAndBalances(\n          queryClient,\n          contractAddress,\n          activeChainId,\n        ),\n    },\n  );\n}\n\n// end platformFees\n\n// metadata\n\n/**\n * Use this to get the metadata of your {@link SmartContract}\n *\n * @example\n * ```jsx\n * const { data: metadata, isLoading, error } = useMetadata(SmartContract);\n * ```\n *\n * @param contract - an instance of a {@link SmartContract}\n * @returns a {@link CustomContractMetadata} object containing the metadata\n * @beta\n */\nexport function useMetadata(\n  contract: RequiredParam<SmartContract | ValidContractInstance>,\n) {\n  const contractAddress = contract?.getAddress();\n  return useQueryWithNetwork(\n    cacheKeys.extensions.metadata.get(contractAddress),\n    () => {\n      invariant(contract, \"No contract provided\");\n      invariant(\n        \"metadata\" in contract && contract.metadata,\n        \"Contract does not support metadata\",\n      );\n      return contract.metadata.get() as Promise<CustomContractMetadata>;\n    },\n    { enabled: !!contract || !!contractAddress },\n  );\n}\n\n/**\n * Use this to update the metadata of your {@link SmartContract}\n * @example\n * ```jsx\n * const Component = () => {\n *   const {\n *     mutate: updateMetadata,\n *     isLoading,\n *     error,\n *   } = useUpdateMetadata(SmartContract);\n *\n *   if (error) {\n *     console.error(\"failed to update metadata\", error);\n *   }\n *\n *   return (\n *     <button\n *       disabled={isLoading}\n *       onClick={() => updateMetadata({ updatePayload: { name: \"My Contract\", description: \"This is my contract\" } })}\n *     >\n *       Update Metadata\n *     </button>\n *   );\n * };\n * ```\n * @param contract - an instance of a {@link SmartContract}\n * @returns a mutation object that can be used to update the metadata\n * @beta\n */\nexport function useUpdateMetadata(\n  contract: RequiredParam<SmartContract | ValidContractInstance>,\n) {\n  const queryClient = useQueryClient();\n  const contractAddress = contract?.getAddress();\n  const activeChainId = useActiveChainId();\n  return useMutation(\n    (updatePayload: CustomContractMetadata) => {\n      invariant(contract, \"No contract provided\");\n      invariant(\n        \"metadata\" in contract && contract.metadata,\n        \"Contract does not support metadata\",\n      );\n      return contract.metadata.update(updatePayload);\n    },\n    {\n      onSettled: () =>\n        invalidateContractAndBalances(\n          queryClient,\n          contractAddress,\n          activeChainId,\n        ),\n    },\n  );\n}\n\n// end metadata\n","import { useActiveChainId } from \"../../Provider\";\nimport { RequiredParam, WalletAddress } from \"../../types\";\nimport {\n  cacheKeys,\n  invalidateContractAndBalances,\n} from \"../../utils/cache-keys\";\nimport { useQueryWithNetwork } from \"../query-utils/useQueryWithNetwork\";\nimport { useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport type {\n  Multiwrap,\n  Role,\n  SmartContract,\n  Split,\n  ValidContractInstance,\n  Vote,\n} from \"@thirdweb-dev/sdk/dist/browser\";\nimport { constants } from \"ethers\";\nimport invariant from \"tiny-invariant\";\n\n/** **********************/\n/**         UTILS       **/\n/** **********************/\n\n/**\n * @internal\n */\nexport type ContractWithRoles =\n  | Exclude<ValidContractInstance, Vote | Split | Multiwrap>\n  | SmartContract;\n\n/**\n * @internal\n */\nexport type RolesForContract<TContract extends ContractWithRoles> =\n  TContract extends SmartContract\n    ? Role | (string & {})\n    : NonNullable<TContract[\"roles\"]>[\"roles\"][number];\n\n/**\n * @internal\n */\ntype GetAllReturnType<TContract extends ContractWithRoles> = Promise<\n  Record<RolesForContract<TContract>, string[]>\n>;\n\n/** **********************/\n/**     READ  HOOKS     **/\n/** **********************/\n\n/**\n * Use this to get the roles of a {@link SmartContract}\n *\n * @example\n * ```jsx\n * const { data: roles, isLoading, error } = useAllRoleMembers(SmartContract);\n * ```\n *\n * @param contract - an instance of a {@link SmartContract}\n * @returns a list of addresses for all supported roles on the contract.\n * @beta\n */\nexport function useAllRoleMembers<TContract extends ContractWithRoles>(\n  contract: RequiredParam<TContract>,\n) {\n  const contractAddress = contract?.getAddress();\n  return useQueryWithNetwork<Awaited<GetAllReturnType<TContract>>>(\n    cacheKeys.extensions.roles.getAll(contractAddress),\n    () => {\n      invariant(contract, \"No contract provided\");\n      invariant(contract.roles, \"Contract does not support roles\");\n      // have to cast to any because of role bs, type is defined in the useQueryWithNetwork definition above\n      return contract.roles.getAll() as any;\n    },\n    {\n      enabled: !!contract && !!contractAddress,\n    },\n  );\n}\n\n/**\n * Use this to get the members of a role on a {@link SmartContract}\n *\n * @example\n * ```jsx\n * const { data: members, isLoading, error } = useRoleMembers(SmartContract, \"admin\");\n * ```\n *\n * @param contract - an instance of a {@link SmartContract}\n * @param role - the role to get the members of, see {@link Role}\n * @returns a list of addresses that are members of the role\n * @beta\n */\nexport function useRoleMembers<TContract extends ContractWithRoles>(\n  contract: RequiredParam<TContract>,\n  role: RolesForContract<TContract>,\n) {\n  const contractAddress = contract?.getAddress();\n  return useQueryWithNetwork(\n    cacheKeys.extensions.roles.get(contractAddress, role),\n    () => {\n      invariant(contract, \"No contract provided\");\n      invariant(contract.roles, \"Contract does not support roles\");\n      return contract.roles.get(role);\n    },\n    {\n      enabled: !!contract && !!contractAddress && !!role,\n    },\n  );\n}\n\n/**\n * Use this to check if a {@link WalletAddress} is a member of a role on a {@link SmartContract}\n *\n * @example\n * ```jsx\n * const { data: isMember, isLoading, error } = useIsAddressRole(SmartContract, \"admin\", \"0x123\");\n * ```\n *\n * @param contract - an instance of a {@link SmartContract}\n * @param role - the role to check the member against, see {@link Role}\n * @param walletAddress - the address to check\n * @returns true if the address is a member of the role, or false if not\n * @beta\n */\nexport function useIsAddressRole<TContract extends ContractWithRoles>(\n  contract: RequiredParam<TContract>,\n  role: RolesForContract<TContract>,\n  walletAddress: RequiredParam<WalletAddress>,\n): boolean {\n  // TODO this might be possible to do with `verify` fn instead?\n  const contractHasRoles = !!(contract && contract.roles);\n  const { data } = useRoleMembers(\n    contractHasRoles ? contract : undefined,\n    role,\n  );\n\n  // if the contract does not have roles then everything is allowed === true\n  if (contractHasRoles === false) {\n    return true;\n  }\n\n  // switch logic (if address 0 is in the role list then anyone has permissions to it)\n  if (data?.includes(constants.AddressZero)) {\n    return true;\n  }\n\n  // actual role check logic\n  return !!(walletAddress && data?.includes(walletAddress));\n}\n\n/** **********************/\n/**     WRITE HOOKS     **/\n/** **********************/\n\n/**\n * Use this to OVERWRITE the list of addresses that are members of specific roles\n *\n * @example\n * ```jsx\n * const Component = () => {\n *   const {\n *     mutate: overwriteRoles,\n *     isLoading,\n *     error,\n *   } = useSetAllRoleMembers(SmartContract);\n *\n *   if (error) {\n *     console.error(\"failed to overwrite roles\", error);\n *   }\n *\n *   return (\n *     <button\n *       disabled={isLoading}\n *       onClick={() => overwriteRoles({  rolesWithAddresses: { minter: [] } })}\n *     >\n *       Overwrite Roles\n *     </button>\n *   );\n * };\n * ```\n *\n * @param contract - an instance of a {@link SmartContract}\n * @returns a mutation object that can be used to overwrite all roles on the contract\n * @beta\n */\nexport function useSetAllRoleMembers<TContract extends ContractWithRoles>(\n  contract: RequiredParam<TContract>,\n) {\n  const activeChainId = useActiveChainId();\n  const contractAddress = contract?.getAddress();\n  const queryClient = useQueryClient();\n\n  return useMutation(\n    async (rolesWithAddresses: {\n      [role in RolesForContract<TContract>]: string[];\n    }) => {\n      invariant(contract, \"No contract provided\");\n      invariant(contract.roles, \"Contract does not support roles\");\n      await contract.roles.setAll(rolesWithAddresses);\n    },\n    {\n      onSettled: () =>\n        invalidateContractAndBalances(\n          queryClient,\n          contractAddress,\n          activeChainId,\n        ),\n    },\n  );\n}\n\n// const { mutate } = useSetAllRoleMembers(undefined as unknown as NFTCollection);\n\n/**\n * Use this to grant a {@link WalletAddress} a specific role on a {@link SmartContract}\n *\n * @example\n * ```jsx\n * const Component = () => {\n *   const {\n *     mutate: grantRole,\n *     isLoading,\n *     error,\n *   } = useGrantRole(SmartContract);\n *\n *   if (error) {\n *     console.error(\"failed to grant role\", error);\n *   }\n *\n *   return (\n *     <button\n *       disabled={isLoading}\n *       onClick={() => grantRole({  role: \"admin\", address: \"0x123\" })}\n *     >\n *       Grant Role\n *     </button>\n *   );\n * };\n * ```\n *\n * @param contract - an instance of a {@link SmartContract}\n * @returns a mutation object that can be used to grant a member of a role on the contract\n * @beta\n */\nexport function useGrantRole<TContract extends ContractWithRoles>(\n  contract: RequiredParam<TContract>,\n) {\n  const activeChainId = useActiveChainId();\n  const contractAddress = contract?.getAddress();\n  const queryClient = useQueryClient();\n\n  return useMutation(\n    async (params: {\n      role: RolesForContract<TContract>;\n      address: WalletAddress;\n    }) => {\n      invariant(contract, \"No contract provided\");\n      invariant(contract.roles, \"Contract does not support roles\");\n      await contract.roles.grant(params.role as any, params.address);\n    },\n    {\n      onSettled: () =>\n        invalidateContractAndBalances(\n          queryClient,\n          contractAddress,\n          activeChainId,\n        ),\n    },\n  );\n}\n\n/**\n * Use this to revoke a {@link WalletAddress} a specific role on a {@link SmartContract}\n *\n * @example\n * ```jsx\n * const Component = () => {\n *   const {\n *     mutate: revokeRole,\n *     isLoading,\n *     error,\n *   } = useRevokeRole(SmartContract);\n *\n *   if (error) {\n *     console.error(\"failed to revoke role\", error);\n *   }\n *\n *   return (\n *     <button\n *       disabled={isLoading}\n *       onClick={() => revokeRole({  role: \"admin\", address: \"0x123\" })}\n *     >\n *       Revoke Role\n *     </button>\n *   );\n * };\n * ```\n *\n * @param contract - an instance of a {@link SmartContract}\n * @returns a mutation object that can be used to revoke a role from a member on the contract\n * @beta\n */\nexport function useRevokeRole<TContract extends ContractWithRoles>(\n  contract: RequiredParam<TContract>,\n) {\n  const activeChainId = useActiveChainId();\n  const contractAddress = contract?.getAddress();\n  const queryClient = useQueryClient();\n  return useMutation(\n    async (params: {\n      role: RolesForContract<TContract>;\n      address: WalletAddress;\n    }) => {\n      invariant(contract, \"No contract provided\");\n      invariant(contract.roles, \"Contract does not support roles\");\n      await contract.roles.revoke(params.role as any, params.address);\n    },\n    {\n      onSettled: () =>\n        invalidateContractAndBalances(\n          queryClient,\n          contractAddress,\n          activeChainId,\n        ),\n    },\n  );\n}\n"]}